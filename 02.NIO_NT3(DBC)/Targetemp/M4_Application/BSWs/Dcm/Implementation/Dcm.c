/**********************************************************************************************************************
 *  COPYRIGHT
 *  -------------------------------------------------------------------------------------------------------------------
 *  \verbatim
 *  Copyright (c) 2022 by Vector Informatik GmbH.                                                  All rights reserved.
 *
 *                This software is copyright protected and proprietary to Vector Informatik GmbH.
 *                Vector Informatik GmbH grants to you only those rights as set out in the license conditions.
 *                All other rights remain with Vector Informatik GmbH.
 *  \endverbatim
 *  -------------------------------------------------------------------------------------------------------------------
 *  FILE DESCRIPTION
 *  -----------------------------------------------------------------------------------------------------------------*/
/**        \file  Dcm.c
 *         \unit  NoUnit
 *        \brief  Implementation of DCM core
 *
 *      \details  MICROSAR DCM based on AR 4.0.3
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 *  REVISION HISTORY
 *  -------------------------------------------------------------------------------------------------------------------
 *  Refer to the module's header file.
 *
 *  FILE VERSION
 *  -------------------------------------------------------------------------------------------------------------------
 *  Refer to the module's header file.
 *********************************************************************************************************************/
#define DCM_SOURCE

#ifdef __PRQA__                                                                                                                                      /* COV_DCM_UNSUPPORTED XF */
# pragma PRQA_MACRO_MESSAGES_OFF "Dcm_UtiGetReqData" 2985 /* MD_Dcm_Redundant_2985 */
# pragma PRQA_MACRO_MESSAGES_OFF "Dcm_UtiGetResData" 2985 /* MD_Dcm_Redundant_2985 */
                                                                                                                                                     /* PRQA S 2991 EOF */ /* MD_Dcm_ConstExpr */
                                                                                                                                                     /* PRQA S 2992 EOF */ /* MD_Dcm_ConstExpr */
                                                                                                                                                     /* PRQA S 2995 EOF */ /* MD_Dcm_ConstExpr */
                                                                                                                                                     /* PRQA S 2996 EOF */ /* MD_Dcm_ConstExpr */
#endif
/**********************************************************************************************************************
 *  INCLUDES
 *********************************************************************************************************************/
#include "Dcm.h"
#include "Rte_Dcm.h"
#include "Dcm_TskMgrInt.h"
#if (DCM_SVC_2C_NVRAM_SUPPORT_ENABLED == STD_ON)
# include "NvM.h"
#endif /* (DCM_SVC_2C_NVRAM_SUPPORT_ENABLED == STD_ON) */
#include "PduR_Dcm.h"
#include "ComM_Dcm.h"
#if ((DCM_DIAG_NOTIF_BSWM_APPL_UPDATED_ENABLED == STD_ON) || \
    (DCM_SVC_28_SUPPORT_ENABLED == STD_ON))
# include "BswM_Dcm.h"
#endif /* ((DCM_DIAG_NOTIF_BSWM_APPL_UPDATED_ENABLED == STD_ON) || \
 (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)) */
#include "Dcm_Int.h"

/**********************************************************************************************************************
 *  VERSION CHECK
 *********************************************************************************************************************/
#if ((DCM_SW_MAJOR_VERSION != 17u) || \
    (DCM_SW_MINOR_VERSION !=  5u) || \
    (DCM_SW_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm.h are inconsistent"
#endif
#if ((DCM_CFG_MAJOR_VERSION != 17u) || \
    (DCM_CFG_MINOR_VERSION !=  5u) || \
    (DCM_CFG_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_Cfg.h are inconsistent"
#endif
#if ((DCM_LCFG_MAJOR_VERSION != 17u) || \
    (DCM_LCFG_MINOR_VERSION !=  5u) || \
    (DCM_LCFG_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_Lcfg.h are inconsistent"
#endif
#if ((DCM_PBCFG_MAJOR_VERSION != 17u) || \
    (DCM_PBCFG_MINOR_VERSION !=  5u) || \
    (DCM_PBCFG_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_PBcfg.h are inconsistent"
#endif

/**********************************************************************************************************************
 *  LOCAL CONSTANT MACROS
 *********************************************************************************************************************/
#if (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON)
/*! Authentication RID access rights validation support */
# if (DCM_SVC_29_APCE_INTERNAL == STD_ON) && \
     (DCM_SVC_31_SUPPORT_ENABLED == STD_ON)
#  define DCM_AUTHMGR_RID_CHECK_ENABLED                              STD_ON
# else
#  define DCM_AUTHMGR_RID_CHECK_ENABLED                              STD_OFF
# endif

/*! Authentication DID access rights validation support */
# if (DCM_SVC_29_APCE_INTERNAL == STD_ON) && \
     (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)
#  define DCM_AUTHMGR_DID_CHECK_ENABLED                              STD_ON
# else
#  define DCM_AUTHMGR_DID_CHECK_ENABLED                              STD_OFF
# endif
#endif /* (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
# define DCM_NET_CONN_LOCK_ENABLED                                   STD_ON
#else
# define DCM_NET_CONN_LOCK_ENABLED                                   STD_OFF
#endif
/*! Specifies whether at least one diagnostic service needs global data storage.
    Extend this list if needed when adding a new diagnostic service with post-request memory */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_29_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
# define DCM_DIAG_SVC_CONTEXT_ENABLED                                STD_ON
#else
# define DCM_DIAG_SVC_CONTEXT_ENABLED                                STD_OFF
#endif

/*! Specifies whether the sequence check for services with sub-functions is active */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_29_SUPPORT_ENABLED == STD_ON)
# define DCM_DIAG_SF_SEQUENCE_CHECK_SUPPORT_ENABLED                  STD_ON
#else
# define DCM_DIAG_SF_SEQUENCE_CHECK_SUPPORT_ENABLED                  STD_OFF
#endif

#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON) || \
    (DCM_DIAG_SVC_CONTEXT_ENABLED == STD_ON) || \
    (DCM_DIAG_SPECIFIC_CAUSE_CODE_ENABLED == STD_ON) || \
    ((DCM_VARMGR_MODE_POSTBUILD_ANY_ENABLED == STD_ON) && (DCM_VARMGR_SUPPORT_ENABLED == STD_ON)) || \
    (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
# define DCM_DIAG_CONTEXT_ENABLED                                    STD_ON
#else
# define DCM_DIAG_CONTEXT_ENABLED                                    STD_OFF
#endif
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/* Consistent configuration checks */
# if (DCM_NET_PERIODIC_TX_ENABLED == STD_OFF)
#  error "Service 0x2A is enabled, but no periodic messages have been configured for Dcm. Please, refer to the Dcm TechRef for SID 0x2A configuration aspect."
# endif
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
#  define DCM_SVC_2C_RACE_CONDITION_READ_ENABLED                     STD_ON
# else
#  define DCM_SVC_2C_RACE_CONDITION_READ_ENABLED                     STD_OFF
# endif

# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
#  error "Service 0x2C is not allowed when any paged DID is configured!"
# endif
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */

/*! ComM notification allowance states */
#define DCM_NET_COMM_ACTIVE                                          ((Dcm_NetActiveDiagnosticType)TRUE)  /*!< Do notify ComM for ActiveDiagnostics (default state) */
#define DCM_NET_COMM_NOT_ACTIVE                                      ((Dcm_NetActiveDiagnosticType)FALSE) /*!< Do NOT notify ComM for ActiveDiagnostics (sleep prevention by DCM is inhibited by application) */

/*! Network variant/non-variant configuration abstraction */
#define Dcm_PbCfgNetNumRxPduIds                                      (Dcm_NetCfgGetNumRxPduIds(Dcm_SingletonContext.Network.ComVariant))
#define Dcm_PbCfgNetNumTxPduIds                                      (Dcm_NetCfgGetNumTxPduIds(Dcm_SingletonContext.Network.ComVariant))
#define Dcm_PbCfgNetCanTpRxPduIdMin                                  (Dcm_NetCfgGetMinCanTpRxPduId(Dcm_SingletonContext.Network.ComVariant))
#define Dcm_PbCfgNetCanTpRxPduIdMax                                  (Dcm_NetCfgGetMaxCanTpRxPduId(Dcm_SingletonContext.Network.ComVariant))
#define Dcm_PbCfgNetNumCanRxPduIds                                   (Dcm_NetCfgGetNumCanRxPduIds(Dcm_SingletonContext.Network.ComVariant))
#define Dcm_PbCfgNetNumPerTxObjects                                  (Dcm_NetCfgGetNumPerTxObjects(Dcm_SingletonContext.Network.ComVariant))
#define Dcm_PbCfgNetNumConnections                                   (Dcm_NetCfgGetNumConnections(Dcm_SingletonContext.Network.ComVariant))
#define Dcm_PbCfgNetNumProtocols                                     (Dcm_NetCfgGetNumProtocols(Dcm_SingletonContext.Network.ComVariant))
#define Dcm_PbCfgNetNumComMChannels                                  (Dcm_NetCfgGetNumComMChannels(Dcm_SingletonContext.Network.ComVariant))
#define Dcm_PbCfgNetNumBuffers                                       (Dcm_NetCfgGetNumBuffers(Dcm_SingletonContext.Network.ComVariant))
#define Dcm_PbCfgNetNumTransportObjects                              (Dcm_NetCfgGetNumTranspObjects(Dcm_SingletonContext.Network.ComVariant))
#define Dcm_PbCfgNetNumAllComMChannels                               (Dcm_NetCfgGetNumAllComMChannels(Dcm_SingletonContext.Network.ComVariant))

#define Dcm_PbCfgNetRxPduInfo                                        (Dcm_NetCfgGetRxPduInfo(Dcm_SingletonContext.Network.ComVariant))
#define Dcm_PbCfgNetConnectionInfo                                   (Dcm_NetCfgGetConnectionInfo(Dcm_SingletonContext.Network.ComVariant))
#define Dcm_PbCfgNetProtocolInfo                                     (Dcm_NetCfgGetProtocolInfo(Dcm_SingletonContext.Network.ComVariant))
#define Dcm_PbCfgNetConnComMChannelMap                               (Dcm_NetCfgGetNetConnComMChannelMap(Dcm_SingletonContext.Network.ComVariant))
#define Dcm_PbCfgNetNetworkHdlLookUp                                 (Dcm_NetCfgGetNetworkHdlLookUp(Dcm_SingletonContext.Network.ComVariant))
#define Dcm_PbCfgNetTxPdu2ConnMap                                    (Dcm_NetCfgGetTxPdu2ConnMap(Dcm_SingletonContext.Network.ComVariant))
#define Dcm_PbCfgNetPerTxPdu2RsrsMap                                 (Dcm_NetCfgGetPerTxPdu2RsrsMap(Dcm_SingletonContext.Network.ComVariant))
#define Dcm_PbCfgNetPerTxPduIdInfo                                   (Dcm_NetCfgGetPerTxPduIdInfo(Dcm_SingletonContext.Network.ComVariant))
#define Dcm_PbCfgNetComCtrlChannelListAll                            (Dcm_NetCfgGetComCtrlChannelListAll(Dcm_SingletonContext.Network.ComVariant))
#define Dcm_PbCfgNetAllComMChannelMap                                (Dcm_NetCfgGetNetAllComMChannelMap(Dcm_SingletonContext.Network.ComVariant))
#define Dcm_PbCfgNetCanTp2DcmRxPduIdMap                              (Dcm_NetCfgGetCanTp2DcmRxPduIdMap(Dcm_SingletonContext.Network.ComVariant))

#if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
# define Dcm_PbRamNetBufferContext                                   (Dcm_SingletonContext.Network.RamVariant.BufferContexts)
# define Dcm_PbRamNetTransportObject                                 (Dcm_SingletonContext.Network.RamVariant.TranspObjects)
# define Dcm_PbRamNetComMContext                                     (Dcm_SingletonContext.Network.RamVariant.ComMContexts)
# define Dcm_PbRamNetPeriodicTxObject                                (Dcm_SingletonContext.Network.RamVariant.PeriodicTxObjects)
# define Dcm_PbRamNetConnHdl2TObjMap                                 (Dcm_SingletonContext.Network.RamVariant.ConnHdl2TObjIdMap)
# define Dcm_PbRamNetComCtrlChannels                                 (Dcm_SingletonContext.Network.RamVariant.ComCtrlChannels)
#else
# define Dcm_PbRamNetBufferContext                                   (Dcm_SingletonContext.Network.BufferContext)
# define Dcm_PbRamNetTransportObject                                 (Dcm_SingletonContext.Network.TransportObject)
# define Dcm_PbRamNetComMContext                                     (Dcm_SingletonContext.Network.ComMContext)
# define Dcm_PbRamNetPeriodicTxObject                                (Dcm_SingletonContext.Network.PeriodicTxContext.TxObject)
# define Dcm_PbRamNetConnHdl2TObjMap                                 (Dcm_SingletonContext.Network.ConnHdl2TObjIdMap)
# define Dcm_PbRamNetComCtrlChannels                                 (Dcm_SingletonContext.Network.ComCtrlChannels)
#endif

#if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
# define Dcm_PbCfgNetBufferInfo                                      (Dcm_SingletonContext.Network.RomVariant.BufferInfo)
#else
# define Dcm_PbCfgNetBufferInfo                                      Dcm_CfgNetBufferInfo
#endif

#if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
/*! Converts a Dcm related CanTp PduID to its corresponding DcmRxPduId */
# define Dcm_NetGetDcmRxPduIdOfCanTpPduId(canTpPduId)                (Dcm_PbCfgNetCanTp2DcmRxPduIdMap[(canTpPduId)-Dcm_PbCfgNetCanTpRxPduIdMin])     /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#else
# define Dcm_NetGetDcmRxPduIdOfCanTpPduId(canTpPduId)                /* not used */
#endif

/*! Retrieves diagnostic protocol specific P2 time justification */
#define Dcm_NetGetP2AdjTime(protocolIdx)                             (Dcm_NetGetProtObjOfProtId(protocolIdx)->SrvAdjTime.P2)                         /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
/*! Retrieves diagnostic protocol specific P2* time justification */
#define Dcm_NetGetP2StarAdjTime(protocolIdx)                         (Dcm_NetGetProtObjOfProtId(protocolIdx)->SrvAdjTime.P2Star)                     /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

/*! USDT transport object states */
#define DCM_NET_TOBJ_STATE_FREE                                      ((Dcm_NetTransportObjectStateType)0x00u)  /*!< Free to be used */
#define DCM_NET_TOBJ_STATE_ONRX                                      ((Dcm_NetTransportObjectStateType)0x01u)  /*!< USDT reception in progress */
#define DCM_NET_TOBJ_STATE_RX_END                                    ((Dcm_NetTransportObjectStateType)0x02u)  /*!< USDT reception already finished */
#define DCM_NET_TOBJ_STATE_PREPTX                                    ((Dcm_NetTransportObjectStateType)0x04u)  /*!< Ready for USDT transmission */
#define DCM_NET_TOBJ_STATE_ONTX                                      ((Dcm_NetTransportObjectStateType)0x08u)  /*!< USDT transmission in progress */
#define DCM_NET_TOBJ_STATE_READY                                     ((Dcm_NetTransportObjectStateType)0x10u)  /*!< Transmission (Rx/Tx) finished but transport object still in use */
#define DCM_NET_TOBJ_STATE_RESERVED                                  ((Dcm_NetTransportObjectStateType)0x20u)  /*!< Transport object is allocated, but not yet in use (transmission) */

/*! USDT transport object flags */
#define DCM_NET_TOBJ_FLAG_NONE                                       ((Dcm_NetTransportObjectFlagType)0x0000u)  /*!< No flags set */
#define DCM_NET_TOBJ_FLAG_INTERNAL                                   ((Dcm_NetTransportObjectFlagType)0x0001u)  /*!< The transport object is used for internal (virtual) request (e.g. RoE) */
#define DCM_NET_TOBJ_FLAG_COPYHEAD                                   ((Dcm_NetTransportObjectFlagType)0x0002u)  /*!< The diagnostic request head shall be copied into a temporary buffer */
#define DCM_NET_TOBJ_FLAG_BUSY                                       ((Dcm_NetTransportObjectFlagType)0x0004u)  /*!< Current diagnostic request reception is a pseudo-parallel one */
#define DCM_NET_TOBJ_FLAG_CANCELED                                   ((Dcm_NetTransportObjectFlagType)0x0008u)  /*!< Current message transmission (Rx/Tx) was canceled */
#define DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ                               ((Dcm_NetTransportObjectFlagType)0x0010u)  /*!< RCR-RP state: just requested to be sent */
#define DCM_NET_TOBJ_FLAG_RCRRP_ON_TX                                ((Dcm_NetTransportObjectFlagType)0x0020u)  /*!< RCR-RP state: currently on transmission */
#define DCM_NET_TOBJ_FLAG_RCRRP_SENT                                 ((Dcm_NetTransportObjectFlagType)0x0040u)  /*!< RCR-RP state: at least once has been sent */
#define DCM_NET_TOBJ_FLAG_RCRRP_TYPE_APPL                            ((Dcm_NetTransportObjectFlagType)0x0080u)  /*!< RCR-RP state: current one was triggered by the application */
#define DCM_NET_TOBJ_FLAG_OBSOLETE                                   ((Dcm_NetTransportObjectFlagType)0x0100u)  /*!< Transport object is obsolete and shall be canceled at later time. The difference to FLAG_CANCELED is that the ongoing transmission is not affected */
#define DCM_NET_TOBJ_FLAG_IGNORE                                     ((Dcm_NetTransportObjectFlagType)0x0200u)  /*!< Transport object shall not restart S3 and Keep-Alive Timers */

/*! USDT transport object response types */
#define DCM_NET_TOBJ_RESTYPE_NONE                                    ((Dcm_NetResponseType)0u)  /*!< No response is ongoing */
#define DCM_NET_TOBJ_RESTYPE_LINEAR                                  ((Dcm_NetResponseType)1u)  /*!< Final response (linear buffer) */
#define DCM_NET_TOBJ_RESTYPE_PAGED                                   ((Dcm_NetResponseType)2u)  /*!< Final response (paged-buffer) */
#define DCM_NET_TOBJ_RESTYPE_RCRRP                                   ((Dcm_NetResponseType)3u)  /*!< RCR-RP response */
#define DCM_NET_TOBJ_RESTYPE_UNSOLICITED                             ((Dcm_NetResponseType)4u)  /*!< Unsolicited (response without request) (e.g. FBL final response after power on/reset) */
#define DCM_NET_TOBJ_RESTYPE_SIMPLE                                  ((Dcm_NetResponseType)5u)  /*!< Simply respond (without processing) e.g. final negative response NRC 0x21 for pseudo parallel client handling or protocol switch rejection */

/*! Diagnostic client USDT connection properties */
#define DCM_NET_CONN_PROP_NONE                                       ((Dcm_CfgNetConnPropertiesType)0x00u)  /*!< Nothing special */
#define DCM_NET_CONN_PROP_TX_ON_FUNC_RX                              ((Dcm_CfgNetConnPropertiesType)0x01u)  /*!< No response to be sent on functional requests over this connection */
#define DCM_NET_CONN_PROP_NO_MAIN_TX                                 ((Dcm_CfgNetConnPropertiesType)0x02u)  /*!< The USDT connection does not contain a PduRTxPduId */

#define DCM_NET_INVALID_CONNHDL                                      ((Dcm_CfgNetNetIdRefMemType)Dcm_PbCfgNetNumConnections)
#define DCM_NET_INVALID_TOBJID                                       ((Dcm_CfgNetTObjHandleMemType)Dcm_PbCfgNetNumTransportObjects)
#define DCM_NET_INVALID_PROTID                                       ((Dcm_NetProtRefMemType)Dcm_PbCfgNetNumProtocols)

/*! State definitions for periodic transport object */
#define DCM_NET_PERIODIC_TX_STATE_FREE                               ((Dcm_NetPerTxObjStateMemType)0)
#define DCM_NET_PERIODIC_TX_STATE_RESERVED                           ((Dcm_NetPerTxObjStateMemType)1)
#define DCM_NET_PERIODIC_TX_STATE_QUEUED                             ((Dcm_NetPerTxObjStateMemType)2)
#define DCM_NET_PERIODIC_TX_STATE_ONTX                               ((Dcm_NetPerTxObjStateMemType)3)

#define DCM_NET_INVALID_PTXOBJ_HANDLE                                ((Dcm_CfgNetPTxObjHandleMemType)Dcm_PbCfgNetNumPerTxObjects)

/*! AR 4.1.2+ PduR API argument values adaption */
#define DCM_NET_ARENV_NTFRSLT_OK                                     E_OK
#define DCM_NET_ARENV_NTFRSLT_NOT_OK                                 E_NOT_OK
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
# define DCM_PAGEDBUFFER_STATE_INACTIVE                              (Dcm_PagedBufferStateType)0x00u /*!< No paged-buffer transmission in progress */
# define DCM_PAGEDBUFFER_STATE_ACTIVATED                             (Dcm_PagedBufferStateType)0x01u /*!< Paged-buffer transmission activated, but not yet passed to the PduR */
# define DCM_PAGEDBUFFER_STATE_CANCELED                              (Dcm_PagedBufferStateType)0x02u /*!< Paged-buffer transmission terminated prior passing it to the PduR */
# define DCM_PAGEDBUFFER_STATE_ONTX                                  (Dcm_PagedBufferStateType)0x03u /*!< Paged-buffer transmission ongoing (passed to the PduR) */

# define DCM_PAGEDBUFFER_ALL_DATA_PROVIDED                           (Dcm_PagedBufferDataProvisionStateType)0x00u /*!< All data provided */
# define DCM_PAGEDBUFFER_PAGE_DATA_PROVIDED                          (Dcm_PagedBufferDataProvisionStateType)0x01u /*!< Already some data provided */
# define DCM_PAGEDBUFFER_WAIT_FOR_DATA                               (Dcm_PagedBufferDataProvisionStateType)0x02u /*!< Waiting for data provision */
#endif /* (DCM_PAGED_BUFFER_ENABLED == STD_ON) */
/*! Timer thread ability types */
#define DCM_TMR_ATR_THREAD_SINGLE                                    ((Dcm_TmrTimerAttributeType)0x00u) /*!< Timer does not support multi threading */
#define DCM_TMR_ATR_THREAD_MULTI                                     ((Dcm_TmrTimerAttributeType)0x01u) /*!< Timer supports multi threading */
/*! Network to diagnostic variant bridge abstraction */
#if (DCM_VARMGR_MODE_POSTBUILD_ANY_ENABLED == STD_ON) && (DCM_VARMGR_SUPPORT_ENABLED == STD_ON)
# define Dcm_PbCfgDiagSvcId2ProtMap                                  (Dcm_SingletonContext.Diag.Svc2ProtocolMap)
#else
# define Dcm_PbCfgDiagSvcId2ProtMap                                  Dcm_CfgDiagSvcId2ProtMap
#endif

#if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON) && (DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
# define Dcm_PbCfgDiagVariantFilter                                  (Dcm_SingletonContext.Diag.RomVariant.VariantFilter)
#else
# define Dcm_PbCfgDiagVariantFilter                                  Dcm_CfgVarMgrVariantTable
#endif
/*! Service 0x10 processing steps */
#define DCM_SVC10_PROGRESS_CHECK_ACCESS                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
#define DCM_SVC10_PROGRESS_TRIGGER_RESET                             ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1u))
#define DCM_SVC10_PROGRESS_WAIT_RESET_ACK                            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 2u))
#define DCM_SVC10_PROGRESS_WAIT_RCRRP_ACK                            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 3u))
#define DCM_SVC10_PROGRESS_SET_PRGCOND                               ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 4u))
#if (DCM_SVC_22_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC22_PROGRESS_DIDLOOKUP                                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
# define DCM_SVC22_PROGRESS_CHECKCONDITION                           ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1u))
# define DCM_SVC22_PROGRESS_GETLENGTH                                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 2u))
# define DCM_SVC22_PROGRESS_READDATA                                 ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 3u))
#endif /* (DCM_SVC_22_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_24_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC24_PROGRESS_DIDLOOKUP                                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
# define DCM_SVC24_PROGRESS_EXECUTEOP                                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1u))
#endif /* (DCM_SVC_24_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
/*! Service 0x27 processing steps */
# define DCM_SVC27_PROGRESS_SEEDPROCESSOR                            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
# define DCM_SVC27_PROGRESS_KEYPROCESSOR                             ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1u))
# define DCM_SVC27_PROGRESS_SETATTEMPTCNTR                           ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 2u))
# define DCM_SVC27_PROGRESS_SEEDREPEATER                             ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 3u))
# define DCM_SVC27_PROGRESS_KEYREPEATER                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 4u))
# define DCM_SVC27_PROGRESS_CHECKATTEMPTSEXCEEDED                    ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 5u))

/*! Get-Seed port operation classes  */
# define DCM_SVC27_OPCLS_SEED_WITHOUT_ADR                            ((Dcm_Svc27OpClassType)0)
# define DCM_SVC27_OPCLS_SEED_WITH_ADR                               ((Dcm_Svc27OpClassType)1)
# define DCM_SVC_27_LEVEL_MASK                                       (Dcm_UtiGetMaskFromXintType(uint32, DCM_STATE_SECURITY_NUM_LEVELS))
# define DCM_SVC_27_SEED_LVL_INVALID                                 ((uint8)0x00u)
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_29_SUPPORT_ENABLED == STD_ON)
/*! Service 0x29 processing steps */
# define DCM_SVC29_PROGRESS_SUBFUNCTION                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
# define DCM_SVC29_PROGRESS_WAITCERTVERIFY                           ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1u))
# define DCM_SVC29_PROGRESS_CERTVERIFIED                             ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 2u))
# define DCM_SVC29_PROGRESS_WAITCHALLENGEGEN                         ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 3u))
# define DCM_SVC29_PROGRESS_CHALLENGEGEN                             ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 4u))
# define DCM_SVC29_PROGRESS_SUBFUNC02_WAITCHALLENGESIGNED            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 5u))
# define DCM_SVC29_PROGRESS_SUBFUNC02_CHALLENGESIGNED                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 6u))
# define DCM_SVC29_PROGRESS_SUBFUNC03_WAITSIGVERIFY                  ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 7u))
# define DCM_SVC29_PROGRESS_SUBFUNC03_ROLEREAD                       ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 8u))
# define DCM_SVC29_PROGRESS_SUBFUNC03_SERVICEWHITELISTREAD           ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 9u))
# define DCM_SVC29_PROGRESS_SUBFUNC03_DIDWHITELISTREAD               ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 10u))
# define DCM_SVC29_PROGRESS_SUBFUNC03_RIDWHITELISTREAD               ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 11u))
# define DCM_SVC29_PROGRESS_SUBFUNC03_MEMWHITELISTREAD               ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 12u))
# define DCM_SVC29_PROGRESS_PERSIST_AUTHENTICATION                   ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 13u))

/*! Service 0x29 subfunction references */
# define DCM_SVC29_SUBFUNC_DEAUTHENTICATE                            ((uint8)0x00u)
# define DCM_SVC29_SUBFUNC_VERIFY_CERT_UNIDIR                        ((uint8)0x01u)
# define DCM_SVC29_SUBFUNC_VERIFY_CERT_BIDIR                         ((uint8)0x02u)
# define DCM_SVC29_SUBFUNC_PROOF_OF_OWNERSHIP                        ((uint8)0x03u)
# define DCM_SVC29_SUBFUNC_TRANSMIT_CERTIFICATE                      ((uint8)0x04u)

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON) || (DCM_SVC_29_04_SUPPORT_ENABLED == STD_ON)
/*! Service 0x29 UDS AuthenticationReturnParameter */
#  define DCM_SVC29_AUTH_CONFIG_APCE                                 ((uint8)0x02u)
#  define DCM_SVC29_DEAUTH_SUCCESSFUL                                ((uint8)0x10u)
#  define DCM_SVC29_OWNERSHIP_VERIFICATION_NECESSARY                 ((uint8)0x11u)
#  define DCM_SVC29_OWNERSHIP_VERIFIED_AUTHENTICATION_COMPLETE       ((uint8)0x12u)
#  define DCM_SVC29_CERTIFICATE_VERIFIED                             ((uint8)0x13u)

/*! Service 0x29 A_Data fields byte length */
#  define DCM_SVC29_REQ_LENGTH_FIELD_BYTELEN                         ((uint32)0x02u)
#  define DCM_SVC29_CHALLENGE_LEN_INDEX                              (0x01u)
#  define DCM_SVC29_CHALLENGE_DATA_START_INDEX                       (0x03u)

/*! Service 0x29 processing states for asynchronous callback handling */
#  define DCM_SVC29_CBK_PROC_STATE_IDLE                              ((Dcm_Svc29ProcessingState)0x00u)
#  define DCM_SVC29_CBK_PROC_STATE_CSM_CANCELLED                     ((Dcm_Svc29ProcessingState)0x01u)
#  define DCM_SVC29_CBK_PROC_STATE_KEYM_CANCELLED                    ((Dcm_Svc29ProcessingState)0x02u)
#  define DCM_SVC29_CBK_PROC_STATE_VERIFY_CERT                       ((Dcm_Svc29ProcessingState)0x03u)
#  define DCM_SVC29_CBK_PROC_STATE_VERIFY_CERT_DONE                  ((Dcm_Svc29ProcessingState)0x04u)
#  define DCM_SVC29_CBK_PROC_STATE_GENERATE_CHALLENGE                ((Dcm_Svc29ProcessingState)0x05u)
#  define DCM_SVC29_CBK_PROC_STATE_GENERATE_CHALLENGE_DONE           ((Dcm_Svc29ProcessingState)0x06u)
#  define DCM_SVC29_CBK_PROC_STATE_SIGN_CHALLENGE                    ((Dcm_Svc29ProcessingState)0x07u)
#  define DCM_SVC29_CBK_PROC_STATE_SIGN_CHALLENGE_DONE               ((Dcm_Svc29ProcessingState)0x08u)
#  define DCM_SVC29_CBK_PROC_STATE_VERIFY_POOW                       ((Dcm_Svc29ProcessingState)0x09u)
#  define DCM_SVC29_CBK_PROC_STATE_VERIFY_POOW_DONE                  ((Dcm_Svc29ProcessingState)0x0Au)
# endif
#endif /* (DCM_SVC_29_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC2A_RATE_TYPE_SLOW                                    ((Dcm_Svc2ASchedRateMemType)0)
# define DCM_SVC2A_RATE_TYPE_MED                                     ((Dcm_Svc2ASchedRateMemType)1)
# define DCM_SVC2A_RATE_TYPE_FAST                                    ((Dcm_Svc2ASchedRateMemType)2)

# define DCM_SVC2A_RATE_TYPE_MASK                                    ((Dcm_Svc2ASchedRateMemType)0x03u)

# define DCM_SVC2A_RATE_TYPE_STOPPED                                 ((Dcm_Svc2ASchedRateMemType)0x10u)
# define DCM_SVC2A_RATE_TYPE_RESERVED                                ((Dcm_Svc2ASchedRateMemType)0x40u)
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC2A_PROGRESS_SCHEDULEDDID_LOOKUP                      ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u)) /*!< Look up DIDs */
# define DCM_SVC2A_PROGRESS_DID_CHECKCONDITION                       ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1u)) /*!< Check conditions */
# define DCM_SVC2A_PROGRESS_DID_GETLENGTH                            ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 2u)) /*!< Obtain total length of the DID */
# define DCM_SVC2A_PROGRESS_STOPPED_DID_LOOKUP                       ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 3u)) /*!< Loop up DIDs and stop periodic transmission */

/*! Service 0x2A transmissionMode parameter */
# define DCM_SVC_2A_SEND_AT_SLOW_RATE                                ((Dcm_Svc2ATransmissionModeType)0x01u)  /*!< Server shall transmit at a slow rate */
# define DCM_SVC_2A_SEND_AT_MEDIUM_RATE                              ((Dcm_Svc2ATransmissionModeType)0x02u)  /*!< Server shall transmit at a medium rate */
# define DCM_SVC_2A_SEND_AT_FAST_RATE                                ((Dcm_Svc2ATransmissionModeType)0x03u)  /*!< Server shall transmit at a fast rate */
# define DCM_SVC_2A_STOP_SENDING                                     ((Dcm_Svc2ATransmissionModeType)0x04u)  /*!< Server stops transmitting periodically/repeatedly */
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC2C_INVALID_DYNDID_HDL                                (Dcm_UtiMaxValueOfUintType(Dcm_CfgDidMgrDynDidHandleMemType))

# define DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED                        0u

# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON) && \
     (DCM_DIDMGR_DYNDID_SRCITEM_CHECK_COND_ENABLED == STD_ON)
#  define DCM_SVC_2C_NUM_PROCESS_CONTEXTS                            2u
#  define DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY                     1u
# else
#  define DCM_SVC_2C_NUM_PROCESS_CONTEXTS                            1u
#  define DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY                     0u
# endif
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC2C_PROGRESS_SUBFUNCTION                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
# define DCM_SVC2C_PROGRESS_01SRC_DIDLOOKUP                          ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1u))
# define DCM_SVC2C_PROGRESS_01SRC_DIDCHECKCONDITIONS                 ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 2u))
# define DCM_SVC2C_PROGRESS_01SRC_DIDGETLENGTH                       ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 3u))
# define DCM_SVC2C_PROGRESS_03_DIDLOOKUP                             ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 4u))
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC2E_PROGRESS_CHECKACCESS                              ((Dcm_RepeaterProgressType)1u)
# define DCM_SVC2E_PROGRESS_WRITEDATA                                ((Dcm_RepeaterProgressType)2u)
#endif /* (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC2F_PROGRESS_CHECKACCESS                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
# define DCM_SVC2F_PROGRESS_EXECUTEOP                                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 1u))
# define DCM_SVC2F_PROGRESS_GETLENGTH                                ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 2u))
# define DCM_SVC2F_PROGRESS_READDATA                                 ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 3u))
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC86_PROGRESS_SUBFUNCTION                              ((Dcm_RepeaterProgressType)(DCM_REPEATER_PROGRESS_USERS_FIRST + 0u))
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */

/**********************************************************************************************************************
 *  LOCAL FUNCTION MACROS
 *********************************************************************************************************************/
#if (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON)
# define Dcm_AuthMgrGetAuthInfoRef(pMsgContext)                      (Dcm_PbCfgNetConnectionInfo[Dcm_NetGetConnHdlOfRxPduId((pMsgContext)->rxPduId)].AuthInfoRef) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

/*! Authentication session timers */
# define Dcm_AuthMgrGetTimerIdx(authInfoRef)                         (authInfoRef)                                                                   /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_AuthMgrTimerGet(authInfoRef)                            (Dcm_SingletonContext.AuthMgr.DelayTime[Dcm_AuthMgrGetTimerIdx((authInfoRef))]) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_AuthMgrTimerReset(authInfoRef)                          (Dcm_AuthMgrTimerSet((authInfoRef), 0u))                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_AuthMgrTimerActive(authInfoRef)                         ((boolean)(Dcm_AuthMgrTimerGet((authInfoRef)) != 0u))                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_AuthMgrTimerExpireMaskReset()                           (Dcm_SingletonContext.AuthMgr.TimerExpiredMask = 0u)                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_AuthMgrTimerExpireMaskGet()                             (Dcm_SingletonContext.AuthMgr.TimerExpiredMask)                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_AuthMgrAnyTimerExpired()                                (Dcm_SingletonContext.AuthMgr.TimerExpiredMask != 0u)
# define Dcm_AuthMgrTimerExpireMaskSetBit(authInfoRef)               ((Dcm_UtiBitOpSet(Dcm_AuthMgrTimerExpiredMaskType, Dcm_SingletonContext.AuthMgr.TimerExpiredMask, Dcm_UtiGetBitFromIndex(uint8_least, Dcm_AuthMgrGetTimerIdx((authInfoRef)))))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
/*! Authentication state check */
# define Dcm_AuthMgrAuthenticationState(authInfoRef)                 (Dcm_AuthMgrNvMData[(authInfoRef)].ConnContext.AuthState)                       /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
/*! Authentication role */
# define Dcm_AuthMgrActiveRole(authInfoRef)                          (Dcm_AuthMgrNvMData[(authInfoRef)].ConnContext.ActiveRole)                      /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
/*! Service white list operations */
# if (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
#  define Dcm_AuthMgrIsGlobalAccessGranted()                         (Dcm_SingletonContext.AuthMgr.GrantGlobalAccess == TRUE)                        /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_AuthMgrSetGlobalAccess(value)                          (Dcm_SingletonContext.AuthMgr.GrantGlobalAccess = (value))                      /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_AuthMgrNumSvcWLElements(authInfoRef)                   (Dcm_AuthMgrNvMData[(authInfoRef)].ConnContext.WLContext.WLServiceContext.NumServiceWLElements) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_AuthMgrSvcWLElemLen(authInfoRef, iter)                 (Dcm_AuthMgrNvMData[(authInfoRef)].ConnContext.WLContext.WLServiceContext.WLServiceElement[iter].WLEntryLength) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_AuthMgrSvcWLElemDataAt(authInfoRef, iter, pos)         (Dcm_AuthMgrNvMData[(authInfoRef)].ConnContext.WLContext.WLServiceContext.WLServiceElement[iter].WLData[pos]) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_AuthMgrSvcWLElemIsSID(authInfoRef, iter, sid)          (Dcm_AuthMgrSvcWLElemDataAt((authInfoRef), (iter), 0u) == (sid))                /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_AuthMgrSvcWLElemIs22(authInfoRef, iter)                (Dcm_AuthMgrSvcWLElemIsSID((authInfoRef), (iter), DCM_DIDMGR_SVC_READ))         /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_AuthMgrSvcWLElemIs2E(authInfoRef, iter)                (Dcm_AuthMgrSvcWLElemIsSID((authInfoRef), (iter), DCM_DIDMGR_SVC_WRITE))        /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_AuthMgrSvcWLElemIs2F(authInfoRef, iter)                (Dcm_AuthMgrSvcWLElemIsSID((authInfoRef), (iter), DCM_DIDMGR_SVC_IOCTRL))       /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_AuthMgrSvcWLElemIsDIDWRIO(authInfoRef, iter)           ((Dcm_AuthMgrSvcWLElemLen((authInfoRef), (iter)) == 3u) && (Dcm_AuthMgrSvcWLElemIs22((authInfoRef), (iter)) || Dcm_AuthMgrSvcWLElemIs2E((authInfoRef), (iter)) || Dcm_AuthMgrSvcWLElemIs2F((authInfoRef), (iter)))) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_AuthMgrSvcWLElemIs31(authInfoRef, iter)                (Dcm_AuthMgrSvcWLElemIsSID((authInfoRef), (iter), 0x31u))                       /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_AuthMgrSvcWLElemIsRID(authInfoRef, iter)               ((Dcm_AuthMgrSvcWLElemLen((authInfoRef), (iter)) == 4u) && Dcm_AuthMgrSvcWLElemIs31((authInfoRef), (iter))) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_AuthMgrSvcWLElemIsDSP(authInfoRef, iter)               (Dcm_AuthMgrSvcWLElemIsDIDWRIO((authInfoRef), (iter)) || Dcm_AuthMgrSvcWLElemIsRID((authInfoRef), (iter))) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# endif
/*! DID white list operations */
# if (DCM_AUTHMGR_WHITELIST_DID_ENABLED == STD_ON)
#  define Dcm_AuthMgrNumDIDWLElements(authInfoRef)                   (Dcm_AuthMgrNvMData[(authInfoRef)].ConnContext.WLContext.WLDidContext.NumDidWLElements) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_AuthMgrDidWLElem(authInfoRef, iter)                    (Dcm_AuthMgrNvMData[(authInfoRef)].ConnContext.WLContext.WLDidContext.WLDidElement[(iter)]) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# endif
/*! RID white list operations */
# if (DCM_AUTHMGR_WHITELIST_RID_ENABLED == STD_ON)
#  define Dcm_AuthMgrNumRIDWLElements(authInfoRef)                   (Dcm_AuthMgrNvMData[(authInfoRef)].ConnContext.WLContext.WLRidContext.NumRidWLElements) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_AuthMgrRidWLElem(authInfoRef, iter)                    (Dcm_AuthMgrNvMData[(authInfoRef)].ConnContext.WLContext.WLRidContext.WLRidElement[(iter)]) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# endif
/*! MEM white list operations */
# if (DCM_AUTHMGR_WHITELIST_MEM_ENABLED == STD_ON)
#  define Dcm_AuthMgrNumMemWLElements(authInfoRef)                   (Dcm_AuthMgrNvMData[(authInfoRef)].ConnContext.WLContext.WLMemContext.NumMemWLElements) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_AuthMgrMemWLElem(authInfoRef, iter)                    (Dcm_AuthMgrNvMData[(authInfoRef)].ConnContext.WLContext.WLMemContext.WLMemElement[(iter)]) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# endif
#endif /* (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON) */
/*! USDT buffer management */
#define Dcm_NetBufferIsFree(pBufferContext)                          ((pBufferContext)->IsInUseCnt == 0u)                                            /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetBufferLock(pBufferContext)                            ((pBufferContext)->IsInUseCnt=1u)                                               /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetBufferRelease(pBufferContext)                         ((pBufferContext)->IsInUseCnt--)                                                /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetBufferUsageEnter(pBufferContext)                      ((pBufferContext)->IsInUseCnt++)                                                /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetBufferUsageLeave(pBufferContext)                      (Dcm_NetBufferRelease(pBufferContext))                                          /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

#define Dcm_NetGetConnHdlOfRxPduId(rxPduId)                          (Dcm_NetCfgGetConnHdlOfRxPduId(Dcm_SingletonContext.Network.ComVariant, (rxPduId))) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#if(DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
# define Dcm_NetIsGenericConnection(connHdl)                         (Dcm_NetCfgIsGenericConnection(Dcm_SingletonContext.Network.ComVariant, (connHdl))) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#endif
#define Dcm_NetGetNodeAddress(connHdl)                               (Dcm_NetCfgGetEcuAddressOfConnHdl(Dcm_SingletonContext.Network.ComVariant, (connHdl))) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetGetTesterAddress(connHdl)                             (Dcm_NetCfgGetTesterAddressOfConnHdl(Dcm_SingletonContext.Network.ComVariant, (connHdl))) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetGetConnHdlOfTxPduId(txPduId)                          (Dcm_PbCfgNetTxPdu2ConnMap[(txPduId)])                                          /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

#define Dcm_NetGetProtIdOfActiveProtocol()                           (Dcm_SingletonContext.Network.ActiveProtocol)                                   /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetGetProtIdOfConnection(connHdl)                        (Dcm_PbCfgNetConnectionInfo[(connHdl)].ProtRef)                                 /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetGetProtIdOfTranspObj(pTranspObj)                      (Dcm_NetGetProtIdOfConnection((pTranspObj)->ConnHdl))                           /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetGetProtIdOfMsgContext(pMsgContext)                    (Dcm_NetGetProtIdOfConnection(Dcm_NetGetConnHdlOfRxPduId((pMsgContext)->rxPduId))) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

#define Dcm_NetGetProtObjOfProtId(protId)                            (&Dcm_PbCfgNetProtocolInfo[(protId)])                                           /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetGetProtObjOfConnection(connHdl)                       (Dcm_NetGetProtObjOfProtId(Dcm_NetGetProtIdOfConnection(connHdl)))              /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetGetProtObjOfTranspObj(pTranspObj)                     (Dcm_NetGetProtObjOfConnection((pTranspObj)->ConnHdl))                          /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

#define Dcm_NetGetThreadIdOfTranspObj(pTranspObj)                    (Dcm_NetGetProtObjOfTranspObj((pTranspObj))->ThreadId)                          /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
# define Dcm_NetPeriodicMsgGetTxPduIdByConn(connHdl, txObjIdx)       (Dcm_PbCfgNetPerTxPduIdInfo[Dcm_PbCfgNetConnectionInfo[(connHdl)].PeriodicTxRef + (txObjIdx)]) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_NetPeriodicMsgGetNumMsgsFor(connHdl)                    (Dcm_PbCfgNetConnectionInfo[(connHdl)].NumPeriodicTxPduIds)                     /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

# define Dcm_NetPeriodicMsgGetTxPduIdCurrConn(txObjIdx)              (Dcm_NetPeriodicMsgGetTxPduIdByConn(Dcm_NetPeriodicMsgGetConnection(),(txObjIdx))) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

# define Dcm_NetPeriodicMsgSetConnection(connHdl)                    (Dcm_SingletonContext.Network.PeriodicTxContext.ConnHdlInUse = (connHdl))       /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_NetPeriodicMsgGetConnection()                           (Dcm_SingletonContext.Network.PeriodicTxContext.ConnHdlInUse)                   /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_NetPeriodicMsgSupportedFor(connHdl)                     (Dcm_NetPeriodicMsgGetNumMsgsFor(connHdl) != 0u)                                /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

# define Dcm_NetPeriodicMsgNumMsgsCurrConnection()                   (Dcm_NetPeriodicMsgGetNumMsgsFor(Dcm_NetPeriodicMsgGetConnection()))            /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_NetPeriodicMsgGetHandleFromTxPduId(txPduId)             ((Dcm_CfgNetPTxObjHandleOptType)(Dcm_PbCfgNetPerTxPdu2RsrsMap[txPduId]))        /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

# define Dcm_NetPeriodicMsgGetNextMsgHdl()                           (Dcm_SingletonContext.Network.PeriodicTxContext.NextTxObjectHdl)                /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_NetPeriodicMsgResetNextMsgHdl()                         (Dcm_SingletonContext.Network.PeriodicTxContext.NextTxObjectHdl = 0u)           /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_NetPeriodicMsgIncNextMsgHdl()                           (++Dcm_SingletonContext.Network.PeriodicTxContext.NextTxObjectHdl)              /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

# define Dcm_NetPeriodicMsgGetTxObjectSentCntr()                     (Dcm_SingletonContext.Network.PeriodicTxContext.TxObjectSentCntr)               /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_NetPeriodicMsgResetTxObjectSentCntr()                   (Dcm_SingletonContext.Network.PeriodicTxContext.TxObjectSentCntr = 0u)          /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_NetPeriodicMsgIncTxObjectSentCntr()                     (++Dcm_SingletonContext.Network.PeriodicTxContext.TxObjectSentCntr)             /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

# define Dcm_NetPeriodicMsgSetClientSrcAddr(clientSrcAddr)           (Dcm_SingletonContext.Network.PeriodicTxContext.ClientSrcAddr = (clientSrcAddr)) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_NetPeriodicMsgGetClientSrcAddr()                        (Dcm_SingletonContext.Network.PeriodicTxContext.ClientSrcAddr)                  /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
#  define Dcm_NetPeriodicMsgGetDelayCntr()                           (Dcm_SingletonContext.Network.PeriodicTxContext.DelayCntr)                      /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_NetPeriodicMsgIncDelayCntr()                           (++Dcm_SingletonContext.Network.PeriodicTxContext.DelayCntr)                    /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_NetPeriodicMsgDecDelayCntr()                           (--Dcm_SingletonContext.Network.PeriodicTxContext.DelayCntr)                    /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_NetPeriodicMsgInitDelayCntr()                          (Dcm_SingletonContext.Network.PeriodicTxContext.DelayCntr = DCM_NET_DELAY_BULK_TRANSMISSION) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

#  define Dcm_NetPeriodicMsgResetNextDelayTimer()                    (Dcm_SingletonContext.Network.PeriodicTxContext.NextDelayTimer = 0u)            /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_NetPeriodicMsgGetNextDelayTimer()                      (Dcm_SingletonContext.Network.PeriodicTxContext.NextDelayTimer)                 /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

#  define Dcm_NetPeriodicMsgGetFastestRate()                         (Dcm_SingletonContext.Network.PeriodicTxContext.FastestRate)                    /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_NetPeriodicMsgInitFastestRate()                        (Dcm_SingletonContext.Network.PeriodicTxContext.FastestRate = DCM_SVC2A_RATE_TYPE_SLOW) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

#  define Dcm_NetGetPeriodicDelayTime(Rate)                          (Dcm_CfgNetPeriodicDelayTime[Rate])                                             /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# else
#  define Dcm_NetPeriodicMsgGetDelayCntr()                           0u
#  define Dcm_NetPeriodicMsgIncDelayCntr()                           /* not used */
#  define Dcm_NetPeriodicMsgDecDelayCntr()                           /* not used */
#  define Dcm_NetPeriodicMsgInitDelayCntr()                          /* not used */

#  define Dcm_NetPeriodicMsgGetFastestRate()                         DCM_SVC2A_RATE_TYPE_SLOW
#  define Dcm_NetPeriodicMsgInitFastestRate()                        /* not used */

#  define Dcm_NetGetPeriodicDelayTime(Rate)                          0u
# endif

# define Dcm_NetPTxObjTimerGet(pPeriodicTxObj)                       ((pPeriodicTxObj)->Timer)                                                       /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_NetPTxObjTimerExpired(pPeriodicTxObj)                   (Dcm_NetPTxObjTimerGet(pPeriodicTxObj) == 0u)                                   /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

#endif /* (DCM_NET_PERIODIC_TX_ENABLED == STD_ON) */

#define Dcm_NetGetSessionConnection()                                (Dcm_SingletonContext.Network.SessionConnection)                                /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetSetSessionConnection(connHdl)                         (Dcm_SingletonContext.Network.SessionConnection = (connHdl))                    /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetGetSessionClientSrcAddr()                             (Dcm_SingletonContext.Network.SessionClientSrcAddr)                             /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetSetSessionClientSrcAddr(clientSrcAddress)             (Dcm_SingletonContext.Network.SessionClientSrcAddr = (clientSrcAddress))        /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

#define Dcm_NetGetComStateByChannelId(channelId)                     (Dcm_PbRamNetComMContext[(channelId)].ComState)                                 /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetGetComStateByConnection(connHdl)                      (Dcm_NetGetComStateByChannelId(Dcm_PbCfgNetConnectionInfo[(connHdl)].NetworkIdRef)) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetGetComStateByRxPduId(rxPduId)                         (Dcm_NetGetComStateByConnection(Dcm_NetGetConnHdlOfRxPduId(rxPduId)))           /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetGetComStateByTranspObject(pTranspObj)                 (Dcm_NetGetComStateByConnection((pTranspObj)->ConnHdl))                         /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

#define Dcm_NetGetProperties(pTranspObj)                             (Dcm_PbCfgNetConnectionInfo[(pTranspObj)->ConnHdl].Properties)                  /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_NetIsPropertieSet(pTranspObj, prop)                      (Dcm_UtiBitOpTest(Dcm_CfgNetConnPropertiesType, Dcm_NetGetProperties(pTranspObj), (prop))) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

#if (DCM_STATE_AUTHENTICATION_ENABLED == STD_ON)
# define Dcm_NetGetAuthInfoRef(connHdl)                              (Dcm_PbCfgNetConnectionInfo[(connHdl)].AuthInfoRef)                             /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#else
# define Dcm_NetGetAuthInfoRef(connHdl)                              /* not used */
#endif
#define Dcm_TmrIsTimerRunning(timerId)                               ( Dcm_UtiBitOpTest(Dcm_TmrMaskMemType, Dcm_SingletonContext.TimerMgr.ControlMask, Dcm_UtiGetBitFromIndex(Dcm_TmrMaskMemType, (timerId))) ) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_TmrSetTimerStopped(timerId)                              ( Dcm_UtiBitOpClr (Dcm_TmrMaskMemType, Dcm_SingletonContext.TimerMgr.ControlMask, Dcm_UtiGetBitFromIndex(Dcm_TmrMaskMemType, (timerId))) ) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#define Dcm_TmrSetTimerRunning(timerId)                              ( Dcm_UtiBitOpSet (Dcm_TmrMaskMemType, Dcm_SingletonContext.TimerMgr.ControlMask, Dcm_UtiGetBitFromIndex(Dcm_TmrMaskMemType, (timerId))) ) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

/*! Returns the timer specific number of threads */
#define Dcm_TmrGetNumThreads(timerId)                                (((Dcm_TmrTimerInfo[(timerId)].Attributes & DCM_TMR_ATR_THREAD_MULTI) != 0u) ? DCM_NUM_THREADS : 1u) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
/*! Abstract interface of getter of the transport object carrying the diagnostic request to be processed at next Dcm_DiagTaskWorker() activation */
/*! Get/Set the queued transport object */
#define Dcm_DiagGetQueuedTranspObj(pContext)                         (Dcm_NetGetTransportObject(pContext->Diag.QueuedSet.TObjHdl))                   /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
/*! Abstract interface of the RCR-RP limiter counter management */
#if (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
/*! Reset the RCR-RP limiter */
# define Dcm_DiagResetRcrRpLimiter(pContext)                         (pContext->Diag.NumRcrRpTimeouts = DCM_DIAG_RCRRP_LIMIT_COUNT)                  /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
/*! Get current RCR-RP limiter value */
# define Dcm_DiagGetRcrRpLimiter(pContext)                           (pContext->Diag.NumRcrRpTimeouts)                                               /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
/*! Decrement by one RCR-RP limiter value */
# define Dcm_DiagDecrementRcrRpLimiter(pContext)                     (--(pContext->Diag.NumRcrRpTimeouts))                                           /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#else
# define Dcm_DiagResetRcrRpLimiter(pContext)                         /* not used */
# define Dcm_DiagGetRcrRpLimiter(pContext)                           /* not used */
# define Dcm_DiagDecrementRcrRpLimiter(pContext)                     /* not used */
#endif
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
# define Dcm_Svc27OnStateChanged()                                   (Dcm_Svc27ResetSequence())                                                      /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc27ResetSequence()                                    (Dcm_SingletonContext.Diag.Services.Svc27.SeedLevel = DCM_SVC_27_SEED_LVL_INVALID) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc27IsKeyRequestExpected()                             ((boolean)(Dcm_SingletonContext.Diag.Services.Svc27.SeedLevel != DCM_SVC_27_SEED_LVL_INVALID)) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc27GetSecLvlRef(subSvcRef)                            ((uint8)((subSvcRef) / 2u))                                                     /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc27IsSeedRequest(subSvcRef)                           ((boolean)(((subSvcRef) & 0x01u) == 0u)) /* Even subSvcRef means "request seed" request */ /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc27IsKeyRequest(subSvcRef)                            ((boolean)(Dcm_Svc27IsSeedRequest(subSvcRef) == FALSE)) /* Odd subSvcRef means "send key" request */ /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc27IsThisKeyRequestExpected(secLvlRef)                ((boolean)(Dcm_CfgStateSecurityInfo[secLvlRef].Value == Dcm_SingletonContext.Diag.Services.Svc27.SeedLevel)) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

# if (DCM_SVC_27_MULTI_ATTEMPT_COUNTER_ENABLED == STD_ON)
#  define Dcm_Svc27GetCounterIdx(secLvl)                             (secLvl)                                                                        /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# else
#  define Dcm_Svc27GetCounterIdx(secLvl)                             0u
# endif

# if (DCM_SVC_27_MULTI_DELAY_TIMER_ENABLED == STD_ON)
#  define Dcm_Svc27GetTimerIdx(secLvl)                               (secLvl)                                                                        /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# else
#  define Dcm_Svc27GetTimerIdx(secLvl)                               0u
# endif

# define Dcm_Svc27CounterGet(secLev)                                 (Dcm_SingletonContext.Diag.Services.Svc27.AttemptCount[Dcm_Svc27GetCounterIdx((secLev))]) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc27CounterReset(secLev)                               (Dcm_Svc27CounterSet((secLev), 0u))                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc27TimerGet(secLev)                                   (Dcm_SingletonContext.Diag.Services.Svc27.DelayTime[Dcm_Svc27GetTimerIdx((secLev))]) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc27TimerReset(secLev)                                 (Dcm_Svc27TimerSet((secLev), 0u))                                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc27TimerActive(secLev)                                ((boolean)(Dcm_Svc27TimerGet((secLev)) != 0u))                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc27TimerJustExpired(mask, secLev)                     ((boolean)(Dcm_UtiBitOpTest(uint32, (mask), Dcm_UtiGetBitFromIndex(uint32_least, Dcm_Svc27GetTimerIdx((secLev)))))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc27ReloadReadFailedGet(secLev)                        (Dcm_UtiBitOpTest(uint32, Dcm_SingletonContext.Diag.Services.Svc27.ReloadMask, Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvOptType, (secLev)))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc27ReloadReadFailedSet(secLev)                        (Dcm_UtiBitOpSet(uint32, Dcm_SingletonContext.Diag.Services.Svc27.ReloadMask, Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvOptType, (secLev)))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_29_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_29_APCE_INTERNAL == STD_ON) || (DCM_SVC_29_04_SUPPORT_ENABLED == STD_ON)
#  define Dcm_Svc29GetPendingKeyMCertId()                            (Dcm_SingletonContext.Diag.Services.Svc29.PendingKeyMCertId)                    /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_Svc29SetPendingKeyMCertId(certId)                      (Dcm_SingletonContext.Diag.Services.Svc29.PendingKeyMCertId = (certId))         /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_Svc29GetPendingCsmJobId()                              (Dcm_SingletonContext.Diag.Services.Svc29.PendingCsmJobId)                      /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_Svc29SetPendingCsmJobId(jobId)                         (Dcm_SingletonContext.Diag.Services.Svc29.PendingCsmJobId = (jobId))            /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_Svc29GetSignatureVerifyResult()                        (Dcm_SingletonContext.Diag.Services.Svc29.SignatureVerifyResult)                /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_Svc29SetSignatureVerifyResult(result)                  (Dcm_SingletonContext.Diag.Services.Svc29.SignatureVerifyResult = (result))     /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_Svc29GetLengthAsyncCbk()                               (Dcm_SingletonContext.Diag.Services.Svc29.LengthAsyncCbk)                       /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_Svc29SetLengthAsyncCbk(length)                         (Dcm_SingletonContext.Diag.Services.Svc29.LengthAsyncCbk = (length))            /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_Svc29GetLengthChallengeSwapBuffer()                    (Dcm_SingletonContext.Diag.Services.Svc29.LengthChallengeSwapBuffer)            /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_Svc29SetLengthChallengeSwapBuffer(length)              (Dcm_SingletonContext.Diag.Services.Svc29.LengthChallengeSwapBuffer = (length)) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_Svc29GetCbkProcessingState()                           (Dcm_SingletonContext.Diag.Services.Svc29.CbkProcessingState)                   /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_Svc29SetCbkProcessingState(state)                      (Dcm_SingletonContext.Diag.Services.Svc29.CbkProcessingState = (state))         /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_Svc29SetNextCbkProcessingState()                       (++Dcm_Svc29GetCbkProcessingState())                                            /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_Svc29GetBufferHdl()                                    (Dcm_NetGetProtObjOfConnection(Dcm_NetGetConnHdlOfRxPduId(Dcm_Svc29GetRxPduId()))->RxTxBufferRef) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

#  define Dcm_Svc29IsCbkStateActive(state)                           (Dcm_Svc29GetCbkProcessingState() == (state))                                   /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_Svc29IsAsyncCsmJobActive()                             (Dcm_Svc29IsCbkStateActive(DCM_SVC29_CBK_PROC_STATE_GENERATE_CHALLENGE) || Dcm_Svc29IsCbkStateActive(DCM_SVC29_CBK_PROC_STATE_SIGN_CHALLENGE) || Dcm_Svc29IsCbkStateActive(DCM_SVC29_CBK_PROC_STATE_VERIFY_POOW)) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#  define Dcm_Svc29IsAsyncKeyMJobActive()                            (Dcm_Svc29IsCbkStateActive(DCM_SVC29_CBK_PROC_STATE_VERIFY_CERT))               /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# endif

# define Dcm_Svc29GetRxPduId()                                       (Dcm_SingletonContext.Diag.Services.Svc29.RxPduId)                              /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc29SetRxPduId(id)                                     (Dcm_SingletonContext.Diag.Services.Svc29.RxPduId = (id))                       /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

# define Dcm_Svc29SetOwnershipRequestExpected()                      (Dcm_SingletonContext.Diag.Services.Svc29.OwnershipRequestExpected = TRUE)      /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc29ResetSequence()                                    (Dcm_SingletonContext.Diag.Services.Svc29.OwnershipRequestExpected = FALSE)     /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc29IsOwnershipRequestExpected()                       (Dcm_SingletonContext.Diag.Services.Svc29.OwnershipRequestExpected == TRUE)     /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#endif /* (DCM_SVC_29_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
# define Dcm_Svc2ASchdGetFreeSpace()                                 ((Dcm_Svc2ASchdItemHandleMemType)(DCM_SVC_2A_SCHEDULER_SIZE - Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries)) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc2AGetSchedulingTimeOfEntry(pSchedTableEntry)         (Dcm_CfgSvc2ASchdRateTime[(pSchedTableEntry)->Rate & DCM_SVC2A_RATE_TYPE_MASK]) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
# define Dcm_Svc2AIsPeriodicDid(did)                                 ((((uint16)(did)) & 0xFF00u) == 0xF200u)                                        /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc2AMakePeriodicDid(didLoByte)                         (Dcm_UtiMake16Bit((uint8)0xF2u, (didLoByte)))                                   /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc2AMakeSchdRateFromUdsRate(udsRate)                   (Dcm_Svc2ASchedRateMemType)((udsRate)-1u)                                       /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
# define Dcm_Svc2CIsDidSrcItem(srcItemIdx)                           (Dcm_UtiGenericBitSetTestBit(Dcm_Svc2CNvMData.Sequencer,(srcItemIdx)))          /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc2CSetDidSrcItem(srcItemIdx)                          (Dcm_UtiGenericBitSetSetBit(Dcm_Svc2CNvMData.Sequencer,(srcItemIdx)))           /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc2CSetMemSrcItem(srcItemIdx)                          (Dcm_UtiGenericBitSetClrBit(Dcm_Svc2CNvMData.Sequencer,(srcItemIdx)))           /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */

# define Dcm_Svc2CGetSrcItemIndex(dynDidHandle, offset)              ((Dcm_CfgDidMgrDynDidSrcItemIdxMemType)(Dcm_DidMgrGetDynDidSrcItemStartRef(dynDidHandle) + (offset))) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
# define Dcm_Svc2CIsDynDidDefined(dynDidHandle)                      (Dcm_Svc2CGetItem(dynDidHandle)->Count != 0u)                                   /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
# define Dcm_Svc2CGetNetBufferSize(pContext)                         ((Dcm_NetGetBufferInfo(Dcm_DiagGetTranspObj(pContext)->BufferHdl)->Size))       /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
# define Dcm_Svc2FSetDidActive(ioDidHdl)                             (Dcm_UtiGenericBitSetSetBit(Dcm_SingletonContext.Diag.Services.Svc2F.ActiveIoDids,(ioDidHdl))) /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */

/**********************************************************************************************************************
 *  LOCAL DATA TYPES AND STRUCTURES
 *********************************************************************************************************************/
typedef P2CONST(Dcm_CfgNetBufferInfoType, TYPEDEF, DCM_CONST_PBCFG) Dcm_PbCfgNetBufferInfoPtrType;
typedef boolean Dcm_NetActiveDiagnosticType;

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/*! Periodic message transmitter control states */
struct DCM_NETPERIODICTXCONTEXTTYPE_TAG
{
  DCM_PB_RAM_DATA_DECL(Dcm_NetPeriodicTxObjectType, TxObject, DCM_NET_MAX_NUM_PERIODIC_TX_OBJ) /*!< Periodic message control objects */
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
  volatile Dcm_TmrTimerCntrMemType DelayTimer[DCM_NET_DELAY_BULK_TRANSMISSION]; /*!< Array of delay timers that assure gap times between periodic DIDs */
# endif
  uint16                           ClientSrcAddr;    /*!< Client source address. Required only when generic connection is used */
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
  Dcm_CfgNetPTxObjHandleMemType    DelayCntr;        /*!< Number of remaining messages that can be dispatched before a delay is required */
  uint8                            NextDelayTimer;   /*!< Index of next delay timer to use */
  uint8                            FastestRate;      /*!< The fastest rate in which periodic DIDs are currently scheduled */
# endif
  Dcm_NetConnRefMemType            ConnHdlInUse;      /*!< Current owner (diagnostic client) of the periodic transmitter */
  Dcm_CfgNetPTxObjHandleMemType    NextTxObjectHdl;  /*!< Pointer to the next periodic message to be sent. Scope is only the current periodic transmitter owners list of periodic messages */
  Dcm_CfgNetPTxObjHandleMemType    TxObjectSentCntr; /*!< Keeps track of the already sent periodic messages. Scope is only the current periodic transmitter owners list of periodic messages */
};
typedef struct DCM_NETPERIODICTXCONTEXTTYPE_TAG Dcm_NetPeriodicTxContextType;

typedef P2VAR(Dcm_NetPeriodicTxObjectType, TYPEDEF, DCM_RAM_PBCFG) Dcm_NetPeriodicTxObjectPtrType;
#endif

typedef P2VAR(Dcm_NetComMContextType, TYPEDEF, DCM_VAR_NOINIT) Dcm_NetComMContextPtrType;
typedef P2VAR(Dcm_NetBufferContextType, TYPEDEF, DCM_VAR_NOINIT) Dcm_NetBufferContextPtrType;

/*! Control states of the network sub-component */
struct DCM_NETCONTEXTTYPE_TAG
{
#if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
  Dcm_CfgVarMgrComVariantType   ComVariant;                                                           /*!< Points to the COM-criteria */
#endif
#if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
  Dcm_CfgNetRamVariantInfoType  RamVariant;                                                           /*!< Relocatable RAM for the network sub-component */
  Dcm_CfgNetRomVariantInfoType  RomVariant;                                                           /*!< Relocatable ROM for the network sub-component */
#endif
  DCM_PB_RAM_DATA_DECL(Dcm_NetBufferContextType, BufferContext, DCM_NET_NUM_BUFFERS)                  /*!< Control states of the USDT message buffers (main and additional) */
  DCM_PB_RAM_DATA_DECL(Dcm_NetTransportObjectType, TransportObject, DCM_NET_MAX_NUM_TRANSP_OBJECTS)   /*!< Transport objects for simultaneous servicing of multiple clients */
  DCM_PB_RAM_DATA_DECL(Dcm_NetComMContextType, ComMContext, DCM_NET_MAX_NUM_COMM_CHANNELS)            /*!< Control states of ComM status notifications per DCM related com-channel (i.e. channel on which DCM communicates with a client */
#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
  Dcm_NetPeriodicTxContextType  PeriodicTxContext;                                                    /*!< Composition relation to the periodic message transmitter */
#endif
  DCM_PB_RAM_DATA_DECL(Dcm_CfgNetTObjHandleMemType, ConnHdl2TObjIdMap, DCM_NET_MAX_NUM_CONNECTIONS)   /*!< A map of type <key = connectionHdl, value = TransportObject>. Used for fast transport object allocation */
#if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
  DCM_PB_RAM_DATA_DECL(Dcm_CommunicationModeType, ComCtrlChannels, DCM_NET_MAX_NUM_ALL_COMM_CHANNELS) /*!< Communication state [Rx/Tx][On/Off] of each ComM channel known to DCM */
#endif
  Dcm_NetProtRefMemType         ActiveProtocol;                                                       /*!< The protocol handle last activated */
  Dcm_NetConnRefMemType         NumActiveConnections;                                                 /*!< Current number of simultaneously serviced clients/connections */
  Dcm_NetConnRefMemType         SessionConnection;                                                    /*!< Owner (client) of the non-default session last started */
  uint16                        SessionClientSrcAddr;                                                 /*!< Source address of client which started the non-default session */
  Dcm_NetActiveDiagnosticType   ActiveDiagnostic;                                                     /*!< Guard for prevention of DCMs automatic ComM diag-activate signal notification (this state is managed by the application) */
#if (DCM_NET_RX_BLOCKING_ENABLED == STD_ON)
  boolean                       RxAllowed;                                                            /*!< Guard for global blocking of any request reception */
#endif
  boolean                       KeepAlive;                                                            /*!< Guard for prevention of diag-inactive notifications from DCM to ComM (e.g. in the default-session) */
};
typedef struct DCM_NETCONTEXTTYPE_TAG Dcm_NetContextType;
/*! Single timer runtime data */
struct DCM_TMRTIMERCONTEXTTYPE_TAG
{
  volatile Dcm_TmrTimerCntrMemType  Timer;         /*!< Remaining time of all running system timers */
           Dcm_TmrTimerIdMemType    TimerInfoRef;  /*!< Reference to Dcm_TmrTimerInfo[] */
};
typedef struct DCM_TMRTIMERCONTEXTTYPE_TAG Dcm_TmrTimerContextType;
typedef P2VAR(Dcm_TmrTimerContextType, TYPEDEF, DCM_VAR_NOINIT) Dcm_TmrTimerContextPtrType;
typedef P2CONST(Dcm_TmrTimerContextType, TYPEDEF, DCM_VAR_NOINIT) Dcm_TmrTimerContextConstPtrType;

/*! Control data of the timer sub-component */
struct DCM_TMRCONTEXTTYPE_TAG
{
  volatile Dcm_TmrMaskMemType       ControlMask;                               /*!< Control bit mask for all configured system timers */
           Dcm_TmrTimerContextType  TimerContext[DCM_TMR_NUM_TIMER_CONTEXTS];  /*!< Runtime data of each available timer */
};
typedef struct DCM_TMRCONTEXTTYPE_TAG Dcm_TmrContextType;

typedef uint8 Dcm_TmrTimerAttributeType;
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
/*! Context for attempt counter handling */
struct DCM_SVC27CONTEXTTYPE_TAG
{
# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
           uint32                   GetAttCntrEventMask;                            /*!< State of attempt counter read operations */
           uint32                   SetAttCntrEventMask;                            /*!< State of attempt counter write operations */
# endif
           uint32                   ReloadMask;                                     /*!< Infinite delay timer mask */
  volatile Dcm_TmrTimerCntrMemType  DelayTime[DCM_SVC_27_NUM_DELAY_TIMERS];         /*!< Array of delay timers for UUDT messages */
           uint8                    AttemptCount[DCM_SVC_27_NUM_ATTEMPT_COUNTERS];  /*!< Array of attempt counters */
# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
           Dcm_OpStatusType         GetAttOpStatus;                                 /*!< Operation state of attempt counter read operation */
           Dcm_OpStatusType         SetAttOpStatus;                                 /*!< Operation state of attempt counter write operation */
# endif
           uint8                    SeedLevel;                                      /*!< Last requested security level for which a seed was sent (0 = invalid (no seed) -> 1..7F - active seed) */
};
typedef struct DCM_SVC27CONTEXTTYPE_TAG Dcm_Svc27ContextType;

typedef P2CONST(Dcm_CfgSvc27SecLevelInfoType, TYPEDEF, DCM_CONST)  Dcm_CfgSvc27SecLevelInfoPtrType;
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_29_SUPPORT_ENABLED == STD_ON)
typedef P2CONST(Dcm_CfgSvc29SubFuncInfoType, TYPEDEF, DCM_CONST) Dcm_CfgSvc29SubFuncInfoPtrType;
# if (DCM_SVC_29_APCE_INTERNAL == STD_ON) || (DCM_SVC_29_04_SUPPORT_ENABLED == STD_ON)
typedef uint8 Dcm_Svc29ProcessingState;
# endif

/*! Context for request sequence and async callback handling */
struct DCM_SVC29CONTEXTTYPE_TAG
{
# if (DCM_SVC_29_APCE_INTERNAL == STD_ON) || (DCM_SVC_29_04_SUPPORT_ENABLED == STD_ON)
  KeyM_CertificateIdType        PendingKeyMCertId;                                    /*!< Key Manager pending certificate ID */
  Dcm_Svc29ProcessingState      CbkProcessingState;                                   /*!< Asynchronous callback processing state */
  KeyM_CertificateStatusType    KeyMCbkResult;                                        /*!< Key Manager callback result */
# endif
# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
  uint32                        PendingCsmJobId;                                      /*!< Crypto Service Manager pending Job ID */
  Crypto_VerifyResultType       SignatureVerifyResult;                                /*!< Store result for signature verify */
  uint32                        LengthAsyncCbk;                                       /*!< Length storage for async operations */
  uint16                        LengthChallengeSwapBuffer;                            /*!< Length of the generated challenge data */
  uint8                         ChallengeSwapBuffer[DCM_AUTHMGR_CHALLENGE_MAX_SIZE];  /*!< Pointer to generated challenge data */
  Crypto_ResultType             CsmCbkResult;                                         /*!< Crypto Service Manager callback result */
# endif
  PduIdType                     RxPduId;                                              /*!< Pdu ID associated with the sequence flag */
  boolean                       OwnershipRequestExpected;                             /*!< Last subfunction that processed was 01 or 02 (0 = was failed or not processed) */
};
typedef struct DCM_SVC29CONTEXTTYPE_TAG Dcm_Svc29ContextType;
#endif /* (DCM_SVC_29_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
typedef uint8       Dcm_Svc2ASchedRateMemType;
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
typedef uint8_least Dcm_Svc2ASchedRateOptType;
# endif
typedef uint8       Dcm_Svc2ASchdItemHandleMemType;
typedef uint8_least Dcm_Svc2ASchdItemHandleOptType;

/*! Service 0x2A scheduler entry data */
struct DCM_SVC2ASCHDENTRYTYPE_TAG
{
           Dcm_DidMgrDidInfoContextType DidContext; /*!< Information about the scheduled DID */
  volatile Dcm_TmrTimerCntrMemType      Timer;      /*!< Timer for the periodic transmission */
           Dcm_Svc2ASchedRateMemType    Rate;       /*!< Requested transmission rate */
};
typedef struct DCM_SVC2ASCHDENTRYTYPE_TAG Dcm_Svc2ASchdEntryType;

typedef P2VAR(Dcm_Svc2ASchdEntryType, TYPEDEF, DCM_VAR_NOINIT) Dcm_Svc2ASchdEntryPtrType;
typedef P2CONST(Dcm_Svc2ASchdEntryType, TYPEDEF, DCM_VAR_NOINIT) Dcm_Svc2ASchdEntryConstPtrType;

/*! Service 0x2A scheduler data */
struct DCM_SVC2ASCHEDULERTYPE_TAG
{
  Dcm_Svc2ASchdEntryType          Table[DCM_SVC_2A_SCHEDULER_SIZE];        /*!< Table of scheduled DIDs */
  Dcm_DidMgrDidOpTypeContextType  DidOpTypeContext;                        /*!< Information about operations on current DID */
  Dcm_CfgNetBufferSizeMemType     WriteIndex;                              /*!< Number of bytes that were already read */
  Dcm_Svc2ASchdItemHandleMemType  NumActiveEntries;                        /*!< Number of active entries in scheduler table */
  Dcm_Svc2ASchdItemHandleMemType  CurrentEntryIndex;                       /*!< Scheduler table entry that is currently processed */
  Dcm_CfgNetPTxObjHandleMemType   MsgTxHandle;                             /*!< Index of current tx object */
  Dcm_OpStatusType                OpStatus;                                /*!< Current operation status */
};
typedef struct DCM_SVC2ASCHEDULERTYPE_TAG Dcm_Svc2ASchedulerType;
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/*! Context for handling of periodic transmision */
struct DCM_SVC2ACONTEXTTYPE_TAG
{
  Dcm_Svc2ASchedulerType Scheduler;                        /*!< Scheduler for periodic transmission */
};
typedef struct DCM_SVC2ACONTEXTTYPE_TAG Dcm_Svc2AContextType;
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/*! Context for the processing of a specific DynDID */
struct DCM_SVC2CDYNDIDPROCESSCONTEXTTYPE_TAG
{
  Dcm_DidMgrDidInfoContextType         SrcDidContext;    /*!< Info context of the currently requested source DID */
  Dcm_DidMgrDidOpTypeContextType       DidOpTypeContext; /*!< Operation type context */
  Dcm_CfgDidMgrDynDidSrcItemIdxMemType ItemInProgress;   /*!< Index of the currently processed source item */
  Dcm_CfgDidMgrDynDidSrcItemIdxMemType ItemToStop;       /*!< Index of the item after the last source item */
};
typedef struct DCM_SVC2CDYNDIDPROCESSCONTEXTTYPE_TAG Dcm_Svc2CDynDidProcessContextType;

typedef P2VAR(Dcm_Svc2CDynDidProcessContextType, TYPEDEF, DCM_VAR_NOINIT) Dcm_Svc2CDynDidProcessContextPtrType;

/*! Context for the handling of the read access to a DynDID */
struct DCM_SVC2CDYNDIDACCESSCONTEXT_TAG
{
  Dcm_Svc2CDynDidProcessContextType ProcessContext[DCM_SVC_2C_NUM_PROCESS_CONTEXTS]; /*!< Process contexts for DynDIDs */
  Dcm_CfgDidMgrDynDidHandleMemType  DynDidHandleInUse;                               /*!< Handle of currently processed DynDID */
# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
  Dcm_MsgItemType                   Buffer[DCM_SVC_2C_READ_BUFFER_SIZE];             /*!< DynDID read buffer */
# endif
};
typedef struct DCM_SVC2CDYNDIDACCESSCONTEXT_TAG Dcm_Svc2CDynDidReadAccessContext;
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/*! Context for the handling of DynDIDs */
struct DCM_SVC2CCONTEXTTYPE_TAG
{
  Dcm_Svc2CDynDidReadAccessContext   DynDidAccessContext; /*!< Access context of the DynDID */
  Dcm_MsgLenType                     ReadIndex;           /*!< Number of bytes that are already read */
};
typedef struct DCM_SVC2CCONTEXTTYPE_TAG Dcm_Svc2CContextType;

typedef P2CONST(Dcm_CfgSvc2CSubFuncInfoType, TYPEDEF, DCM_CONST) Dcm_CfgSvc2CSubFuncInfoPtrType;
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
/*! Context for the handling of IODIDs */
struct DCM_SVC2FCONTEXTTYPE_TAG
{
  Dcm_DiagDataContextType DataContext;                                                /*!< Data context */
# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
  Dcm_UtiBitSetBaseType   ActiveIoDids[Dcm_UtiGenericBitSetCalcSize(DCM_NUM_IODIDS)]; /*!< Bit masks of active IO operations */
  boolean                 HasAnyActiveIoDid;                                          /*!< Active IODID operation flag */
# endif
};
typedef struct DCM_SVC2FCONTEXTTYPE_TAG Dcm_Svc2FContextType;
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */

#if (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_AUTHMGR_SET_DEAUTH_ROLE_ENABLED == STD_ON)
/*! Pending data for processing of Dcm_SetDeauthenticatedRole() */
struct DCM_AUTHMGRPENDINGROLETYPE_TAG
{
  uint32                    ConnectionMask;                        /*!< Bit mask for the connetionId for which Dcm_SetDeauthenticatedRole() was called */
  Dcm_CfgStateGroupMemType  Role[DCM_CFGAUTHMGRNETCONNINFO_SIZE];  /*!< Pending role from Dcm_SetDeauthenticatedRole() */
};
typedef struct DCM_AUTHMGRPENDINGROLETYPE_TAG Dcm_AuthMgrPendingRoleType;
# endif

# if (DCM_STATE_AUTHENTICATION_ENABLED == STD_ON)
/*! Authentication manager context */
struct DCM_AUTHMGRCONTEXTTYPE_TAG
{
#  if (DCM_AUTHMGR_SET_DEAUTH_ROLE_ENABLED == STD_ON)
  Dcm_AuthMgrPendingRoleType       PendingData;                              /*!< Pending data for processing of Dcm_SetDeauthenticatedRole() */
#  endif
  Dcm_AuthMgrTimerExpiredMaskType  TimerExpiredMask;                         /*!< A flag to store expired timers for authentication sessions */
#  if (DCM_AUTHMGR_DEFAULT_SESSION_TIMEOUT_ENABLED == STD_ON)
  Dcm_AuthMgrTimerType             DelayTime[DCM_AUTHMGR_NUM_DELAY_TIMERS];  /*!< Array of delay timers for authentication sessions */
#  endif
#  if (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
  boolean                          GrantGlobalAccess;                        /*!< Global access flag */
#  endif
};
typedef struct DCM_AUTHMGRCONTEXTTYPE_TAG Dcm_AuthMgrContextType;
# endif
#endif /* (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
/*! Control data of the unsolicited response at ECU start-up task */
struct DCM_STARTUPRESPONSECONTEXTTYPE_TAG
{
  Dcm_ProgConditionsType          ProgConditions;                             /*!< Dedicated programming condition storage in case a parallel request needs the repeater proxy pool */
  Dcm_MsgItemType                 ResBuffer[DCM_DIAG_START_UP_FBL_RES_SIZE];  /*!< Dedicated response buffer for the final response */
  boolean                         IsResponseRequired;                         /*!< Response-required information extracted from the pre-boot time context */
  Dcm_NetTransmissionResultType   TxStatus;                                   /*!< Transports the response transmission result to the Dcm_DiagTaskFblRes() */
  sint8                           SessStateRef;                               /*!< Diagnostic session index (values <0 mean no session transition). Use sint8 since no more than 127 sessions are possible */
  Dcm_NetConnRefMemType           ConnHdl;                                    /*!< Connection handle on which the unsolicited response was sent for post-processing purposes */
};
typedef struct DCM_STARTUPRESPONSECONTEXTTYPE_TAG Dcm_DiagStartUpResContextType;
#endif

#if (DCM_DIAG_SVC_CONTEXT_ENABLED == STD_ON)
/*! Storage of all diagnostic services contexts that shall be kept in memory not only during a diagnostic request but during the whole ECU operation cycle */
struct DCM_DIAGSERVICESCONTEXTTYPE_TAG
{
# if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc27ContextType  Svc27;  /*!< Storage place for all "SecurityAccess" data */
# endif
# if (DCM_SVC_29_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc29ContextType  Svc29;  /*!< Storage place for all "Authentication" data */
# endif
# if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc2AContextType  Svc2A;  /*!< Storage place for all "ReadDataByPeriodicId" data */
# endif
# if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc2CContextType  Svc2C;  /*!< Storage place for all "DynamicallyDefineIdentifier" data */
# endif
# if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc2FContextType  Svc2F;  /*!< Storage place for all "IOControlByIdentifier" data */
# endif
};
typedef struct DCM_DIAGSERVICESCONTEXTTYPE_TAG Dcm_DiagServicesContextType;
#endif

#if (DCM_DIAG_SPECIFIC_CAUSE_CODE_ENABLED == STD_ON)
/*! Control data of the specific cause code */
struct DCM_CAUSECODECONTEXTTYPE_TAG
{
  Dcm_SpecificCauseCodeType CauseCode;      /*!< The specific cause code */
  boolean                   SendCauseCode;  /*!< Flag to send the CauseCode */
};
typedef struct DCM_CAUSECODECONTEXTTYPE_TAG Dcm_DiagCauseCodeContextType;
#endif

#if (DCM_DIAG_CONTEXT_ENABLED == STD_ON)
/*! Control intanced data of the sub-component diagnostic kernel */
struct DCM_DIAGCONTEXTTYPE_TAG
{
# if (DCM_VARMGR_MODE_POSTBUILD_ANY_ENABLED == STD_ON) && (DCM_VARMGR_SUPPORT_ENABLED == STD_ON)
  P2CONST(Dcm_CfgDiagSvc2ProtMapMemType, AUTOMATIC, DCM_CONST_PBCFG) Svc2ProtocolMap; /*!< Points to the "diagnostic service to protocol map" for a particual DCM variant (criterion): Dcm_CfgDiagSvcId2ProtMap[] */
# endif
# if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON) && (DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
  Dcm_CfgDiagRomVariantInfoType  RomVariant;        /*!< Relocatable ROM for the diagnostic sub-component */
# endif
# if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
  Dcm_DiagStartUpResContextType  StartUpFbl;        /*!< The global data of the unsolicited response task (Dcm_DiagTaskFblRes()) */
# endif
# if (DCM_DIAG_SVC_CONTEXT_ENABLED == STD_ON)
  Dcm_DiagServicesContextType    Services;          /*!< Diagnostic service processors "long term" memory */
# endif
# if (DCM_DIAG_SPECIFIC_CAUSE_CODE_ENABLED == STD_ON)
  Dcm_DiagCauseCodeContextType   CauseCodeContext;  /*!< Context of the specific cause code */
# endif
# if(DCM_STATE_SECURITY_BYPASS_ENABLED == STD_ON)
  boolean                        IsSecurityBypass;
# endif
};
typedef struct DCM_DIAGCONTEXTTYPE_TAG Dcm_DiagContextType;
#endif

/*! Function pointer prototype for a system timer related time-out notification */
typedef P2FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE, Dcm_TmrTimeoutFuncType) (
  Dcm_ThreadIdMemType threadId  /* IN: Active thread */
  );

/*! Single timer configuration data */
struct DCM_TMRTIMERINFOTYPE_TAG
{
  Dcm_TmrTimeoutFuncType     OnTimeoutFunc;    /*!< Pointer to the timeout notification handler of kind Dcm_OnTimeout<TimerName>() (e.g. Dcm_OnTimeoutP2()) */
  Dcm_TmrTimerAttributeType  Attributes;       /*!< Configuration attributes (Valid values: DCM_TSK_ATR_*) */
  Dcm_TmrTimerIdMemType      TimerContextRef;  /*!< Reference to Dcm_SingletonContext.TimerMgr.TimerContext[] */
};
typedef struct DCM_TMRTIMERINFOTYPE_TAG Dcm_TmrTimerInfoType;
typedef P2CONST(Dcm_TmrTimerInfoType, TYPEDEF, DCM_CONST) Dcm_TmrTimerInfoPtrType;
/*! Data container for data shared among all DCM threads */
struct DCM_SINGLETONCONTEXTTYPE_TAG
{
#if (DCM_DIAG_CONTEXT_ENABLED == STD_ON)
  Dcm_DiagContextType        Diag;        /*!< Diagnostic kernel sub-component per-instance memory */
#endif
  Dcm_NetContextType         Network;     /*!< Network sub-component shared memory */
  Dcm_TmrContextType         TimerMgr;    /*!< System timer manager sub-component shared memory */
  Dcm_StateContextType       StateMgr;    /*!< Diagnostic state manager sub-component shared memory */
#if (DCM_STATE_AUTHENTICATION_ENABLED == STD_ON)
  Dcm_AuthMgrContextType     AuthMgr;     /*!< Authentication manager sub-component shared memory */
#endif
#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
  Dcm_RecoveryContextType    Recovery;    /*!< Recovery context containing the operation state and the recovery information */
#endif
};
typedef struct DCM_SINGLETONCONTEXTTYPE_TAG Dcm_SingletonContextType;
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
/*! Function pointer prototype for a Get-Seed handler with Security-Access-Data-Record */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_Svc27OpFuncSeedWAdr)(
  Dcm_MsgType seed,
  Dcm_OpStatusType opStatus,
  Dcm_MsgType adr,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/*! Function pointer prototype for a Get-Seed handler without Security-Access-Data-Record */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_Svc27OpFuncSeedWoAdr)(
  Dcm_OpStatusType opStatus,
  Dcm_MsgType seed,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */

/**********************************************************************************************************************
 *  LOCAL FUNCTION DECLARATIONS
 *********************************************************************************************************************/
#define DCM_START_SEC_CODE
#include "Dcm_MemMap.h"                                                                                                                              /* PRQA S 5087 */ /* MD_MSR_MemMap */
#if (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_AUTHMGR_DEFAULT_SESSION_TIMEOUT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrTimerStart()
 *********************************************************************************************************************/
/*! \brief          Sets the value of a specific connection idle timer.
 *  \details        Starts the base authentication idle connection timer.
 *  \param[in]      authInfoRef      The authentication info reference
 *  \param[in]      value            Timer value for the specific idle connection timer
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrTimerStart(
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  Dcm_AuthMgrTimerType value
  );

/**********************************************************************************************************************
 *  Dcm_AuthMgrTimerSet()
 *********************************************************************************************************************/
/*! \brief          Sets the value of a specific idle connection session timer.
 *  \details        -
 *  \param[in]      authInfoRef  The authentication info reference
 *  \param[in]      value        Timer value
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrTimerSet(
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  Dcm_AuthMgrTimerType value
  );
# endif

# if (DCM_STATE_AUTHENTICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrSetConnAuthState()
 *********************************************************************************************************************/
/*! \brief          Sets the authentication state of a connection of the given index.
 *  \details        -
 *  \param[in]      authInfoRef  Index to the ConnAuthStates array
 *  \param[in]      value        New authentication state of connection
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrSetConnAuthState(
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  Dcm_AuthenticationStateType value
  );
# endif

# if(DCM_AUTHMGR_WHITELISTS_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrGetWLContext()
 *********************************************************************************************************************/
/*! \brief          Get white lists for a connection.
 *  \details        -
 *  \param[in]      authInfoRef     Index to white lists array
 *  \param[out]     pWLContext      White list entries for a connection
 *  \param[out]     ErrorCode       Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_OK        The operation was successful
 *  \return         DCM_E_NOT_OK    The given index was invalid (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrGetWLContext(
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  CONSTP2VAR(Dcm_AuthMgrWLContextPtrType, AUTOMATIC, AUTOMATIC) pWLContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

/**********************************************************************************************************************
 *  Dcm_AuthMgrUpdateActiveRole()
 *********************************************************************************************************************/
/*! \brief          Authentication Manager update active role.
 *  \details        Sets the active role to a particular connection to the new authentication role argument.
 *  \param[in]      authInfoRef                Index to the ConnActiveRole array
 *  \param[in]      authRole                   The new authentication role
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrUpdateActiveRole(
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  Dcm_CfgStateGroupMemType authRole
  );

# if (DCM_AUTHMGR_DEFAULT_SESSION_TIMEOUT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrDetectIdleConnection()
 *********************************************************************************************************************/
/*! \brief          Detects an idle connection and deauthenticates it if necessary
 *  \details        -
 *  \param[in]      oldSession    The old session
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrDetectIdleConnection(
  Dcm_CfgStateGroupOptType oldSession
  );
# endif

/**********************************************************************************************************************
 *  Dcm_AuthMgrDeauthenticateIdleConn()
 *********************************************************************************************************************/
/*! \brief          Deauthenticates all idle connections
 *  \details        -
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrDeauthenticateIdleConn(
  void
  );

# if (DCM_STATE_AUTHENTICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrSetAuthentication()
 *********************************************************************************************************************/
/*! \brief          Performs an authentication state transition.
 *  \details        -
 *  \param[in]      authInfoRef    The authentication information reference
 *  \param[in]      authState      The new authentication state
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrSetAuthentication(
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  Dcm_AuthenticationStateType authState
  );
# endif

/**********************************************************************************************************************
 *  Dcm_AuthMgrInit()
 *********************************************************************************************************************/
/*! \brief          State initialization.
 *  \details        Initialization of the authentication manager sub-module.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrInit(
  void
  );

# if (DCM_AUTHMGR_SET_DEAUTH_ROLE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrSetDeauthenticatedRole()
 *********************************************************************************************************************/
/*! \brief          Handles the event set by API Dcm_SetDeauthenticatedRole().
 *  \details        -
 *  \param[in]      pContext  Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrSetDeauthenticatedRole(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext
  );

/**********************************************************************************************************************
 *  Dcm_AuthMgrSetPendingRole()
 *********************************************************************************************************************/
/*! \brief          Sets the pending role coming from external API Dcm_SetDeauthenticatedRole().
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrSetPendingRole(
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  Dcm_CfgStateGroupMemType pendingRole
  );
# endif
#endif /* (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_NetIsKeepAliveTimeStartOnFunc3E80Enabled()
 *********************************************************************************************************************/
/*! \brief          Returns DCM_NET_KEEP_ALIVE_TIME_START_ON_FUNC_3E_80_ENABLED as boolean.
 *  \details        -
 *  \return         TRUE         DCM_NET_KEEP_ALIVE_TIME_START_ON_FUNC_3E_80_ENABLED is STD_ON
 *  \return         FALSE        DCM_NET_KEEP_ALIVE_TIME_START_ON_FUNC_3E_80_ENABLED is STD_OFF
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \synchronous    TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetIsKeepAliveTimeStartOnFunc3E80Enabled(
  void
  );

/**********************************************************************************************************************
 *  Dcm_NetIsRxPduIdValid()
 *********************************************************************************************************************/
/*! \brief          Checks the received rxPduId.
 *  \details        -
 *  \param[in]      rxPduId    The rxPduId of the request
 *  \return         TRUE       The rxPduId is valid
 *  \return         FALSE      The rxPduId is not valid
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetIsRxPduIdValid(
  PduIdType rxPduId
  );

/**********************************************************************************************************************
 *  Dcm_NetIsTxPduIdValid()
 *********************************************************************************************************************/
/*! \brief          Checks the received txPduId.
 *  \details        -
 *  \param[in]      txPduId    The txPduId of the request
 *  \return         TRUE       The txPduId is valid
 *  \return         FALSE      The txPduId is not valid
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetIsTxPduIdValid(
  PduIdType txPduId
  );

/**********************************************************************************************************************
 *  Dcm_NetGetComMContext()
 *********************************************************************************************************************/
/*! \brief          Returns a ComM context element of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a ComM context
 *  \return         ComM context object
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NetComMContextPtrType, DCM_CODE) Dcm_NetGetComMContext(
  Dcm_CfgNetNetIdRefOptType index
  );

/**********************************************************************************************************************
 *  Dcm_NetGetBufferContext()
 *********************************************************************************************************************/
/*! \brief          Returns a buffer context element of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a buffer context
 *  \return         Buffer context object
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NetBufferContextPtrType, DCM_CODE) Dcm_NetGetBufferContext(
  Dcm_CfgNetBufferRefOptType index
  );

/**********************************************************************************************************************
 *  Dcm_NetPutToConn2TObjMap()
 *********************************************************************************************************************/
/*! \brief          Sets a transport object handle of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a transport object handle
 *  \param[in]      value    New handle
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPutToConn2TObjMap(
  Dcm_NetConnRefOptType index,
  Dcm_CfgNetTObjHandleMemType value
  );

/**********************************************************************************************************************
 *  Dcm_NetWriteAddBufferU8At()
 *********************************************************************************************************************/
/*! \brief          Writes into the additional buffer of a transport object.
 *  \details        -
 *  \param[in]      pTranspObj    The transport object
 *  \param[in]      index         Index to the additional buffer
 *  \param[in]      value         New value of the transport object
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetWriteAddBufferU8At(
  Dcm_NetTransportObjectPtrType pTranspObj,
  uint8_least index,
  Dcm_MsgItemType value
  );

/**********************************************************************************************************************
 *  Dcm_NetGetBufferInfo()
 *********************************************************************************************************************/
/*! \brief          Returns a buffer information element of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a buffer information element
 *  \return         Buffer info object
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_PbCfgNetBufferInfoPtrType, DCM_CODE) Dcm_NetGetBufferInfo(
  Dcm_CfgNetBufferRefOptType index
  );

/**********************************************************************************************************************
 *  Dcm_NetCommonInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the common network related states.
 *  \details        -
 *  \param[in]      configPtr    Pointer to a concrete configuration root
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetCommonInit(
  Dcm_ConfigPtrType configPtr
  );

/**********************************************************************************************************************
 *  Dcm_NetComMInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the ComM related states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetComMInit(
  void
  );

/**********************************************************************************************************************
 *  Dcm_NetBufferInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the buffer related states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetBufferInit(
  void
  );

/**********************************************************************************************************************
 *  Dcm_NetConnectionInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the connection related states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetConnectionInit(
  void
  );

/**********************************************************************************************************************
 *  Dcm_NetTranspObjInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the transport object related states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTranspObjInit(
  void
  );

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the periodic message related states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgInit(
  void
  );
#endif

/**********************************************************************************************************************
 *  Dcm_NetInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the network sub-module.
 *  \details        -
 *  \param[in]      configPtr    Pointer to a concrete configuration root
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetInit(
  Dcm_ConfigPtrType configPtr
  );

/**********************************************************************************************************************
 *  Dcm_NetRegisterActiveConnection()
 *********************************************************************************************************************/
/*! \brief          Registers an active connection.
 *  \details        Function will be called from Dcm_NetStartOfReception.
 *  \param[in]      pTranspObj    The transport object
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetRegisterActiveConnection(
  Dcm_NetTransportObjectPtrType pTranspObj
  );

#if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetOnRequestDetection()
 *********************************************************************************************************************/
/*! \brief          Cancels any pending job if detected another ECU to be requested from the same client.
 *  \details        Function will be called from Dcm_NetStartOfReception.
 *  \param[in]      connHdl        The connection ID of the foreign ECU request
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetOnRequestDetection(
  Dcm_NetConnRefMemType connHdl
  );
#endif

/**********************************************************************************************************************
 *  Dcm_NetRxPrioritisationFindWinner()
 *********************************************************************************************************************/
/*! \brief          Determination of request with highest priority.
 *  \details        -
 *  \param[in]      ev                      The active event(s) of the task Dcm_NetTaskRx
 *  \param[out]     pBusyEvents             Bitfield for busy requests
 *  \return         ID of the winner
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgNetTObjHandleOptType, DCM_CODE) Dcm_NetRxPrioritisationFindWinner(
  Dcm_TskTaskEvOptType ev,
  Dcm_TskTaskEvPtrType pBusyEvents
  );

/**********************************************************************************************************************
 *  Dcm_NetRxPrioritisationProcessWinner()
 *********************************************************************************************************************/
/*! \brief          Processing of the request with the highest priority.
 *  \details        -
 *  \param[in]      pContext      Pointer to the context
 *  \param[in]      pTranspObj    The transport object
 *  \param[in,out]  pBusyEvents   Bitfield for busy requests
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetRxPrioritisationProcessWinner(
  Dcm_ContextPtrType pContext,
  Dcm_NetTransportObjectPtrType pTranspObj,
  Dcm_TskTaskEvPtrType pBusyEvents
  );

/**********************************************************************************************************************
 *  Dcm_NetRxPrioritisationProcessLoosers()
 *********************************************************************************************************************/
/*! \brief          Processing of requests that were preempted.
 *  \details        -
 *  \param[in]      BusyEvents             Bitfield for busy requests
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetRxPrioritisationProcessLoosers(
  Dcm_TskTaskEvOptType BusyEvents
  );

/**********************************************************************************************************************
 *  Dcm_NetExecStartProtocolOp()
 *********************************************************************************************************************/
/*! \brief          Executes a protocol start up.
 *  \details        -
 *  \param[in]      newProtocol    The new protocol ID to be evaluated for starting
 *  \return         TRUE           Proceed with protocol starting
 *  \return         FALSE          Skip any further service processing after return
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetExecStartProtocolOp(
  Dcm_ProtocolType newProtocol
  );

/**********************************************************************************************************************
 *  Dcm_NetComposeAddNegResponse()
 *********************************************************************************************************************/
/*! \brief          Composes a negative response.
 *  \details        -
 *  \param[in]      pTranspObj    The transport object
 *  \param[in]      resType       The response type
 *  \param[in]      nrc           The negative response code
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetComposeAddNegResponse(
  Dcm_NetTransportObjectPtrType pTranspObj,
  Dcm_NetResponseType resType,
  Dcm_NegativeResponseCodeType nrc
  );

/**********************************************************************************************************************
 *  Dcm_NetProcessStartProtocol()
 *********************************************************************************************************************/
/*! \brief          Starts a new protocol.
 *  \details        Delegates a new request with a new protocol and terminates the old one.
 *  \param[in]      pTranspObj    The transport object
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetProcessStartProtocol(
  Dcm_NetTransportObjectPtrType pTranspObj
  );

/**********************************************************************************************************************
 *  Dcm_NetTransmitUsdtResponse()
 *********************************************************************************************************************/
/*! \brief          Start transmission on this connection.
 *  \details        Start an USDT transmission over a specific connection.
 *  \param[in]      pTranspObj            The transport object to be used during the transmission.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            All the items of the structure must be validly initialized:
 *                  hBuffer               Shall be the TxBuffer handle
 *                  pduInfo.SduDataPtr    Shall point to the TxBuffer
 *                  pduInfo.SduLength     Shall contain the length of the data to be sent
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTransmitUsdtResponse(
  Dcm_NetTransportObjectPtrType pTranspObj
  );

#if (DCM_NET_CONN_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetLockConnection()
 *********************************************************************************************************************/
/*! \brief          Allocates a transport object for a concrete client connection.
 *  \details        -
 *  \param[in]      connHdl            The connection to be locked
 *  \param[out]     pTranspObj         The allocated transport object
 *  \return         BUFREQ_OK          The operation was successful
 *  \return         BUFREQ_E_NOT_OK    The given index was invalid
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetLockConnection(
  Dcm_NetConnRefMemType connHdl,
  CONSTP2VAR(Dcm_NetTransportObjectPtrType, AUTOMATIC, AUTOMATIC) pTranspObj
  );
#endif

/**********************************************************************************************************************
 *  Dcm_NetTpRxIndicationNotOk()
 *********************************************************************************************************************/
/*! \brief          Indication of finished reception with no success.
 *  \details        This function is called by Dcm_NetTpRxIndication.
 *  \param[in]      pTranspObj    The transport object
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpRxIndicationNotOk(
  Dcm_NetTransportObjectPtrType pTranspObj
  );

/**********************************************************************************************************************
 *  Dcm_NetTpRxIndicationOk()
 *********************************************************************************************************************/
/*! \brief          Indication of finished reception with success.
 *  \details        This function is called by Dcm_NetTpRxIndication.
 *  \param[in]      pTranspObj    The transport object
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpRxIndicationOk(
  Dcm_NetTransportObjectPtrType pTranspObj
  );

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetDelayTimerGet()
 *********************************************************************************************************************/
/*! \brief          Get remaining delay time.
 *  \details        Returns the remaining delay time of the given timer
 *  \param[in]      timer       ID of the timer
 *  \return         Remaining delay time
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TmrTimerCntrOptType, DCM_CODE) Dcm_NetDelayTimerGet(
  uint8_least timer
  );
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetDelayTimerSet()
 *********************************************************************************************************************/
/*! \brief          Set delay timeout.
 *  \details        Sets the timout for the given delay timer
 *  \param[in]      timer       ID of the timer
 *  \param[in]      timeout     Timeout value
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetDelayTimerSet(
  uint8_least timer,
  Dcm_TmrTimerCntrOptType timeout
  );
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetDelayTimerExpired()
 *********************************************************************************************************************/
/*! \brief          Check if the delay timer timed out.
 *  \details        Returns whether the given delay timer timed out
 *  \param[in]      timer       ID of the timer
 *  \return         TRUE        Timer has expired
 *  \return         FALSE       Timer is running
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetDelayTimerExpired(
  uint8_least timer
  );
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPTxObjTimerSet()
 *********************************************************************************************************************/
/*! \brief          Set the timeout for the given periodic transport object.
 *  \details        -
 *  \param[in]      pPeriodicTxObj    The periodic transport object
 *  \param[in]      timeout           Timout of the timer
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPTxObjTimerSet(
  Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj,
  Dcm_TmrTimerCntrMemType timeout
  );
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPTxObjTimerStart()
 *********************************************************************************************************************/
/*! \brief          Start the timer for the given periodic transport object.
 *  \details        -
 *  \param[in]      pPeriodicTxObj    The periodic transport object
 *  \param[in]      timeout           Timout of the timer
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPTxObjTimerStart(
  Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj,
  Dcm_TmrTimerCntrMemType timeout
  );
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPTxObjTimerStop()
 *********************************************************************************************************************/
/*! \brief          Stop the timer for the given periodic transport object.
 *  \details        -
 *  \param[in]      pPeriodicTxObj    The periodic transport object
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPTxObjTimerStop(
  Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj
  );
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgIncNextDelayTimer()
 *********************************************************************************************************************/
/*! \brief          Set delay timer index to next timer.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgIncNextDelayTimer(
  void
  );
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgSetFastestRate()
 *********************************************************************************************************************/
/*! \brief          Sets a new fastest rate.
 *  \details        -
 *  \param[in]      Rate    The periodic rate
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgSetFastestRate(
  Dcm_Svc2ASchedRateOptType Rate
  );
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPTxDelayTimerStart()
 *********************************************************************************************************************/
/*! \brief          Starts a delay timer for periodic message transmission.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPTxDelayTimerStart(
  void
  );
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutTxObjectHandler()
 *********************************************************************************************************************/
/*! \brief          Executes jobs on timeout of a transport object timer.
 *  \details        -
 *  \return         Flag whether timer needs to be reloaded
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_OnTimeoutTxObjectHandler(
  void
  );
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutDelayTimerHandler()
 *********************************************************************************************************************/
/*! \brief          Executes jobs on timeout of a delay timer.
 *  \details        -
 *  \return         Flag whether timer needs to be reloaded
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_OnTimeoutDelayTimerHandler(
  void
  );
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetGetPeriodicTxObject()
 *********************************************************************************************************************/
/*! \brief          Returns a periodic transport object element of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a periodic transport object
 *  \return         Periodic transport object
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NetPeriodicTxObjectPtrType, DCM_CODE) Dcm_NetGetPeriodicTxObject(
  Dcm_CfgNetPTxObjHandleOptType index
  );
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgGetTxBuffer()
 *********************************************************************************************************************/
/*! \brief          Return the tx buffer of the periodic message with the given index.
 *  \details        -
 *  \param[in]      perTxObjHandle    Handle of periodic transport object to be transmitted
 *  \return         Tx buffer of periodic transport object
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            The periodic message shall first be allocated via Dcm_NetPeriodicMsgAllocate()
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_MsgType, DCM_CODE) Dcm_NetPeriodicMsgGetTxBuffer(
  Dcm_CfgNetPTxObjHandleOptType perTxObjHandle
  );
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgTransmitTxObj()
 *********************************************************************************************************************/
/*! \brief          Transmits a periodic message.
 *  \details        -
 *  \param[in]      perTxObjHandle    Handle of periodic transport object to be transmitted
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            The periodic message shall first be allocated via Dcm_NetPeriodicMsgAllocate()
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgTransmitTxObj(
  Dcm_CfgNetPTxObjHandleOptType perTxObjHandle
  );
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgResetConnection()
 *********************************************************************************************************************/
/*! \brief          Resets the periodic message connection.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgResetConnection(
  void
  );
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgStopDid()
 *********************************************************************************************************************/
/*! \brief          Stops transmission of DID and also removes queued transport objects.
 *  \details        -
 *  \param[in]      Did      DID that is to be stopped
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgStopDid(
  uint16 Did
  );
#endif

/**********************************************************************************************************************
 *  Dcm_NetIsPduInfoValid()
 *********************************************************************************************************************/
/*! \brief          Checks the received PduInfo.
 *  \details        -
 *  \param[in]      info       Message context (data and length of the portion)
 *  \return         TRUE       The info element is valid
 *  \return         FALSE      The info element is not valid
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetIsPduInfoValid(
  P2CONST(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info
  );

/**********************************************************************************************************************
 *  Dcm_NetCopyRxData()
 *********************************************************************************************************************/
/*! \brief          Copies request data from the lower layer.
 *  \details        This function is called by Dcm_CopyRxData.
 *  \param[in]      pTranspObj         The transport object
 *  \param[in]      info               Message context (data and length of the portion)
 *  \param[out]     bufferSizePtr      Available buffer size
 *  \return         BUFREQ_OK          A free buffer is available - start copy data
 *  \return         BUFREQ_E_NOT_OK    No free buffer is available - ignore request
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetCopyRxData(
  Dcm_NetTransportObjectPtrType pTranspObj,
  P2CONST(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info,
  P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) bufferSizePtr
  );

/**********************************************************************************************************************
 *  Dcm_NetTpRxIndication()
 *********************************************************************************************************************/
/*! \brief          Indication of finished reception.
 *  \details        This function is called by Dcm_TpRxIndication.
 *  \param[in]      rxPduId    The RxPDUID of the request.
 *  \param[in]      result     Transmission result
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpRxIndication(
  PduIdType rxPduId,
  Std_ReturnType result
  );

/**********************************************************************************************************************
 *  Dcm_NetCopyLinearTxData()
 *********************************************************************************************************************/
/*! \brief          Copies transmit data in linear form to the lower layer.
 *  \details        This function is called by Dcm_NetCopyTxData for the linear response data case.
 *  \param[in]      pTranspObj          The transport object
 *  \param[in]      info                Pointer to a PduInfoType, which indicates the number of bytes to be copied
 *                                      (SduLength) and the location where the data have to be copied to (SduDataPtr).
 *                                      An SduLength of 0 is possible in order to poll the available transmit data
 *                                      count. In this case no data are to be copied and SduDataPtr might be invalid.
 *  \param[in]      availableDataPtr    Remaining Tx data after completion of this call
 *  \return         BUFREQ_OK           A free buffer is available - start copy data
 *  \return         BUFREQ_E_NOT_OK     Some error occurred (i.e. internal error detected)
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetCopyLinearTxData(
  Dcm_NetTransportObjectPtrType pTranspObj,
  P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info ,                                                                                                /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) availableDataPtr
  );

/**********************************************************************************************************************
 *  Dcm_NetCopyTxData()
 *********************************************************************************************************************/
/*! \brief          Copies transmit data to the lower layer.
 *  \details        This function is called by Dcm_CopyTxData.
 *  \param[in]      pTranspObj          The transport object
 *  \param[in]      info                Pointer to a PduInfoType, which indicates the number of bytes to be copied
 *                                      (SduLength) and the location where the data have to be copied to (SduDataPtr).
 *                                      An SduLength of 0 is possible in order to poll the available transmit data
 *                                      count. In this case no data are to be copied and SduDataPtr might be invalid.
 *  \param[in]      availableDataPtr    Remaining Tx data after completion of this call.
 *  \return         BUFREQ_OK           Response data is available - all requested data are copied
 *  \return         BUFREQ_E_BUSY       The required amount of data is not available - try later again
 *  \return         BUFREQ_E_NOT_OK     Some error occurred (e.g. no more data, internal error detected etc.)
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetCopyTxData(
  Dcm_NetTransportObjectPtrType pTranspObj,
  P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info ,                                                                                                /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) availableDataPtr
  );
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferInitByThread()
 *********************************************************************************************************************/
/*! \brief          Reset paged-buffer any time.
 *  \details        Resetting the paged-buffer.
 *  \param[in]      ThreadId    Active thread
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_PagedBufferInitByThread(
  Dcm_ThreadIdOptType threadId
  );
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferInit()
 *********************************************************************************************************************/
/*! \brief          Initialize paged-buffer any time.
 *  \details        Initialization of the paged-buffer.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_PagedBufferInit(
  void
  );
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferDefragmentPage()
 *********************************************************************************************************************/
/*! \brief          Defragments the current paged-buffer page.
 *  \details        -
 *  \param[in]      pContext  Pointer to the context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_PagedBufferDefragmentPage(
  Dcm_ContextPtrType pContext
  );
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferUpdatePage()
 *********************************************************************************************************************/
/*! \brief          Dispatches the UpdatePage call.
 *  \details        Dispatches the UpdatePage call regarding the paged-buffer.
 *  \param[in]      pContext  Pointer to the context
 *  \param[out]     ErrorCode             The NRC
 *  \return         DCM_E_OK              All data has been copied - evaluate the out parameters
 *  \return         DCM_E_PENDING         No result yet, retry later
 *  \return         DCM_E_NOT_OK          Something went wrong, stop updating(only in DET situation)
 *  \return         DCM_E_BUFFERTOOLOW    Some data copied but no place, retry later on TP buffer under-run
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_PagedBufferUpdatePage(
  Dcm_ContextPtrType pContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferCopyData()
 *********************************************************************************************************************/
/*! \brief          Copy from paged-buffer to the TP layer.
 *  \details        -
 *  \param[in]      pTranspObj          The transport object
 *  \param[in]      info                Message context (data and length of the portion)
 *  \param[in]      availableDataPtr    Remaining Tx data after completion of this call
 *  \return         BUFREQ_OK           A free buffer is available - start copy data
 *  \return         BUFREQ_E_NOT_OK     No free buffer is available - ignore request
 *  \return         BUFREQ_E_BUSY       No free buffer at this time - try later again
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_PagedBufferCopyData(
  Dcm_NetTransportObjectPtrType pTranspObj,
  P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info,
  P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) availableDataPtr
  );
#endif
/**********************************************************************************************************************
 *  Dcm_StateInit()
 *********************************************************************************************************************/
/*! \brief          State initialization.
 *  \details        Initialization of the state manager sub-module.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_StateInit(
  void
  );

/**********************************************************************************************************************
 *  Dcm_StateExecOnStateChangeFunc()
 *********************************************************************************************************************/
/*! \brief          Executes all registered on state change functions if precondition no more fulfilled.
 *  \details        -
 *  \param[in]      notifList        The notification list
 *  \param[in]      formerStateId    The former state
 *  \param[in]      newStateId       The new state
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_StateExecOnStateChangeFunc(
  Dcm_CfgStateNotificationInfoPtrType notifList,
  uint8 formerStateId,
  uint8 newStateId
  );

#if (DCM_STATE_SECURITY_LOOKUP_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateFindStateIndexFromSecLevel()
 *********************************************************************************************************************/
/*! \brief          Map an external state identifier to an internal state index.
 *  \details        -
 *  \param[in]      secLevel    The security level (incl. LOCKED)
 *  \return         -1          Not found
 *  \return         >= 0        Internal state index
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(sint8_least, DCM_CODE) Dcm_StateFindStateIndexFromSecLevel(
  Dcm_SecLevelType secLevel
  );
#endif

#if ((DCM_STATE_SECURITY_FIXED_BYTES_ENABLED == STD_ON)  && (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON))
/**********************************************************************************************************************
 *  Dcm_StateVsgGetSecurityFixedByteStateIdx()
 *********************************************************************************************************************/
/*! \brief         Returns referencs to active security fixed byte.
 *  \details        Returns a reference to a security fixed byte that is assigned to a active VSG
 *  \param[in,out]  pStateIndex      Index to security fixed byte VSG configuration in
 *                                   Dcm_CfgStateVsgMaskSecurityFixedByte
 *  \return         DCM_E_OK         Operation succeeded
 *  \return         DCM_E_NOT_OK     No active security fixed byte available
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_StateVsgGetSecurityFixedByteStateIdx(
  P2VAR(sint32_least, AUTOMATIC, DCM_APPL_DATA) pStateIndex
  );
#endif

#if (DCM_STATE_SECURITY_FIXED_BYTES_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateGetSecurityLevelFixedBytes()
 *********************************************************************************************************************/
/*! \brief          Provides fixed bytes set up for a specific security level.
 *  \details        This function provides the fixed bytes for the requested security level.
 *                  A security level without configured fixed bytes will return E_OK and no bytes (bufferSize = 0)
 *  \param[in]      secLevel              The requested security level
 *  \param[out]     fixedBytes            Buffer to receive the fixed byte values
 *  \param[in,out]  bufferSize
 *                  IN                    The provided buffer size
 *                  OUT                   The number of fixed bytes for the requested level
 *  \return         E_OK                  The security bytes were copied to the provided buffer
 *  \return         DCM_E_NOT_OK          The security level is not configured
 *  \return         DCM_E_BUFFERTOOLOW    The buffer was too small, bufferSize will contain the number of bytes needed
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_StateGetSecurityLevelFixedBytes(
  Dcm_SecLevelType secLevel,
  P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) fixedBytes,
  P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) bufferSize
  );
#endif

#if (DCM_STATE_NOTIFY_SVC_PRO_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateNotifyServiceProcessors()
 *********************************************************************************************************************/
/*! \brief          Notifies all related service processors for a state change (of any state group).
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_StateNotifyServiceProcessors(
  void
  );
#endif
/**********************************************************************************************************************
 *  Dcm_TmrGetTimerInfo()
 *********************************************************************************************************************/
/*! \brief          Returns a timer info element of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a timer info
 *  \return         The timer info element corresponding to the index
 *  \return         NULL_PTR      On invalid array boundaries (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TmrTimerInfoPtrType, DCM_CODE) Dcm_TmrGetTimerInfo(
  Dcm_TmrTimerIdOptType index
  );

/**********************************************************************************************************************
 *  Dcm_TmrGetTimerContext()
 *********************************************************************************************************************/
/*! \brief          Returns a timer context element of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to a timer context
 *  \return         The timer context element corresponding to the index
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TmrTimerContextPtrType, DCM_CODE) Dcm_TmrGetTimerContext(
  Dcm_TmrTimerIdOptType index
  );

/**********************************************************************************************************************
 *  Dcm_TmrInit()
 *********************************************************************************************************************/
/*! \brief          Timer initialization.
 *  \details        Initialization of the timer manager sub-module.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TmrInit(
  void
  );

/**********************************************************************************************************************
 *  Dcm_DiagSetNewReqBaseToCurProgress()
 *********************************************************************************************************************/
/*! \brief          Sets the request context base to the current progress.
 *  \details        Updates all request related members to an initial value, starting with buffer that skips the already
 *                  consumed request bytes.
 *  \param[in,out]  pMsgContext   Current message context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \synchronous    TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagSetNewReqBaseToCurProgress(
  Dcm_MsgContextPtrType pMsgContext
  );

/**********************************************************************************************************************
 *  Dcm_DiagSetQueuedTranspObj()
 *********************************************************************************************************************/
/*! \brief          Setter of the transport object carrying the diagnostic request to be processed at next.
 *                  Dcm_DiagTaskWorker() activation
 *  \details        -
 *  \param[in]      pContext      Pointer to the context with all thread specific elements
 *  \param[in]      pTranspObj    Currently active DCM external/internal connection
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagSetQueuedTranspObj(
  Dcm_ContextPtrType pContext,
  Dcm_NetTransportObjectPtrType pTranspObj
  );

/**********************************************************************************************************************
 *  Dcm_DiagSetNewResBaseToCurProgress()
 *********************************************************************************************************************/
/*! \brief          Sets the response context base to the current progress.
 *  \details        Updates all response related members to an initial value, starting with buffer that skips the already
 *                  provided response bytes.
 *  \param[in,out]  pMsgContext   Current message context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \synchronous    TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagSetNewResBaseToCurProgress(
  Dcm_MsgContextPtrType pMsgContext
  );

/**********************************************************************************************************************
 *  Dcm_DiagGetPostProcessorFunc()
 *********************************************************************************************************************/
/*! \brief          Returns a pointer to a post-processor function of the given index.
 *  \details        -
 *  \param[in]      index       Unique handle to a post-processor function
 *  \return         Post-handler
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_DiagSvcConfirmationFuncType, DCM_CODE) Dcm_DiagGetPostProcessorFunc(
  uint8_least index
  );

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagGetUpdateFunc()
 *********************************************************************************************************************/
/*! \brief          Returns a pointer to an update function of the given index.
 *  \details        -
 *  \param[in]      index    Unique handle to an update function
 *  \return         Paged-buffer update-handler
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_DiagSvcUpdateFuncType, DCM_CODE) Dcm_DiagGetUpdateFunc(
  uint8_least index
  );
#endif

/**********************************************************************************************************************
 *  Dcm_DiagInit()
 *********************************************************************************************************************/
/*! \brief          Initializes DCM diagnostic sub-module.
 *  \details        -
 *  \param[in]      configPtr    Pointer to a concrete configuration root
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts must be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagInit(
  Dcm_ConfigPtrType configPtr
  );

#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagPutStartUpFblResBuffer()
 *********************************************************************************************************************/
/*! \brief          Writes into the global start up FBL response buffer.
 *  \details        -
 *  \param[in]      index         Index to the start up FBL response buffer
 *  \param[in]      value         New value of the start up FBL response buffer
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagPutStartUpFblResBuffer(
  uint8_least index,
  Dcm_MsgItemType value
  );
#endif

/**********************************************************************************************************************
 *  Dcm_DiagAcceptNewRequest()
 *********************************************************************************************************************/
/*! \brief          Checks whether a new request will be accepted.
 *  \details        -
 *  \param[in]      pTranspObj    Currently active DCM USDT connection
 *  \return         TRUE          New request is accepted
 *  \return         FALSE         New request is not accepted
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_DiagAcceptNewRequest(
  Dcm_NetTransportObjectPtrType pTranspObj
  );

/**********************************************************************************************************************
 *  Dcm_DiagOnTxFinished()
 *********************************************************************************************************************/
/*! \brief          Notifies the diagnostic sub-module that an ongoing transmission just finished.
 *  \details        Called by the TP once an ongoing transmission is finished.
 *  \param[in]      pTranspObj    Currently active DCM USDT connection
 *  \param[in]      txStatus      Transmission result
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagOnTxFinished(
  Dcm_NetTransportObjectPtrType pTranspObj,
  Dcm_NetTransmissionResultType txStatus
  );

/**********************************************************************************************************************
 *  Dcm_DiagExecConfirmationFunc()
 *********************************************************************************************************************/
/*! \brief          Executes a confirmation callback and evaluates its return values.
 *  \details        -
 *  \param[in]     pContext       Pointer to the context
 *  \param[in]      notifList     The diagnostic request confirmation list to be executed
 *  \param[in]      confStatus    The post-processing status
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            The last element of the passed notifList must be marked by NULL_PTR.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagExecConfirmationFunc(
  Dcm_ContextPtrType pContext,
  Dcm_CfgDiagNotificationInfoPtrType notifList,
  Dcm_ConfirmationStatusType confStatus
  );

/**********************************************************************************************************************
 *  Dcm_DiagGetPostProcessResult()
 *********************************************************************************************************************/
/*! \brief          Calculates the Dcm_ConfirmationType value for the post processors.
 *  \details        -
 *  \param[in]      pContext    Pointer to the context
 *  \return         The confirmation status
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_ConfirmationStatusType, DCM_CODE) Dcm_DiagGetPostProcessResult(
  Dcm_ContextPtrType pContext
  );

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagGetRecoverySignature()
 *********************************************************************************************************************/
/*! \brief          Composes the recovery information control check-sum signature.
 *  \details        -
 *  \return         The control checksum
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(uint32, DCM_CODE) Dcm_DiagGetRecoverySignature(
  void
  );
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagProvideRecoveryStates()
 *********************************************************************************************************************/
/*! \brief          Takes the restored DCM state over.
 *  \details        Takes the external stored and recovered DCM state over.
 *  \param[in,out]  RecoveryInfo    Reference to structure that stores recovery info
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagProvideRecoveryStates(
  P2VAR(Dcm_RecoveryInfoType, AUTOMATIC, DCM_APPL_DATA) RecoveryInfo
  );
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagProcessRecoveryInfo()
 *********************************************************************************************************************/
/*! \brief          Takes the restored DCM state over.
 *  \details        Takes the external stored and recovered DCM state over.
 *  \param[in,out]  RecoveryInfo    Reference to structure that stores recovery info
 *  \param[in]      opStatus        Current operation status
 *  \context        TASK
 *  \return         DCM_E_OK        Processing succeeded
 *  \return         DCM_E_PENDING   Disable DTC API call is pending
 *  \return         DCM_E_NOT_OK    Disable DTC API call failed
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagProcessRecoveryInfo(
  P2CONST(Dcm_RecoveryInfoType, AUTOMATIC, DCM_VAR_NOINIT) RecoveryInfo,
  Dcm_OpStatusType opStatus
  );
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagSafeProcessRecoveryInfo()
 *********************************************************************************************************************/
/*! \brief          Checks and takes the restored DCM state over.
 *  \details        Checks and takes the external stored and recovered DCM state over.
 *  \param[in,out]  RecoveryInfo    Reference to structure that stores recovery info
 *  \param[in]      opStatus        Current operation status
 *  \context        TASK
 *  \return         DCM_E_OK        Processing succeeded
 *  \return         DCM_E_PENDING   Disable DTC API call is pending
 *  \return         DCM_E_NOT_OK    Processing failed
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagSafeProcessRecoveryInfo(
  P2CONST(Dcm_RecoveryInfoType, AUTOMATIC, DCM_VAR_NOINIT) RecoveryInfo,
  Dcm_OpStatusType opStatus
  );
#endif

#if (DCM_DIAG_SPECIFIC_CAUSE_CODE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagSetSpecificCauseCode()
 *********************************************************************************************************************/
/*! \brief          Registers a specific cause code.
 *  \details        Registers a specific cause code to the request in progress if no other specific cause code already
 *                  set.
 *  \param[in]      specificCauseCode    The specific cause code to be registered
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagSetSpecificCauseCode(
  Dcm_SpecificCauseCodeType specificCauseCode
  );
#endif

#if (DCM_MULTI_THREAD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagIsSessionChangeAllowed()
 *********************************************************************************************************************/
/*! \brief          Checks whether any other thread is currently busy with a parallel request.
 *  \details        -
 *  \param[in]      pContext    Pointer to the context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagIsSessionChangeAllowed(
  Dcm_ContextPtrType pContext
  );
#endif

/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoCancelProcCancelOpenJobs()
 *********************************************************************************************************************/
/*! \brief          Cancel open diagnostic jobs.
 *  \details        -
 *  \param[in]      pContext    Pointer to the context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoCancelProcCancelOpenJobs(
  Dcm_ContextPtrType pContext
  );

/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoCancelProcReviveKilledTasks()
 *********************************************************************************************************************/
/*! \brief          Revive tasks that were killed during cancellation.
 *  \details        -
 *  \param[in]      pContext       Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoCancelProcReviveKilledTasks(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );

/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoCancelProcessing()
 *********************************************************************************************************************/
/*! \brief          Performs diagnostic job cancellation.
 *  \details        If a diagnostic job is ongoing the appropriate action will be taken to close it deterministically.
 *  \param[in]      pContext       Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoCancelProcessing(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );

/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoPostProcessing()
 *********************************************************************************************************************/
/*! \brief          Performs post processing of currently finished request.
 *  \details        -
 *  \param[in]      pContext        Pointer to the context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoPostProcessing(
  Dcm_ContextPtrType pContext
  );

/**********************************************************************************************************************
 *  Dcm_DiagWorkerSetDefSessionExtern()
 *********************************************************************************************************************/
/*! \brief          Performs session transition to the default session on external request.
 *  \details        Synchronizes an external session change request with the internal DCM state. If a diagnostic job is
 *                  still in processing, the session change request will be postponed till the job is finished. This is
 *                  required in order to guarantee clean sequence flow on session change and active diagnostic jobs.
 *  \param[in]      pContext  Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerSetDefSessionExtern(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );

/**********************************************************************************************************************
 *  Dcm_DiagSwitchProcessingContext()
 *********************************************************************************************************************/
/*! \brief          Performs a context switch of the current working serivice processing set.
 *  \details        -
 *  \param[in]      pContext    Pointer to the context
 *  \context        TASK
 *  \return         DCM_E_OK                Initialization succeeded, proceed with next step
 *  \return         DCM_E_NOT_OK            Initialization failed, repeat again next time
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagSwitchProcessingContext(
  Dcm_ContextPtrType pContext
  );

/**********************************************************************************************************************
 *  Dcm_DiagInitMsgContextBufferInfo()
 *********************************************************************************************************************/
/*! \brief          Initializes the given message context.
 *  \details        Initializes the given message context so that it points always to a valid buffer.
 *  \param[in,out]  pMsgContext   Current message context
 *  \param[in]      index         Unique handle to a buffer information element
 *  \context        TASK
 *  \reentrant      TRUE
 *  \synchronous    TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagInitMsgContextBufferInfo(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_CfgNetBufferRefOptType index
  );

/**********************************************************************************************************************
 *  Dcm_DiagInitiateServiceProcessing()
 *********************************************************************************************************************/
/*! \brief          Initiates diagnostic kernel for new request processing.
 *  \details        -
 *  \param[in]      pContext        Pointer to the context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *  \note           The parameter pMsgContext is passed to this function for initialization.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagInitiateServiceProcessing(
  Dcm_ContextPtrType pContext
  );

/**********************************************************************************************************************
 *  Dcm_DiagHandleSuppressBit()
 *********************************************************************************************************************/
/*! \brief          Handles the SPRMIB if set and supported by the requested service.
 *  \details        -
 *  \param[in]      pContext       Pointer to the context
 *  \param[in]      pTranspObj     The transport object
 *  \param[in,out]  pMsgContext    Current request context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagHandleSuppressBit(
  Dcm_ContextPtrType pContext,
  Dcm_NetTransportObjectPtrType pTranspObj,
  Dcm_MsgContextPtrType pMsgContext
  );

/**********************************************************************************************************************
 *  Dcm_DiagHandleDispatching()
 *********************************************************************************************************************/
/*! \brief          Handles the service dispatching.
 *  \details        -
 *  \param[in]      sid            The SID of the request
 *  \param[in,out]  pMsgContext    Current request context
 *  \param[in]      pContext       Pointer to the context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagHandleDispatching(
  uint8 sid,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_ContextPtrType pContext
  );

/**********************************************************************************************************************
 *  Dcm_DiagValidateAndDispatchService()
 *********************************************************************************************************************/
/*! \brief          Validates received SID and dispatches further processing.
 *  \details        -
 *  \param[in,out]  pMsgContext             Current request context
 *  \param[out]     ErrorCode               The error code to be returned
 *  \return         DCM_E_OK                Validation succeeded. Initiate recognized service processing
 *  \return         DCM_E_NOT_OK            Validation failed. Finish service processing with the ErrorCode result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Dcm_DiagInitiateServiceProcessing() shall be called first.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagValidateAndDispatchService(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_ContextPtrType pContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_DiagWorkerProcessNewRequest()
 *********************************************************************************************************************/
/*! \brief          Initiates diagnostic service processing once a new request is received.
 *  \details        -
 *  \param[in]      pContext  Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerProcessNewRequest(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );

/**********************************************************************************************************************
 *  Dcm_DiagWorkerProcessRcrRpTxEnd()
 *********************************************************************************************************************/
/*! \brief          Prepares for application notification after enforced RCR-RP transmission.
 *  \details        -
 *  \param[in]      pContext  Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerProcessRcrRpTxEnd(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON) && \
    (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagWorkerCancelOperation()
 *********************************************************************************************************************/
/*! \brief          Cancels any ongoing diagnostic operation.
 *  \details        -
 *  \param[in]      pContext  Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerCancelOperation(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );
#endif

#if (DCM_STATE_SECURITY_BYPASS_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagWorkerSetSecurityBypass()
 *********************************************************************************************************************/
/*! \brief          Performs security level bypass.
 *  \details        Enables or disables a security bypass mode. If a diagnostic job is still in processing,
 *                  the security bypass mode will be postponed until the job is finished. This is required
 *                  in order to prevent security state inconsistencies.
 *  \param[in]      pContext       Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerSetSecurityBypass(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );
#endif

/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoRepeat()
 *********************************************************************************************************************/
/*! \brief          Triggers a scheduled diagnostic job activity.
 *  \details        Each registered diagnostic job activity will be called out from this point.
 *  \param[in]      pContext  Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoRepeat(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );

#if (DCM_TSK_NUM_DIAG_FBLRES > 0u)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoGetProgCond()
 *********************************************************************************************************************/
/*! \brief          Gets the programming conditions from FBL/Application.
 *  \details        Checks and takes the external stored and recovered DCM state over.
 *  \param[in]      pContext       Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagFblResDoGetProgCond(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0u)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoWaitTxComm()
 *********************************************************************************************************************/
/*! \brief          Waits until the ComM has processed the DCM communication request.
 *  \details        Waits for either P2Star timeout of ComM acknowledge of channel wake up.
 *  \param[in]      pContext       Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagFblResDoWaitTxComm(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0u)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoResetFlags()
 *********************************************************************************************************************/
/*! \brief          Resets all FBL flags.
 *  \details        Resets all FBL related flags so at next power-on/reset no final response to be sent.
 *  \param[in]      pContext       Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagFblResDoResetFlags(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0u)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoProcessTxConfirmation()
 *********************************************************************************************************************/
/*! \brief          Performs a session transition after a final positive response.
 *  \details        If the final response was for SID 0x10, the corresponding session transition is performed here.
 *  \param[in]      pContext       Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagFblResDoProcessTxConfirmation(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagTxPostponeFinalPagedResponse()
 *********************************************************************************************************************/
/*! \brief          Postpones the diagnostic service final response transmission if paged-buffer used.
 *  \details        The postponing is required only if the SPRMIB was set. Since the SPMRIB=TRUE means
 *                  "execute job, but do not send a response", in the case of paged-buffer the response is sent during
 *                  the "job execution". So if the P2 time is exceeded while performing the job, the final response may
 *                  not be able to provide all of the response data (the previous data pages are already lost)
 *  \param[in]      pContext  Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagTxPostponeFinalPagedResponse(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );
#endif

/**********************************************************************************************************************
 *  Dcm_DiagTxStartFinalResponse()
 *********************************************************************************************************************/
/*! \brief          Initiates diagnostic service final response transmission.
 *  \details        -
 *  \param[in]      pContext  Pointer to the context
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagTxStartFinalResponse(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  );

/**********************************************************************************************************************
 *  Dcm_DiagTxStartRcrRpResponse()
 *********************************************************************************************************************/
/*! \brief          Initiates diagnostic service RCR-RP response transmission.
 *  \details        -
 *  \param[in]      pContext  Pointer to the context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagTxStartRcrRpResponse(
  Dcm_ContextPtrType pContext
  );

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagGetRecoveryInfoComMChannelState()
*********************************************************************************************************************/
/*! \brief          Returns a pointer to a ComM channel state of the recovery info.
 *  \details        -
 *  \param[in]      RecoveryInfo    Reference to structure that stores recovery info
 *  \param[in]      index           Index to a ComM channel state
 *  \return         A valid pointer to a ComM channel state
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_RecoveryInfoComMChannelStatePtrType, DCM_CODE) Dcm_DiagGetRecoveryInfoComMChannelState(
  P2VAR(Dcm_RecoveryInfoType, AUTOMATIC, DCM_APPL_DATA) RecoveryInfo,
  Dcm_CfgNetNetIdRefOptType index
  );
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON && DCM_MODE_COMMCTRL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagGetRecoveryInfoCommControlState()
*********************************************************************************************************************/
/*! \brief          Returns a pointer to the communication state of a ComM channel of the recovery info.
 *  \details        -
 *  \param[in]      RecoveryInfo    Reference to structure that stores recovery info
 *  \param[in]      index           Index to the communication state of a ComM channel
 *  \return         A valid pointer to the communication state of a ComM channel
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
*********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_RecoveryInfoCommControlStatePtrType, DCM_CODE) Dcm_DiagGetRecoveryInfoCommControlState(
  P2VAR(Dcm_RecoveryInfoType, AUTOMATIC, DCM_APPL_DATA) RecoveryInfo,
  Dcm_CfgNetNetIdRefOptType index
  );
#endif

/**********************************************************************************************************************
 *  Dcm_DiagIsCancellationNeeded()
 *********************************************************************************************************************/
/*! \brief          Check whether cancellation of diagnostic service processing is necessary.
 *  \details        -
 *  \param[in]      pTranspObj    Currently active DCM TP connection
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_DiagIsCancellationNeeded(
  Dcm_NetTransportObjectPtrType pTranspObj
  );
#if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc10_TriggerReset()
 *********************************************************************************************************************/
/*! \brief          Triggers an Ecu Reset.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_FORCE_RCRRP       Enforce a RCR-RP transmission
 *  \return         DCM_E_LOOP              Execute next repeater stage immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_NOT_OK            Operation failed, send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10_TriggerReset(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc10RepeaterProxyContextPtrType pRepContext
  );
#endif


#if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc10_WaitForResetAck()
 *********************************************************************************************************************/
/*! \brief          Wait for Ecu Reset acknowledgment.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_FORCE_RCRRP       Enforce a RCR-RP transmission
 *  \return         DCM_E_LOOP              Execute next repeater stage immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_NOT_OK            Operation failed, send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10_WaitForResetAck(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc10RepeaterProxyContextPtrType pRepContext
  );
#endif

#if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc10_WaitForRcrRpAck()
 *********************************************************************************************************************/
/*! \brief          Wait for RCR-RP acknowledgment.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_LOOP              Execute next repeater stage immediately
 *  \return         DCM_E_NOT_OK            Operation failed, send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10_WaitForRcrRpAck(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc10RepeaterProxyContextPtrType pRepContext
  );
#endif

#if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc10_SetProgConditions()
 *********************************************************************************************************************/
/*! \brief          Sets programming conditions.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_STOP_REPEATER     Trigger to stop repeater (programming conditions set)
 *  \return         DCM_E_NOT_OK            Operation failed, send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10_SetProgConditions(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc10RepeaterProxyContextPtrType pRepContext
  );
#endif

/**********************************************************************************************************************
 *  Dcm_Svc10Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x10 Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send final positive response
 *  \return         DCM_E_LOOP              Execute next repeater stage immediately
 *  \return         DCM_E_NOT_OK            Operation failed
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc10RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc10CheckAccess()
 *********************************************************************************************************************/
/*! \brief          Checks whether transistion to requested session can be performed.
 *  \details        If e.g. any OBD request is currently in progress the session change request has to be delayed.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send final positive response
 *  \return         DCM_E_LOOP              Execute next repeater stage immediately
 *  \return         DCM_E_NOT_OK            Operation failed
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10CheckAccess(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc10RepeaterProxyContextPtrType pRepContext
  );
#if (DCM_SVC_22_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc22GetDidInfoContext()
 *********************************************************************************************************************/
/*! \brief          Returns a pointer to a DidInfoContext of the index given by the repeater proxy context.
 *  \details        -
 *  \param[in,out]  pRepContext    Current repeater proxy context
 *  \return         A valid pointer to a DidInfoContext
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_DidMgrDidInfoContextPtrType, DCM_CODE) Dcm_Svc22GetDidInfoContext(
  Dcm_Svc22RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc22Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x22 Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc22RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc22ReadDid()
 *********************************************************************************************************************/
/*! \brief          Reads a single paged DID for service 0x22.
 *  \details        -
 *  \param[in]      opStatus                The operation status
 *  \param[in,out]  pDataContext            The pointer to the data context
 *  \param[in,out]  pDidInfoContext         The DID configuration context
 *  \param[in,out]  pDidOpTypeContext       The DID configuration operation context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_OK                All data has been copied
 *  \return         DCM_E_PENDING           No result yet, retry later
 *  \return         DCM_E_BUFFERTOOLOW      Some data copied but no place, retry later on TP buffer under-run
 *  \return         DCM_E_FORCE_RCRRP       Enforce a RCR-RP transmission
 *  \return         DCM_E_NOT_OK            The DID reading has failed for some reason. NRC is already set.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22ReadDid(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_Svc22UtiReadData()
 *********************************************************************************************************************/
/*! \brief          Reads the requested DIDs for service 0x22.
 *  \details        This is shared utility function of the Repeater and PagedBuffer.
 *  \param[in]      opStatus                Current operation status
 *  \param[in,out]  pDataContext            Pointer to the data context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \param[in,out]  pRepContext             Service 0x22 repeater context
 *  \return         DCM_E_OK                All data has been copied
 *  \return         DCM_E_PENDING           No result yet, retry later
 *  \return         DCM_E_BUFFERTOOLOW      Some data copied but no place, retry later on TP buffer under-run
 *  \return         DCM_E_FORCE_RCRRP       Enforce a RCR-RP transmission
 *  \return         DCM_E_NOT_OK            The DID reading has failed for some reason. NRC is already set.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22UtiReadData(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc22RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc22DidLookUp()
 *********************************************************************************************************************/
/*! \brief          A generic DID look-up for SID 0x22.
 *  \details        Performs a lookup for a specific DID on any request.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Go to next step
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22DidLookUp(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc22RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc22CheckCondition()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x22.
 *  \details        Checks the conditions of a requested DID.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22CheckCondition(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc22RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc22GetLength()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x22.
 *  \details        Reads the length of a requested DID.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22GetLength(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc22RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc22ReadData()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x22.
 *  \details        Reads the data of a requested DID.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_FORCE_RCRRP       Force RCR-RP
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22ReadData(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc22RepeaterProxyContextPtrType pRepContext
  );
#endif /* (DCM_SVC_22_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_24_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc24Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x2C Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc24Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc24RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc24ExecuteOp()
 *********************************************************************************************************************/
/*! \brief          Service 0x24 operation execution unit.
 *  \details        Executes a specific service 0x24 operation.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc24ExecuteOp(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc24RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc24DidLookUp()
 *********************************************************************************************************************/
/*! \brief          Service 0x24 DID look up client.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Stop polling
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc24DidLookUp(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc24RepeaterProxyContextPtrType pRepContext
  );
#endif /* (DCM_SVC_24_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc27SecLevelInfoGetEntry()
 *********************************************************************************************************************/
/*! \brief          Get security level descriptor.
 *  \details        -
 *  \param[in]      secLev           Zero based security level index
 *  \param[out]     pSecLevelInfo    The security level descriptor
 *  \param[out]     ErrorCode        Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_OK         The operation was successful
 *  \return         DCM_E_NOT_OK     The given index was invalid (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgSvc27SecLevelInfoGetEntry(
  uint8_least secLev,
  CONSTP2VAR(Dcm_CfgSvc27SecLevelInfoPtrType, AUTOMATIC, AUTOMATIC) pSecLevelInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_Svc27CounterSet()
 *********************************************************************************************************************/
/*! \brief          Sets the value of a specific security level attempt counter.
 *  \details        -
 *  \param[in]      secLev      Zero based security level index
 *  \param[in]      value       Attempt counter value
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27CounterSet(
  uint8_least secLev,
  uint8 value
  );

/**********************************************************************************************************************
 *  Dcm_Svc27CounterInc()
 *********************************************************************************************************************/
/*! \brief          Increments the value of a specific security level attempt counter.
 *  \details        -
 *  \param[in]      secLev      Zero based security level index
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27CounterInc(
  uint8_least secLev
  );

/**********************************************************************************************************************
 *  Dcm_Svc27TimerSet()
 *********************************************************************************************************************/
/*! \brief          Sets the value of a specific security level timer.
 *  \details        -
 *  \param[in]      secLev      Zero based security level index
 *  \param[in]      value       Timer value
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27TimerSet(
  uint8_least secLev,
  Dcm_TmrTimerCntrMemType value
  );

/**********************************************************************************************************************
 *  Dcm_Svc27TimerStart()
 *********************************************************************************************************************/
/*! \brief          Sets the value of a specific security level timer.
 *  \details        Starts the base security level timer.
 *  \param[in]      secLev      Zero based security level index
 *  \param[in]      value       Timer value for the specific security level
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27TimerStart(
  uint8_least secLev,
  Dcm_TmrTimerCntrMemType value
  );

/**********************************************************************************************************************
 *  Dcm_Service27Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x27 Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc27RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Service27SeedProcessor()
 *********************************************************************************************************************/
/*! \brief          Service 0x27 get application generated seed.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \return         DCM_E_OK                Request was successful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27SeedProcessor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc27RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Service27KeyProcessor()
 *********************************************************************************************************************/
/*! \brief          Service 0x27 get application key comparator.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               Negative response code in case return value is DCM_E_NOT_OK
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27KeyProcessor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc27RepeaterProxyContextPtrType pRepContext
  );

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27UtiGetAttemptCntr()
 *********************************************************************************************************************/
/*! \brief          Restores the attempt counter values from the application.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in,out]  levelMask               Pointer to a security level mask.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27UtiGetAttemptCntr(
  Dcm_OpStatusType opStatus,
  P2VAR(uint32, AUTOMATIC, DCM_VAR_NOINIT) levelMask
  );
# endif

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27ReadAttemptCounter()
 *********************************************************************************************************************/
/*! \brief          Manages reading of an attempt counter value.
 *  \details        If a diagnostic job is ongoing the appropriate action will be taken to close it deterministically.
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27ReadAttemptCounter(
  Dcm_TskEventContextPtrType pEventContext
  );
# endif

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27WriteAttemptCounter()
 *********************************************************************************************************************/
/*! \brief          Manages writing of an attempt counter value.
 *  \details        If a diagnostic job is ongoing the appropriate action will be taken to close it deterministically.
 *  \param[in,out]  pEventContext  Pointer to the event context
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27WriteAttemptCounter(
  Dcm_TskEventContextPtrType pEventContext
  );
# endif

/**********************************************************************************************************************
 *  Dcm_Service27SeedRepeater()
 *********************************************************************************************************************/
/*! \brief          Service 0x27 get seed service port accessor.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in,out]  pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27SeedRepeater(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc27RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Service27KeyRepeater()
 *********************************************************************************************************************/
/*! \brief          Service 0x27 send key service port accessor.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send neagative response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27KeyRepeater(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_ReadOnlyMsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc27RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Service27CheckAttemptsExceededRepeater()
 *********************************************************************************************************************/
/*! \brief          Checks whether the number of allowed attempts were reached.
 *  \details        Determines the final negative response code (0x35 or 0x36).
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27CheckAttemptsExceededRepeater(
  Dcm_OpStatusType opStatus,
  Dcm_ReadOnlyMsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc27RepeaterProxyContextPtrType pRepContext
  );

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27SetAttemptCntrRepeater()
 *********************************************************************************************************************/
/*! \brief          Service 0x27 set attempt counter service port accessor.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27SetAttemptCntrRepeater(
  Dcm_OpStatusType opStatus,
  Dcm_ReadOnlyMsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc27RepeaterProxyContextPtrType pRepContext
  );
# endif
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_29_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc29SubFuncInfoGetEntry()
 *********************************************************************************************************************/
/*! \brief          Get subfunction descriptor.
 *  \details        -
 *  \param[in]      subSvcRef       Index to a subfunction descriptor
 *  \param[out]     pSubFuncInfo    The subfunction descriptor
 *  \param[out]     ErrorCode       Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_OK        The operation was successful
 *  \return         DCM_E_NOT_OK    The given index was invalid (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgSvc29SubFuncInfoGetEntry(
  Dcm_DiagSubServiceRefOptType subSvcRef,
  CONSTP2VAR(Dcm_CfgSvc29SubFuncInfoPtrType, AUTOMATIC, AUTOMATIC) pSubFuncInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_Svc29Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x29 Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  );

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON) || (DCM_SVC_29_04_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29CbkResultDispatcher()
 *********************************************************************************************************************/
/*! \brief          Dispatch the asynchronous callback result.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29CbkResultDispatcher(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  );
# endif

/**********************************************************************************************************************
 *  Dcm_Svc29SubFuncHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x29 SubFunction Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send positive response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29SubFuncHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  );

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchAuthentication()
 *********************************************************************************************************************/
/*! \brief          Mode switching for authentication state change.
 *  \details        -
 *  \param[in]      authInfoRef     The authentication info table reference
 *  \param[in]      mode            The next authentication mode
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_ModeSwitchAuthentication(
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  uint8 mode
  );
# endif

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON) || (DCM_SVC_29_04_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29KeyMSetCertificate()
 *********************************************************************************************************************/
/*! \brief          Set certificate wrapper function.
 *  \details        Stores certificate in KeyM and handles possible return values.
 *  \param[in]      certId                The certificate identifier
 *  \param[in]      pCertificateData      Pointer to struct containing certificate data and length
 *  \param[out]     ErrorCode             The NRC
 *  \return         DCM_E_NOT_OK          Send negative response
 *  \return         DCM_E_OK              Successful
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29KeyMSetCertificate(
  KeyM_CertificateIdType certId,
  P2CONST(KeyM_CertDataType, AUTOMATIC, DCM_APPL_DATA) pCertificateData,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON) || (DCM_SVC_29_04_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29KeyMVerifyCertificate()
 *********************************************************************************************************************/
/*! \brief          Verify stored certificate wrapper function.
 *  \details        Verifies stored certificate in KeyM and handles possible return values.
 *  \param[in]      pContext              Pointer to the context
 *  \param[in]      certId                The certificate identifier
 *  \param[out]     ErrorCode             The NRC
 *  \return         DCM_E_NOT_OK          Send negative response
 *  \return         DCM_E_PENDING         Retry later
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29KeyMVerifyCertificate(
  Dcm_ContextPtrType pContext,
  KeyM_CertificateIdType certId,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29GeneralNrcCheck()
 *********************************************************************************************************************/
/*! \brief          Changes Certificate Verification Failed NRC to General NRC.
 *  \details        If NRC pertains to Certificate Verification Failed, it is changed to General NRC.
 *  \param[in]      pContext              Pointer to the context
 *  \param[in,out]  ErrorCode             The NRC
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc29GeneralNrcCheck(
  Dcm_ContextPtrType pContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29FinalizeSequenceStartReq()
 *********************************************************************************************************************/
/*! \brief          Finalize request processing of subfunction 0x01 and 0x02.
 *  \details        -
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \return         DCM_E_OK                Send positive response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29FinalizeSequenceStartReq(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

# if (DCM_SVC_29_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29GetServerCertificate()
 *********************************************************************************************************************/
/*! \brief          Gets the server certificate of KeyM.
 *  \details        -
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Server certificate retreived
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29GetServerCertificate(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29ValidateCsmCbkResult()
 *********************************************************************************************************************/
/*! \brief          Validates the callback result of Csm.
 *  \details        -
 *  \param[out]     ErrorCode               The NRC
 *  \return         DCM_E_OK                Successful callback result
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29ValidateCsmCbkResult(
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON) || (DCM_SVC_29_04_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29ValidateKeyMCbkResult()
 *********************************************************************************************************************/
/*! \brief          Validates the callback result of KeyM.
 *  \details        -
 *  \param[out]     ErrorCode               The NRC
 *  \return         DCM_E_OK                Successful callback result
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29ValidateKeyMCbkResult(
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif
#endif /* (DCM_SVC_29_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/* --- public members ---------------------------------------------------------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_Service2ASchedulerInit()
 *********************************************************************************************************************/
/*! \brief          Initialization function.
 *  \details        Initializes the periodic DID scheduler.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Service2ASchedulerInit(
  void
  );

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdAddItemByDid()
 *********************************************************************************************************************/
/*! \brief          Inserts a new item to the scheduler without activating it.
 *  \details        -
 *  \param[in,out]  pDidInfoContext    The context of the DID
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdAddItemByDid(
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdCommit()
 *********************************************************************************************************************/
/*! \brief          Commits already inserted items to be scheduled with a given rate.
 *  \details        -
 *  \param[in]      rate    The scheduling rate
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdCommit(
  Dcm_Svc2ASchedRateMemType rate
  );

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdDiscard()
 *********************************************************************************************************************/
/*! \brief          Discards all inserted items.
 *  \details        -
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdDiscard(
  void
  );

# if (DCM_DIDMGR_PERIODICDID_CLR_ON_STATE_CHG_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2AOnStateChanged()
 *********************************************************************************************************************/
/*! \brief          Stops all scheduled DIDs no more allowed by the new states.
 *  \details        Stops all scheduled DIDs that are nor more allowed after the state has been changed.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2AOnStateChanged(
  void
  );
# endif

/* --- private members --------------------------------------------------------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdFindFreeOrInUseItemByDid()
 *********************************************************************************************************************/
/*! \brief          Tries to find already used DID entry slot. If not, returns the last free found.
 *  \details        -
 *  \param[in]      did           The did
 *  \param[in]      schdHandle    Handle of the found slot
 *  \return         TRUE          A slot was found
 *  \return         FALSE         No slot was found - schdHandle output parameter is invalid
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_Svc2ASchdFindFreeOrInUseItemByDid(
  uint16 did,
  P2VAR(Dcm_Svc2ASchdItemHandleOptType, AUTOMATIC, AUTOMATIC) schdHandle
  );

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdUpdateTimers()
 *********************************************************************************************************************/
/*! \brief          Updates all active scheduled item timers.
 *  \details        -
 *  \return         TRUE     Activate processor task
 *  \return         FALSE    Don't activate processor task
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_Svc2ASchdUpdateTimers(
  void
  );

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdNextEntryIdxInc()
 *********************************************************************************************************************/
/*! \brief          Scheduler item iterator increment.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdNextEntryIdxInc(
  void
  );

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdGetEntry()
 *********************************************************************************************************************/
/*! \brief          Obtain a service 0x2A scheduler entry.
 *  \details        -
 *  \param[in]      schdHandle    The scheduler entry handle
 *  \return         Pointer to requested 2A scheduler entry - if handle is invalid, pointer to first entry
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_Svc2ASchdEntryPtrType, DCM_CODE) Dcm_Svc2ASchdGetEntry(
  Dcm_Svc2ASchdItemHandleOptType schdHandle
  );

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdInitDidMgrResources()
 *********************************************************************************************************************/
/*! \brief          Allocate DID manager resources for PDID
 *  \details        -
 *  \param[in,out]  pDataContext    Pointer to the data context
 *  \param[in]      did             The DID that is about to be read
 *  \return         DCM_E_OK        Continue processing
 *  \return         DCM_E_PENDING   DID is currently in use by another service
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ASchdInitDidMgrResources(
  Dcm_DiagDataContextPtrType pDataContext,
  uint16 did
  );

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdProcessEntry()
 *********************************************************************************************************************/
/*! \brief          A single PDID processing step.
 *  \details        Performs PDID reading and sending on expired PDID slots.
 *  \param[in]      pSchedTableEntry    The scheduler entry to be processed
 *  \return         DCM_E_OK        Continue processing
 *  \return         DCM_E_PENDING   Processing was postponed
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ASchdProcessEntry(
  Dcm_Svc2ASchdEntryPtrType pSchedTableEntry
  );
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2AScheduledDidLookUp()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2A.
 *  \details        Performs a lookup for a specific DID on scheduling requests.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Go to next step
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AScheduledDidLookUp(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ARepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2AStoppedDidLookUp()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2A.
 *  \details        Performs a lookup for a specific DID on stop DID requests.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Go to next step
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AStoppedDidLookUp(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ARepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2ADidCheckCondition()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2A.
 *  \details        Checks the conditions of a requested DID.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADidCheckCondition(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ARepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2ADidGetLength()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2A.
 *  \details        Returns the length of a requested DID.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Go on with next DID
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADidGetLength(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ARepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2AIsUdsRateSupported()
 *********************************************************************************************************************/
/*! \brief          Checks whether the UDS rate is supported.
 *  \details        -
 *  \param[in]      udsRate                 Rate to be checked
 *  \return         TRUE                    Rate is supported
 *  \return         FALSE                   Rate is not supported
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_Svc2AIsUdsRateSupported(
  Dcm_Svc2ATransmissionModeType udsRate
  );

/**********************************************************************************************************************
 *  Dcm_Svc2ADoScheduleDids()
 *********************************************************************************************************************/
/*! \brief          Updates the scheduler content.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADoScheduleDids(
  Dcm_ContextPtrType pContext,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_Svc2AStopScheduledDids()
 *********************************************************************************************************************/
/*! \brief          Stops requested DIDs.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AStopScheduledDids(
  Dcm_ContextPtrType pContext,
  Dcm_MsgContextPtrType pMsgContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2AHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x2A Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Operation failed
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ARepeaterProxyContextPtrType pRepContext
  );
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrInit()
 *********************************************************************************************************************/
/*! \brief          Initialization function.
 *  \details        Service 0x2C DID definition manager initializer.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2CDefMgrInit(
  void
  );

/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrReadSrcItems()
 *********************************************************************************************************************/
/*! \brief          Performs reading on a single DynDID source item (DID or memory area).
 *  \details        -
 *  \param[in]      opStatus         Current DynDID read operation status.
 *  \param[in,out]  pDataContext     Pointer to the data context
 *  \param[in,out]  pProcessContext  The process context
 *  \return         DCM_E_OK         Read of all source items finished with success.
 *  \return         DCM_E_PENDING    One of the source items needs more time to return final result, call again.
 *  \return         DCM_E_NOT_OK     One of the source items returned an error.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrReadSrcItems(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_Svc2CDynDidProcessContextPtrType pProcessContext
  );

# if (DCM_DIDMGR_DYNDID_CLR_ON_STATE_CHG_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2COnStateChanged()
 *********************************************************************************************************************/
/*! \brief          Clears all no more allowed DynDIDs in the new states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2COnStateChanged(
  void
  );
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2CGetSrcItem()
 *********************************************************************************************************************/
/*! \brief          Return the requested source item
 *  \details        -
 *  \param[in]      srcItemIndex    Index of the source item
 *  \return         The requested source item or any valid source item if the provided index is invalid
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_Svc2CDynDidSrcItemPtrType, DCM_CODE) Dcm_Svc2CGetSrcItem(
  Dcm_CfgDidMgrDynDidSrcItemIdxOptType srcItemIndex
  );

/**********************************************************************************************************************
 *  Dcm_Svc2CGetItem()
 *********************************************************************************************************************/
/*! \brief          Return the requested item
 *  \details        -
 *  \param[in]      itemIndex    Index of the item
 *  \return         The requested item or any valid item if the provided index is invalid
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_Svc2CDynDidItemPtrType, DCM_CODE) Dcm_Svc2CGetItem(
  Dcm_CfgDidMgrDynDidHandleOptType itemIndex
  );

/**********************************************************************************************************************
 *  Dcm_Svc2CGetDDDidProcessContext()
 *********************************************************************************************************************/
/*! \brief          Return the requested process context
 *  \details        -
 *  \param[in]      processContextIndex    Index of the process context
 *  \return         The process context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_Svc2CDynDidProcessContextPtrType, DCM_CODE) Dcm_Svc2CGetDDDidProcessContext(
  uint8 processContextIndex
  );

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C01DefMgrRead()
 *********************************************************************************************************************/
/*! \brief          Reads a single DID source item.
 *  \details        -
 *  \param[in]      opStatus        Current DID sourceItem operation status.
 *  \param[in,out]  pDataContext    Pointer to the data context
 *  \param[in,out]  pProcessContext The process context
 *  \return         DCM_E_OK        Reading finished with success.
 *  \return         DCM_E_PENDING   Reading needs some additional time. Call again.
 *  \return         DCM_E_NOT_OK    Reading finished with failed.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C01DefMgrRead(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_Svc2CDynDidProcessContextPtrType pProcessContext
  );
# endif

# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C02DefMgrRead()
 *********************************************************************************************************************/
/*! \brief          Reads a single Memory source item.
 *  \details        -
 *  \param[in]      opStatus        Current Memory sourceItem operation status.
 *  \param[in,out]  pDataContext    Pointer to the data context
 *  \return         DCM_E_OK            Reading finished with success.
 *  \return         DCM_E_FORCE_RCRRP   Send RCR-RP response. Once sent, call again.
 *  \return         DCM_E_PENDING       Reading needs some additional time. Call again.
 *  \return         DCM_E_NOT_OK        Reading finished with failed.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C02DefMgrRead(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext
  );
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrReadCheckAccessAndInit()
 *********************************************************************************************************************/
/*! \brief          Check read acces for requested DynDID.
 *  \details        -
 *  \param[in]      dynDidHandle    Current dynDid handle to be read.
 *  \param[in,out]  pOpStatus       Current and modified operation status.
 *  \return         DCM_E_OK            Check succeeded, proceed with read.
 *  \return         DCM_E_PENDING       The DynDID is still in usage, try later
 *  \return         DCM_E_NOT_OK        Check failed, leave the DynDID reading.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrReadCheckAccessAndInit(
  Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle,
  P2VAR(Dcm_OpStatusType, AUTOMATIC, AUTOMATIC) pOpStatus
  );
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc2CSubFuncInfoGetEntry()
 *********************************************************************************************************************/
/*! \brief          Get subfunction descriptor.
 *  \details        -
 *  \param[in]      SubSvcRef       Index to a subfunction descriptor
 *  \param[out]     pSubFuncInfo    The subfunction descriptor
 *  \param[out]     ErrorCode       Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_OK        The operation was successful
 *  \return         DCM_E_NOT_OK    The given index was invalid (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgSvc2CSubFuncInfoGetEntry(
  Dcm_DiagSubServiceRefOptType SubSvcRef,
  CONSTP2VAR(Dcm_CfgSvc2CSubFuncInfoPtrType, AUTOMATIC, AUTOMATIC) pSubFuncInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_Svc2CHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x2C Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2CSubFuncHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x2C SubFunction Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CSubFuncHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  );

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C01SrcDidLookUp()
 *********************************************************************************************************************/
/*! \brief          Processes the source items of service 0x2C 0x01.
 *  \details        Performs a lookup for a specific source DID.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C01SrcDidLookUp(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C01SrcDidCheckCondition()
 *********************************************************************************************************************/
/*! \brief          Processes the source items of service 0x2C 0x01.
 *  \details        Checks the condition of a specific source DID.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C01SrcDidCheckCondition(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C01SrcDidGetLength()
 *********************************************************************************************************************/
/*! \brief          Processes the source items of service 0x2C 0x01.
 *  \details        Calculates and stores the length of a specific source DID.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C01SrcDidGetLength(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C02SrcItemsGetLength()
 *********************************************************************************************************************/
/*! \brief          Processes the source items of service 0x2C 0x02.
 *  \details        Calculates the total length of all source items
 *  \param[in]      alfid                   The ALFID of the request
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Calculation succeeded
 *  \return         DCM_E_NOT_OK            Error during calculation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C02SrcItemsGetLength(
  uint8 alfid,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_2C_03_SUPPORT_ENABLED == STD_ON)                                                                                                       /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_Svc2C03DidLookUp()
 *********************************************************************************************************************/
/*! \brief          Service 0x2C 0x03 dedicated DID look up client.
 *  \details        -
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \param[out]     ErrorCode      The NRC
 *  \param[out]     pRepContext    Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C03DidLookUp(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  );
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2CSetMaxAllowedDynDIDLength()
 *********************************************************************************************************************/
/*! \brief          Set the maximum allowed length for the currently processed DynDID.
 *  \details        -
 *  \param[in]      pContext       Pointer to the context
 *  \param[in]      pRepContext    Current repeater proxy context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2CSetMaxAllowedDynDIDLength(
  Dcm_ContextPtrType pContext,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  );

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CInitDidInfoFromDidInfoIdx()
 *********************************************************************************************************************/
/*! \brief          Returns information of a specific DID.
 *  \details        Retrieve the DID information using DidInfoIdx.
 *  \param[in]      didInfoIdx        The current operation status
 *  \param[in,out]  pSrcDidContext    The source DID context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \synchronous    TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2CInitDidInfoFromDidInfoIdx(
  Dcm_CfgDidMgrDidInfoRefType didInfoIdx,
  Dcm_DidMgrDidInfoContextPtrType pSrcDidContext
  );
# endif
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2EHandler()
 *********************************************************************************************************************/
/*! \brief          Handles Service 0x2E.
 *  \details        Checks if Did information is correct and either ready to write data or pending.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2EHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ERepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2ECheckAccess()
 *********************************************************************************************************************/
/*! \brief          Checks the service 0x2E access.
 *  \details        Tries to lock a given Did and react accordingly.
 *  \param[in]      pContext         Pointer to the context
 *  \param[in]      opStatus         Current operation status
 *  \param[in]      pMsgContext      Pointer to current message context
 *  \param[in]      pRepContext      Current repeater proxy context
 *  \param[out]     ErrorCode        The NRC
 *  \return         DCM_E_LOOP       Repeat immediately
 *  \return         DCM_E_PENDING    Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ECheckAccess(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ERepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2EWriteData()
 *********************************************************************************************************************/
/*! \brief          Executes service 0x2E operation.
 *  \details        Writes the intended data and releases the lock if the operation result is not pending.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_OK                Send response
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2EWriteData(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ERepeaterProxyContextPtrType pRepContext
  );
#endif /* (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x2F Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \return         DCM_E_PENDING           Final result is pending, retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext
  );

# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FGetActiveIoDids()
 *********************************************************************************************************************/
/*! \brief          Return the requested active IODIDs bit mask
 *  \details        -
 *  \param[in]      ioDidIndex              Index of the IODID
 *  \return         The active IODIDs bit mask
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_UtiBitSetBasePtrType, DCM_CODE) Dcm_Svc2FGetActiveIoDids(
  Dcm_CfgDidMgrIoDidHandleOptType ioDidIndex
  );
# endif

# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FReturnControlToEcu()
 *********************************************************************************************************************/
/*! \brief          Reset all active IO controls.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FReturnControlToEcu(
  void
  );
# endif

# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FOnStateChanged()
 *********************************************************************************************************************/
/*! \brief          Reset all active IO controls no more supported in the active DCM state.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FOnStateChanged(
  void
  );
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2FExtractCEMR()
 *********************************************************************************************************************/
/*! \brief          Extracts the CEMR from the request.
 *  \details        Extracts the CEMR from a byte stream into a 32bit variable. If CEMRsize > 4 -> value is 0.
 *  \param[in]      cemrStream   Points to the beginning of the CEMR in the request
 *  \param[in]      cemrSize     Specifies the CEMR total length
 *  \return         0            If the CEMR size > 4 or no bit has been set. This value is invalid and will only
 *                               be used as initialization of the CEMR, but not passed to the application for NBit CEMR.
 *  \return         >0           Extracted CEMR. Note: For 3Byte CEMR the result is MSB bound!

 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(uint32, DCM_CODE) Dcm_Svc2FExtractCEMR(
  Dcm_ReadOnlyMsgType cemrStream,
  Dcm_CfgDidMgrIoDidCemrLengthMemType cemrSize
  );

/**********************************************************************************************************************
 *  Dcm_Svc2FProcessCEMR()
 *********************************************************************************************************************/
/*! \brief          Processes CEMR of IO DID request if the IO DID supports CEMR.
 *  \details        On IO DIDs with CEMR the CEMR will be extracted and verified for non-zero value.
 *  \param[in,out]  pMsgContext        The current request context
 *  \param[in,out]  pRepContext        Current repeater proxy context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FProcessCEMR(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2FCalculateExpectedReqLength()
 *********************************************************************************************************************/
/*! \brief          Calculates the expected request length including DID data and CEMR.
 *  \details        -
 *  \param[out]     expLengthMin        Returns the expected request minimum length.
 *  \param[out]     expLengthMax        Returns the expected request maximum length.
 *  \param[in,out]  pRepContext         Current repeater proxy context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FCalculateExpectedReqLength(
  Dcm_DidMgrDidLengthPtrType expLengthMin,
  Dcm_DidMgrDidLengthPtrType expLengthMax,
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2FCheckReqLength()
 *********************************************************************************************************************/
/*! \brief          Verifies the request length.
 *  \details        Verifies that the request length is valid for the concrete DID and IO operation incl. CEMR.
 *  \param[in,out]  pMsgContext        The current request context
 *  \param[in,out]  pRepContext        Current repeater proxy context
 *  \return         DCM_E_POSITIVERESPONSE            Request length is valid.
 *  \return         !=DCM_E_POSITIVERESPONSE          A validation error has occurred.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_Svc2FCheckReqLength(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2FIoDidOperationProcessor()
 *********************************************************************************************************************/
/*! \brief          Process a concrete IODID and its requested operation.
 *  \details        -
 *  \param[in]      pContext         Pointer to the context
 *  \param[in]      pMsgContext      Pointer to current message context
 *  \param[out]     ErrorCode        The NRC
 *  \param[out]     pRepContext      Current repeater proxy context
 *  \return         DCM_E_NOT_OK     Send negative response
 *  \return         DCM_E_LOOP       Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FIoDidOperationProcessor(
  Dcm_ContextPtrType pContext,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2FCheckAccess()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2F.
 *  \details        Checks the service 0x2F access.
 *  \param[in]      pContext         Pointer to the context
 *  \param[in]      opStatus         Current operation status
 *  \param[in]      pMsgContext      Pointer to current message context
 *  \param[out]     ErrorCode        The NRC
 *  \param[in]      pRepContext      Current repeater proxy context
 *  \return         DCM_E_LOOP       Repeat immediately
 *  \return         DCM_E_PENDING    Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FCheckAccess(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2FExecuteOp()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2F.
 *  \details        Executes a specific service 0x2F operation.
 *  \param[in]      pContext       Pointer to the context
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \param[out]     ErrorCode        The NRC
 *  \param[in,out]  pRepContext      Current repeater proxy context
 *  \return         Next action to perform
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FExecuteOp(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2FGetLength()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2F.
 *  \details        Reads the length of a requested DID.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FGetLength(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2FReadData()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2F.
 *  \details        -
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \param[out]     ErrorCode      The NRC
 *  \param[out]     pRepContext    Current repeater proxy context
 *  \return         DCM_E_OK       Send response
 *  \return         DCM_E_NOT_OK   Send negative response
 *  \return         DCM_E_PENDING  Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FReadData(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext
  );
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc86SubFuncInfoGetEntry()
 *********************************************************************************************************************/
/*! \brief          Get subfunction descriptor.
 *  \details        -
 *  \param[in]      SubSvcRef       Index to a subfunction descriptor
 *  \param[out]     pSubFuncInfo    The subfunction descriptor
 *  \param[out]     ErrorCode       Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_OK        The operation was successful
 *  \return         DCM_E_NOT_OK    The given index was invalid (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgSvc86SubFuncInfoGetEntry(
  Dcm_DiagSubServiceRefOptType SubSvcRef,
  CONSTP2VAR(Dcm_CfgSvc86SubFuncInfoPtrType, AUTOMATIC, AUTOMATIC) pSubFuncInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_Svc86Handler()
 *********************************************************************************************************************/
/*! \brief          Service 0x86 Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc86Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc86RepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc86SubFuncHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x86 SubFunction Handler.
 *  \details        -
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             Current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_LOOP              Repeat Repeater Proxy immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc86SubFuncHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc86RepeaterProxyContextPtrType pRepContext
  );
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
#include "Dcm_MemMap.h"                                                                                                                              /* PRQA S 5087 */ /* MD_MSR_MemMap */

#define DCM_START_SEC_CODE
#include "Dcm_MemMap.h"                                                                                                                              /* PRQA S 5087 */ /* MD_MSR_MemMap */
#if (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_STATE_AUTHENTICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrGetCertRole()
 *********************************************************************************************************************/
/*! \brief          Reads the role element of a certificate.
 *  \details        -
 *  \param[in]      opStatus                   The operation status
 *  \param[out]     ErrorCode                  The NRC
 *  \param[in,out]  pRepContext                The repeater context
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   Successful
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrGetCertRole(
  Dcm_OpStatusType opStatus,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_AUTHMGR_WHITELISTS_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrGetCertWLElement()
 *********************************************************************************************************************/
/*! \brief          Reads a white list element of a certificate.
 *  \details        -
 *  \param[in]      certificateId              Certificate Id
 *  \param[in]      certElementId              Certificate element Id
 *  \param[out]     pElementData               Pointer to store the element data
 *  \param[in,out]  pElementDataLength         Element data length
 *  \param[in]      opStatus                   The operation status
 *  \param[in,out]  pRepContext                The repeater context
 *  \param[out]     ErrorCode                  The NRC
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   No element left (end of list)
 *  \return         DCM_E_LOOP                 Element successfully read
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrGetCertWLElement(
  uint16 certificateId,
  uint16 certElementId,
  Dcm_MsgType pElementData,
  Dcm_Uint32VarDataPtrType pElementDataLength,
  Dcm_OpStatusType opStatus,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

# if (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrServiceWLReadList()
 *********************************************************************************************************************/
/*! \brief          Reads the services white list element of a certificate.
 *  \details        -
 *  \param[in,out]  pRepContext                The repeater context
 *  \param[out]     ErrorCode                  The NRC
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   Successful
 *  \return         DCM_E_PENDING              Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrServiceWLReadList(
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

# if (DCM_AUTHMGR_WHITELIST_DID_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrDidWLReadList()
 *********************************************************************************************************************/
/*! \brief          Reads the DID white list element of a certificate.
 *  \details        -
 *  \param[in,out]  pRepContext                The repeater context
 *  \param[out]     ErrorCode                  The NRC
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   Successful
 *  \return         DCM_E_PENDING              Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrDidWLReadList(
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

# if (DCM_AUTHMGR_WHITELIST_RID_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrRidWLReadList()
 *********************************************************************************************************************/
/*! \brief          Reads the RID white list element of a certificate.
 *  \details        -
 *  \param[in,out]  pRepContext                The repeater context
 *  \param[out]     ErrorCode                  The NRC
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   Successful
 *  \return         DCM_E_PENDING              Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrRidWLReadList(
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

# if (DCM_AUTHMGR_WHITELIST_MEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrMemWLReadList()
 *********************************************************************************************************************/
/*! \brief          Reads the memory selection white list element of a certificate.
 *  \details        -
 *  \param[in,out]  pRepContext                The repeater context
 *  \param[out]     ErrorCode                  The NRC
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   Successful
 *  \return         DCM_E_PENDING              Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrMemWLReadList(
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

# if (DCM_STATE_AUTHENTICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckRole()
 *********************************************************************************************************************/
/*! \brief          Authentication role check for execution preconditons reference
 *  \details        -
 *  \param[in]      stateRef                   The operation execution precondition reference
 *  \param[in]      authInfoRef                The authentication information reference
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   Successful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckRole(
  Dcm_CfgStateRefOptType stateRef,
  Dcm_CfgNetAuthInfoRefMemType authInfoRef
  );
# endif

# if (DCM_STATE_AUTHENTICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckDispatcherLevel()
 *********************************************************************************************************************/
/*! \brief          Authentication access rights check on dispatcher level
 *  \details        -t
 *  \param[in]      sid                        The service identifier
 *  \param[in]      stateRef                   The operation execution precondition reference
 *  \param[in,out]  pMsgContext                The message context
 *  \param[in]      authInfoRef                The authentication information reference
 *  \param[out]     ErrorCode                  The NRC
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   Successful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckDispatcherLevel(
  uint8 sid,
  Dcm_CfgStateRefOptType stateRef,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

# if (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckServiceWLDispatcher()
 *********************************************************************************************************************/
/*! \brief          Authentication service white list check for DSD
 *  \details        Checks that the request matches first bytes of an element in service white list
 *  \param[in]      sid                        The service identifier
 *  \param[in,out]  pMsgContext                The message context
 *  \param[in]      authInfoRef                The authentication information reference
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   Successful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckServiceWLDispatcher(
  uint8 sid,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_CfgNetAuthInfoRefMemType authInfoRef
  );
# endif

# if (DCM_AUTHMGR_DID_CHECK_ENABLED == STD_ON)
#  if (DCM_AUTHMGR_WHITELIST_DID_ENABLED == STD_ON) || \
      (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckDidWL()
 *********************************************************************************************************************/
/*! \brief          Authentication DID white list check
 *  \details        Checks if DID and op matches element in DID white list
 *  \param[in]      did                        The DID identifier
 *  \param[in]      didOpMask                  The operation (bit-wise)
 *  \param[in]      authInfoRef                The authentication information reference
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   Successful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckDidWL(
  uint16 did,
  Dcm_DidOpType didOpMask,
  Dcm_CfgNetAuthInfoRefMemType authInfoRef
  );
#  endif
# endif

# if (DCM_AUTHMGR_DID_CHECK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckDid()
 *********************************************************************************************************************/
/*! \brief          DID operation authentication checks
 *  \details        Checks if DID operation is allowed by role or DID white list
 *  \param[in]      connHdl                    The connection identifier
 *  \param[in]      did                        The DID identifier
 *  \param[in]      didOpMask                  The operation (bit-wise)
 *  \param[in]      stateRef                   The operation execution precondition reference
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   Successful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckDid(
  Dcm_NetConnRefMemType connHdl,
  uint16 did,
  Dcm_DidOpType didOpMask,
  Dcm_CfgStateRefOptType stateRef
  );
# endif

# if (DCM_AUTHMGR_WHITELIST_RID_ENABLED == STD_ON) || \
     (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckRidWL()
 *********************************************************************************************************************/
/*! \brief          Authentication RID white list check
 *  \details        Checks if RID and op matches element in RID white list
 *  \param[in]      rid                        The RID identifier
 *  \param[in]      ridSubfunc                 The routine control subfunction
 *  \param[in]      authInfoRef                The authentication information reference
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   Successful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckRidWL(
  uint16 rid,
  uint8 ridSubfunc,
  Dcm_CfgNetAuthInfoRefMemType authInfoRef
  );
# endif

# if (DCM_AUTHMGR_RID_CHECK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckRid()
 *********************************************************************************************************************/
/*! \brief          RID operation authentication checks
 *  \details        Checks if RID operation is allowed by role or RID white list
 *  \param[in]      pContext                   Pointer to the context
 *  \param[in]      rid                        The RID identifier
 *  \param[in]      ridSubfunc                 The routine control subfunction
 *  \param[in]      stateRef                   The operation execution precondition reference
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   Successful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckRid(
  Dcm_ContextPtrType pContext,
  uint16 rid,
  uint8 ridSubfunc,
  Dcm_CfgStateRefOptType stateRef
  );
# endif

# if (DCM_AUTHMGR_WHITELIST_MEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckMemWL()
 *********************************************************************************************************************/
/*! \brief          Authentication MEM white list check
 *  \details        Checks if MemorySelection matches element in MEM white list
 *  \param[in]      memId                      The MemorySelection
 *  \param[in]      authInfoRef                The authentication information reference
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   Successful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckMemWL(
  uint8 memId,
  Dcm_CfgNetAuthInfoRefMemType authInfoRef
  );
# endif
#endif /* (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_NetUnRegisterAllComMActivity()
 *********************************************************************************************************************/
/*! \brief          Tries to unregister all ComM channels activities.
 *  \details        -
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUnRegisterAllComMActivity(
  void
  );

/**********************************************************************************************************************
 *  Dcm_NetUnRegisterComMActivity()
 *********************************************************************************************************************/
/*! \brief          Tries to unregister a ComM channel activity.
 *  \details        -
 *  \param[in]      connHdl    The connection which has finished its job
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            Must be called only for external diagnostic requests
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUnRegisterComMActivity(
  Dcm_NetConnRefMemType connHdl
  );

/**********************************************************************************************************************
 *  Dcm_NetRegisterComMActivity()
 *********************************************************************************************************************/
/*! \brief          Tries to register a ComM channel activity.
 *  \details        -
 *  \param[in]      pTranspObj    The transport object which starts diagnostic job
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetRegisterComMActivity(
  Dcm_NetTransportObjectPtrType pTranspObj
  );

/**********************************************************************************************************************
 *  Dcm_NetUsdtTxConfirmation()
 *********************************************************************************************************************/
/*! \brief          Transport object transmission finalization.
 *  \details        Finalization of a transmitted USDT message.
 *  \param[in]      pTranspObj    The transport object used during transmission
 *  \param[in]      result        The transmission result
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUsdtTxConfirmation(
  Dcm_NetTransportObjectPtrType pTranspObj,
  Dcm_NetTransmissionResultType result
  );

/**********************************************************************************************************************
 *  Dcm_NetAllocateOrGetTranspObject()
 *********************************************************************************************************************/
/*! \brief          Transport object allocation.
 *  \details        Allocates a transport object for a concrete client connection.
 *  \param[in]      connHdl            The connection identifier
 *  \param[out]     pTranspObj         The allocated transport object
 *  \return         BUFREQ_OK          The operation was successful
 *  \return         BUFREQ_E_NOT_OK    The given index was invalid (if runtime checks enabled)
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Must be called within a critical section to guarantee unique result
 *********************************************************************************************************************/
DCM_LOCAL FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetAllocateOrGetTranspObject(
  Dcm_NetConnRefOptType connHdl,
  CONSTP2VAR(Dcm_NetTransportObjectPtrType, AUTOMATIC, AUTOMATIC) pTranspObj
  );

/**********************************************************************************************************************
 *  Dcm_NetGetTranspObjOfConnection()
 *********************************************************************************************************************/
/*! \brief          Returns the transport object of the given connection.
 *  \details        -
 *  \param[in]      connHdl            The connection identifier
 *  \param[out]     pTranspObj         The transport object assigned to the given connection
 *  \return         BUFREQ_OK          The operation was successful
 *  \return         BUFREQ_E_NOT_OK    The given index was invalid
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            Since only getter, can be called outside of a critical section, but for consistent results do call within critical section
 *********************************************************************************************************************/
DCM_LOCAL FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetGetTranspObjOfConnection(
  Dcm_NetConnRefOptType connHdl,
  CONSTP2VAR(Dcm_NetTransportObjectPtrType, AUTOMATIC, AUTOMATIC) pTranspObj
  );

/**********************************************************************************************************************
 *  Dcm_NetTranspObjRelease()
 *********************************************************************************************************************/
/*! \brief          Release transport object resource.
 *  \details        Releases a given transport object.
 *  \param[in]      pTranspObj    The transport object to be released
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTranspObjRelease(
  Dcm_NetTransportObjectPtrType pTranspObj
  );

/**********************************************************************************************************************
 *  Dcm_NetGetConnHdlByTesterAddress()
 *********************************************************************************************************************/
/*! \brief          Tries to find the corresponding connection of a diagnostic client.
 *  \details        -
 *  \param[in]      testerAddress    The diagnostic client address to look for
 *  \return         < DCM_NET_INVALID_CONNHDL    Valid connection id found.
 *  \return         DCM_NET_INVALID_CONNHDL      No connection found for the source address.
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NetConnRefMemType, DCM_CODE) Dcm_NetGetConnHdlByTesterAddress(
  uint16 testerAddress
  );

#if ((DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON) && (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)) || \
    (DCM_AUTHMGR_SET_DEAUTH_ROLE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetGetConnHdlByConnectionId()
 *********************************************************************************************************************/
/*! \brief          Tries to find the corresponding connection of a connection handle.
 *  \details        -
 *  \param[in]      connectionId                Connection identifier
 *  \return         < DCM_NET_INVALID_CONNHDL    Valid connection id found.
 *  \return         DCM_NET_INVALID_CONNHDL      No connection found for the source address.
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NetConnRefMemType, DCM_CODE) Dcm_NetGetConnHdlByConnectionId(
  uint16 connectionId
  );
#endif

/**********************************************************************************************************************
 *  Dcm_NetUnRegisterActiveConnection()
 *********************************************************************************************************************/
/*! \brief          Unregister a connection.
 *  \details        Unregister an active connection referenced by the given transport object.
 *  \param[in]      pTranspObj    The transport object to be released
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUnRegisterActiveConnection(
  Dcm_NetTransportObjectPtrType pTranspObj
  );

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgAllocate()
 *********************************************************************************************************************/
/*! \brief          Periodic message allocation.
 *  \details        Allocates a resource for a periodic message.
 *  \param[in]      Did     DID of the message that is allocated
 *  \return         DCM_NET_INVALID_PTXOBJ_HANDLE      No free resource found
 *  \return         < DCM_NET_INVALID_PTXOBJ_HANDLE    A concrete valid handle is returned
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_CfgNetPTxObjHandleMemType, DCM_CODE) Dcm_NetPeriodicMsgAllocate(
  uint16 Did
  );
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgRelease()
 *********************************************************************************************************************/
/*! \brief          Releases a concrete periodic message resource.
 *  \details        -
 *  \param[in]      pPeriodicTxObj    The periodic transport object
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgRelease(
  Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj
  );
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgTransmit()
 *********************************************************************************************************************/
/*! \brief          Transmits a periodic message.
 *  \details        -
 *  \param[in]      pPeriodicTxObj    The periodic transport object
 *  \param[in]      length            The periodic response message length
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgTransmit(
  Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj,
  PduLengthType length
  );
#endif

/**********************************************************************************************************************
 *  Dcm_NetStartOfReception()
 *********************************************************************************************************************/
/*! \brief          Start of new request reception.
 *  \details        This function is called by Dcm_StartOfReception.
 *  \param[in]      rxPduId            The RxPDUID of the request
 *  \param[in]      info               Message context (data and length of the portion)
 *  \param[in]      tpSduLength        The total length of the TP message
 *  \param[out]     bufferSizePtr      Available buffer size
 *  \param[in]      addTObjFlags       Additional transport object flags from caller
 *  \return         BUFREQ_OK          A free buffer is available - start copy data
 *  \return         BUFREQ_E_NOT_OK    No free buffer is available - ignore request
 *  \return         BUFREQ_E_OVFL      The request message is too long for the configured buffer
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetStartOfReception(
  PduIdType rxPduId,
  P2CONST(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info,
  PduLengthType tpSduLength,
  P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) bufferSizePtr,
  Dcm_NetTransportObjectFlagType addTObjFlags
  );

/**********************************************************************************************************************
 *  Dcm_NetIsKeepAliveRequest()
 *********************************************************************************************************************/
/*! \brief          Check whether request is functional TesterPresent with SPRMIB set.
 *  \details        -
 *  \param[in]      rxPduId            The RxPDUID of the request
 *  \param[in]      info               Message context (data and length of the portion)
 *  \param[in]      neededLength       The length to be a TesterPresent  message
 *  \return         TRUE               Request is a functional TesterPresent with SPRMIB set
 *  \return         FALSE              Request is not a functional TesterPresent with SPRMIB set
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(boolean, DCM_CODE) Dcm_NetIsKeepAliveRequest(
  PduIdType rxPduId,
  P2CONST(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info,
  uint8 neededLength
  );

/**********************************************************************************************************************
 *  Dcm_NetSetComModeEntered()
 *********************************************************************************************************************/
/*! \brief          Internal utility for updating the new communication state.
 *  \details        -
 *  \param[in]      networkId      The communication channel on which this state is now active
 *  \param[in]      newComState    The new state of the communication channel (e.g. DCM_NET_COMM_STATE_RX_DIS_TX_DIS)
 *  \context        ISR1|ISR2
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetSetComModeEntered(
  NetworkHandleType networkId,
  Dcm_NetComMStateType newComState
  );
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferExecute()
 *********************************************************************************************************************/
/*! \brief          Starts polling a paged buffer update function.
 *  \details        -
 *  \param[in]      pContext  Pointer to the context
 *  \param[in,out]  pDataContext          The pointer to the data context
 *  \param[out]     ErrorCode             The NRC
 *  \return         DCM_E_OK              All data has been copied - evaluate the out parameters
 *  \return         DCM_E_PENDING         No result yet, retry later
 *  \return         DCM_E_PENDING_LIMITER Runtime limit reached, retry later
 *  \return         DCM_E_NOT_OK          Something went wrong, stop updating (only in DET situation)
 *  \return         DCM_E_BUFFERTOOLOW    Some data copied but no place, retry later on TP buffer under-run
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_PagedBufferExecute(
  Dcm_ContextPtrType pContext,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferCancel()
 *********************************************************************************************************************/
/*! \brief          Dispatches the CancelPage call.
 *  \details        Dispatches the CancelPage call regarding the paged-buffer.
 *  \param[in]      pContext        Pointer to the context
 *  \param[out]     ErrorCode       The NRC
 *  \return         DCM_E_OK        Operation finished with success
 *  \return         DCM_E_NOT_OK    Operation failed, ErrorCode contains the NRC
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_PagedBufferCancel(
  Dcm_ContextPtrType pContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
#endif
/**********************************************************************************************************************
 *  Dcm_StateSetSession()
 *********************************************************************************************************************/
/*! \brief          Performs a session state transition.
 *  \details        -
 *  \param[in]      stateRef    The state order number.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_StateSetSession(
  Dcm_StateIndexOptType stateRef
  );

#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateSetSecurity()
 *********************************************************************************************************************/
/*! \brief          Performs a security state transition.
 *  \details        -
 *  \param[in]      stateRef    The state order number.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_StateSetSecurity(
  Dcm_StateIndexOptType stateRef
  );
#endif
/**********************************************************************************************************************
 *  Dcm_OnTimeoutP2()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when a P2 timeout occurs.
 *  \param[in]      ThreadId  Active thread
 *  \return         Returns always 0 -> no reload
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutP2(
  Dcm_ThreadIdMemType threadId
  );

/**********************************************************************************************************************
 *  Dcm_OnTimeoutS3()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when a S3 timeout occurs.
 *  \param[in]      ThreadId  Active thread
 *  \return         Returns always 0 -> no reload
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutS3(
  Dcm_ThreadIdMemType threadId
  );

#if (DCM_TMR_NUM_FBLRES > 0u)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutFblRes()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when the P2* time expires after FBL-to-APPL transition.
 *  \param[in]      ThreadId  Active thread
 *  \return         Returns always 0 -> no reload
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutFblRes(
  Dcm_ThreadIdMemType threadId
  );
#endif

#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutSecurityAccess()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when a security access timeout occurs.
 *  \param[in]      ThreadId  Active thread
 *  \return         Number of reload ticks
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutSecurityAccess(
  Dcm_ThreadIdMemType threadId
  );
#endif

#if (DCM_TMR_NUM_PERIODIC_TX > 0u)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutPeriodicTx()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        The periodic transmission timeout is reached
 *  \param[in]      ThreadId  Active thread
 *  \return         Number of reload ticks
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutPeriodicTx(
  Dcm_ThreadIdMemType threadId
  );
#endif

#if (DCM_TMR_NUM_SVC2A_SCHEDULER > 0u)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutSvc2AScheduler()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when a service 0x2A scheduler timeout occurs.
 *  \param[in]      ThreadId  Active thread
 *  \return         Number of reload ticks
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutSvc2AScheduler(
  Dcm_ThreadIdMemType threadId
  );
#endif

#if (DCM_TMR_NUM_KEEP_ALIVE > 0u)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutKeepAlive()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when a keep alive timeout occurs.
 *  \param[in]      ThreadId  Active thread
 *  \return         Number of reload ticks
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutKeepAlive(
  Dcm_ThreadIdMemType threadId
  );
#endif

#if (DCM_TMR_NUM_AUTHENTICATION > 0u)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutAuthentication()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when a authentication timeout occurs.
 *  \return         Number of reload ticks
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutAuthentication(
  Dcm_ThreadIdMemType threadId
  );
#endif
/**********************************************************************************************************************
 *  Dcm_DiagRcrRpTxFinished()
 *********************************************************************************************************************/
/*! \brief          Performs post processing of currently finished RCR-RP transmission.
 *  \details        -
 *  \param[in]      pTranspObj    Currently active DCM TP connection
 *  \param[in]      txStatus      Transmission result
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagRcrRpTxFinished(
  Dcm_NetTransportObjectPtrType pTranspObj,
  Dcm_NetTransmissionResultType txStatus
  );

/**********************************************************************************************************************
 *  Dcm_DiagSetP2Timings()
 *********************************************************************************************************************/
/*! \brief          Sets the adjusted P2 timings.
 *  \details        -
 *  \param[in]      sesStateIdx    The index of the current session.
 *  \param[in]      protocolIdx    The index of the current protocol.
 *  \param[in]      threadId       Active thread
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagSetP2Timings(
  Dcm_StateIndexMemType sesStateIdx,
  Dcm_NetProtRefMemType protocolIdx,
  Dcm_ThreadIdMemType threadId
  );

/**********************************************************************************************************************
 *  Dcm_DiagRxIndication()
 *********************************************************************************************************************/
/*! \brief          Called once an incoming reception is finished.
 *  \details        -
 *  \param[in]      pTranspObj    Currently active DCM external/internal connection
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagRxIndication(
  Dcm_NetTransportObjectPtrType pTranspObj
  );

/**********************************************************************************************************************
 *  Dcm_SetNegResponse()
 *********************************************************************************************************************/
/*! \brief          Registers a NRC to the request in progress if no other NRC already set.
 *  \details        -
 *  \param[in]      nrc         The error code to be registered
 *  \param[in]      threadId    Active thread
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_SetNegResponse(
  Dcm_NegativeResponseCodeType nrc,
  Dcm_ThreadIdOptType threadId
  );

/**********************************************************************************************************************
 *  Dcm_ProcessingDone()
 *********************************************************************************************************************/
/*! \brief          Finalizes the service job processing.
 *  \details        -
 *  \param[in]      threadId    Active thread
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ProcessingDone(
  Dcm_ThreadIdOptType threadId
  );

/**********************************************************************************************************************
 *  Dcm_DiagLookUpFilter()
 *********************************************************************************************************************/
/*! \brief          Performs a lookup result filtering.
 *  \details        -
 *  \param[in,out]  pMsgContext          The current request context
 *  \param[in]      lookUpTable          Pointer to the table to be scanned (first element is table-size!)
 *  \param[in]      lookUpFilterTable    List of filters
 *  \param[in]      value                Value to be found
 *  \param[in]      chkLevel             Hierarchy level on which the lookup is performed
 *  \param[out]     errorCode            The error code to be returned
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_DiagLookUpFilter(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_Uint8ConstDataPtrType lookUpTable,
  Dcm_VarRefMemPtrType lookUpFilterTable,
  uint8 value,
  Dcm_DiagCheckLvlType chkLevel,
  Dcm_NegativeResponseCodePtrType errorCode
  );

/**********************************************************************************************************************
 *  Dcm_DiagSvcWithSubFuncStateCheck()
 *********************************************************************************************************************/
/*! \brief          Performs a state rule check for a service with sub-function.
 *  \details        -
 *  \param[in,out]  pMsgContext               Current request context
 *  \param[in]      stateRef                  Reference to the state precondition table
 *  \param[in]      subFuncSequenceChecker    Function for accessing a service specific sequence check
 *  \param[in]      subSvcRef                 The sub-function zero-based index
 *  \param[out]     ErrorCode                 The NRC
 *  \return         DCM_E_OK                  State rule check was sucessful
 *  \return         DCM_E_NOT_OK              State rule check was not sucessful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagSvcWithSubFuncStateCheck(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_CfgStateRefOptType stateRef,
  Dcm_DiagSubFuncSequenceCheckerFuncType subFuncSequenceChecker,
  Dcm_DiagSubServiceRefOptType subSvcRef,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_DiagExecIndicationFunc()
 *********************************************************************************************************************/
/*! \brief          Executes an indication callback and evaluates its return values.
 *  \details        -
 *  \param[in]      pContext            Pointer to the context
 *  \param[in]      sid                 The requested SID
 *  \param[in]      notificationType    The notification kind (OEM, SYS)
 *  \param[in]      notifList           The request indication list to be executed
 *  \param[out]     ErrorCode           The NRC
 *  \return         DCM_E_OK            Proceed with service validation after return
 *  \return         DCM_E_NOT_OK        At least one Xxx_Indication() has rejected further processing
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            The last element of the passed notifList must be marked by NULL_PTR.
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagExecIndicationFunc(
  Dcm_ContextPtrType pContext,
  Dcm_MsgItemType sid,
  Dcm_DiagApplNotificationType notificationType,
  Dcm_CfgDiagNotificationInfoPtrType notifList,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );

/**********************************************************************************************************************
 *  Dcm_DiagTxFinalization()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        -
 *  \param[in]      pTranspObj    Currently active DCM TP connection
 *  \param[in]      txStatus      Transmission result
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTxFinalization(
  Dcm_NetTransportObjectPtrType pTranspObj,
  Dcm_NetTransmissionResultType txStatus
  );

#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagOnFblResTxFinished()
 *********************************************************************************************************************/
/*! \brief          Called by the TP once an ongoing transmission is finished.
 *  \details        -
 *  \param[in]      pTranspObj    Currently active DCM TP connection
 *  \param[in]      txStatus      Transmission result
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagOnFblResTxFinished(
  Dcm_NetTransportObjectPtrType pTranspObj,
  Dcm_NetTransmissionResultType txStatus
  );
#endif

/**********************************************************************************************************************
 *  Dcm_DiagCancelProcessing()
 *********************************************************************************************************************/
/*! \brief          Cancel any ongoing job.
 *  \details        This function cancels any ongoing service processing.
 *  \param[in]      pTranspObj    Currently active DCM TP connection
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagCancelProcessing(
  Dcm_NetTransportObjectPtrType pTranspObj
  );
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27UtiSetAttemptCntr()
 *********************************************************************************************************************/
/*! \brief          Notifies the application about changed attempt counter values.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in,out]  levelMask               Pointer to a security level mask.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc27UtiSetAttemptCntr(
  Dcm_OpStatusType opStatus,
  P2VAR(uint32, AUTOMATIC, DCM_VAR_NOINIT) levelMask
  );
# endif

/**********************************************************************************************************************
 *  Dcm_Svc27ReqLengthGetter()
 *********************************************************************************************************************/
/*! \brief          Service 0x27 sub-function length getter.
 *  \details        Always returns the sub-function specific length.
 *  \param[in]      sfRef                The sub-function zero-based index.
 *  \return         Expected sub-function specific length.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc27ReqLengthGetter(
  Dcm_DiagSubServiceRefOptType sfRef
  );

/**********************************************************************************************************************
 *  Dcm_Svc27SubFuncSequenceChecker()
 *********************************************************************************************************************/
/*! \brief          Service 0x27 sub-function sequence checker.
 *  \details        Checks whether the sub-function sequence is correct.
 *  \param[in]      pMsgContext          Pointer to current message context
 *  \param[in]      subSvcRef            The sub-function zero-based index.
 *  \param[out]     ErrorCode            The NRC
 *  \return         DCM_E_OK             Validation passed
 *  \return         DCM_E_NOT_OK         Send negative response
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc27SubFuncSequenceChecker(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_DiagSubServiceRefOptType subSvcRef,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_29_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_29_APCE_INTERNAL == STD_ON) || (DCM_SVC_29_04_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29CertificateStoreVerify()
 *********************************************************************************************************************/
/*! \brief          Service 0x29 sub-function 0x01, 0x02 and 0x04 storage and verfication step.
 *  \details        Stores and verifies client certificate from request.
 *  \param[in]      clientCertId            Certificate Id to be stored
 *  \param[in]      clientCertLength        Client certificate length
 *  \param[in]      pContext                Pointer to the context
 *  \param[in,out]  pMsgContext             The message context
 *  \param[out]     ErrorCode               The NRC
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29CertificateStoreVerify(
  uint16 clientCertId,
  uint16 clientCertLength,
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON) || (DCM_SVC_29_04_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29CertificateVerificationDoneHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x29 sub-function 0x01 and 0x02 stored certificate verification step.
 *  \details        Stored certificate verification.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in]      opStatus                The operations status
 *  \param[in,out]  pMsgContext             The message context
 *  \param[in,out]  pRepContext             The repeater context
 *  \param[out]     ErrorCode               The NRC
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29CertificateVerificationDoneHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29GenerateServerChallenge()
 *********************************************************************************************************************/
/*! \brief          Challenge generation wrapper function.
 *  \details        Triggers the Csm to generate the server challenge.
 *  \param[in]      pContext                Pointer to the context
 *  \param[in,out]  pMsgContext             The message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             The repeater context
 *  \return         DCM_E_NOT_OK            Send negative response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29GenerateServerChallenge(
  Dcm_ContextPtrType pContext,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29ChallengeGenerationDoneHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x29 certificate signing step.
 *  \details        Certificate signing after successful challenge generation.
 *  \param[in]      pContext                   Pointer to the context
 *  \param[in]      opStatus                   The operations status
 *  \param[in,out]  pMsgContext                The message context
 *  \param[out]     ErrorCode                  The NRC
 *  \param[in,out]  pRepContext                The repeater context
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_PENDING              Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29ChallengeGenerationDoneHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_29_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29GenerateSignature()
 *********************************************************************************************************************/
/*! \brief          Signature generation wrapper function.
 *  \details        Evaluates previous operation result and generates challenge.
 *  \param[in]      pContext                   Pointer to the context
 *  \param[in,out]  pMsgContext                The message context
 *  \param[out]     ErrorCode                  The NRC
 *  \param[in,out]  pRepContext                The repeater context
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_PENDING              Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29GenerateSignature(
  Dcm_ContextPtrType pContext,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_29_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29_02ChallengeSigningDoneHandler()
 *********************************************************************************************************************/
/*! \brief          Service 0x29 sub-function 0x02 final step.
 *  \details        Sends positive response if challege signing and certificate retrieval was successful.
 *  \param[in]      pContext                   Pointer to the context
 *  \param[in]      opStatus                   The operations status
 *  \param[in,out]  pMsgContext                The message context
 *  \param[out]     ErrorCode                  The NRC
 *  \param[in,out]  pRepContext                The repeater context
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   Send positive response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29_02ChallengeSigningDoneHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  );

# endif

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29_03RoleRead()
 *********************************************************************************************************************/
/*! \brief          Service 0x29 sub-function 0x03 role retrieval step.
 *  \details        Retrieve role from key manager.
 *  \param[in]      pContext                   Pointer to the context
 *  \param[in]      opStatus                   The operation status
 *  \param[in,out]  pMsgContext                The message context
 *  \param[out]     ErrorCode                  The NRC
 *  \param[in,out]  pRepContext                The repeater context
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_LOOP                 Repeat Repeater Proxy immediately
 *  \return         DCM_E_PENDING              Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29_03RoleRead(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29_03ServiceWL()
 *********************************************************************************************************************/
/*! \brief          Service 0x29 sub-function 0x03 SERVICE white list retrieval step.
 *  \details        Retrieve service white list from key manager.
 *  \param[in]      pContext                   Pointer to the context
 *  \param[in]      opStatus                   The operation status
 *  \param[in,out]  pMsgContext                The message context
 *  \param[out]     ErrorCode                  The NRC
 *  \param[in,out]  pRepContext                The repeater context
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_LOOP                 Repeat Repeater Proxy immediately
 *  \return         DCM_E_PENDING              Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29_03ServiceWL(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29_03DidWL()
 *********************************************************************************************************************/
/*! \brief          Service 0x29 sub-function 0x03 DID white list retrieval step.
 *  \details        Retrieve DID white list from key manager.
 *  \param[in]      pContext                   Pointer to the context
 *  \param[in]      opStatus                   The operation status
 *  \param[in,out]  pMsgContext                The message context
 *  \param[out]     ErrorCode                  The NRC
 *  \param[in,out]  pRepContext                The repeater context
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_LOOP                 Repeat Repeater Proxy immediately
 *  \return         DCM_E_PENDING              Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29_03DidWL(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29_03RidWL()
 *********************************************************************************************************************/
/*! \brief          Service 0x29 sub-function 0x03 RID white list retrieval step.
 *  \details        Retrieve RID white list from key manager.
 *  \param[in]      pContext                   Pointer to the context
 *  \param[in]      opStatus                   The operation status
 *  \param[in,out]  pMsgContext                The message context
 *  \param[out]     ErrorCode                  The NRC
 *  \param[in,out]  pRepContext                The repeater context
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_LOOP                 Repeat Repeater Proxy immediately
 *  \return         DCM_E_PENDING              Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29_03RidWL(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29_03MemWL()
 *********************************************************************************************************************/
/*! \brief          Service 0x29 sub-function 0x03 MEM white list retrieval step.
 *  \details        Retrieve MEM white list from key manager.
 *  \param[in]      pContext                   Pointer to the context
 *  \param[in]      opStatus                   The operation status
 *  \param[in,out]  pMsgContext                The message context
 *  \param[out]     ErrorCode                  The NRC
 *  \param[in,out]  pRepContext                The repeater context
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   Send positive response
 *  \return         DCM_E_LOOP                 Repeat Repeater Proxy immediately
 *  \return         DCM_E_PENDING              Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29_03MemWL(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  );
# endif

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29_03PersistAuthentication()
 *********************************************************************************************************************/
/*! \brief          Service 0x29 sub-function 0x03 Persistence.
 *  \details        Call NvMWriteBlock in order to persist authentication data.
 *  \param[in]      opStatus                   The operation status
 *  \param[in,out]  pMsgContext                The message context
 *  \param[out]     ErrorCode                  The NRC
 *  \param[in,out]  pRepContext                The repeater context
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_OK                   Send positive response
 *  \return         DCM_E_PENDING              Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29_03PersistAuthentication(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  );
# endif

/**********************************************************************************************************************
 *  Dcm_Svc29ReqLengthGetter()
 *********************************************************************************************************************/
/*! \brief          Service 0x29 sub-function length getter.
 *  \details        Always returns the sub-function specific length.
 *  \param[in]      sfRef                The sub-function zero-based index
 *  \return         Expected sub-function specific length
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc29ReqLengthGetter(
  Dcm_DiagSubServiceRefOptType sfRef
  );

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29VerifySignature()
 *********************************************************************************************************************/
/*! \brief          Service 0x29 sub-function 0x03 Signature verify.
 *  \details        Triggers the verify signature job of Csm.
 *  \param[in]      proofOfOwnershipLength     Proof of Ownership length
 *  \param[in]      pContext                   Pointer to the context
 *  \param[in,out]  pMsgContext                The message context
 *  \param[out]     ErrorCode                  The NRC
 *  \return         DCM_E_NOT_OK               Send negative response
 *  \return         DCM_E_PENDING              Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29VerifySignature(
  uint16 proofOfOwnershipLength,
  Dcm_ContextPtrType pContext,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
# endif

/**********************************************************************************************************************
 *  Dcm_Svc29SubFuncSequenceChecker()
 *********************************************************************************************************************/
/*! \brief          Service 0x29 sub-function sequence checker.
 *  \details        Checks whether the sub-function sequence is correct.
 *  \param[in,out]  pMsgContext                 The message context
 *  \param[in]      subSvcRef                   The sub-function zero-based index
 *  \param[out]     ErrorCode                   The NRC
 *  \return         DCM_E_NOT_OK                Wrong sequence
 *  \return         DCM_E_OK                    Successful
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29SubFuncSequenceChecker(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_DiagSubServiceRefOptType subSvcRef,
  Dcm_NegativeResponseCodePtrType ErrorCode
  );
#endif /* (DCM_SVC_29_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/* --- public members ---------------------------------------------------------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdStopAll()
 *********************************************************************************************************************/
/*! \brief          Stops all scheduled DIDs.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdStopAll(
  void
  );

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdCancelReadByHandle()
 *********************************************************************************************************************/
/*! \brief          Stops a single scheduled item.
 *  \details        -
 *  \param[in]      schdHandle    The handle
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdCancelReadByHandle(
  Dcm_Svc2ASchdItemHandleOptType schdHandle
  );

# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdCancelReadByDid()
 *********************************************************************************************************************/
/*! \brief          Cancels the reading of a single scheduled item.
 *  \details        -
 *  \param[in]      did    The did
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdCancelReadByDid(
  uint16 did
  );
# endif

# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2AGetConnectionOfDID()
 *********************************************************************************************************************/
/*! \brief          Returns the connection ID of scheduled DID.
 *  \details        -
 *  \param[in]      did    The DID
 *  \return         Valid connection ID (if DID is scheduled)
 *  \return         DCM_NET_INVALID_CONNHDL (if DID is not scheduled)
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NetConnRefMemType, DCM_CODE) Dcm_Svc2AGetConnectionOfDID(
  uint16 did
  );
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdStopItemByHandle()
 *********************************************************************************************************************/
/*! \brief          Stops a single scheduled item.
 *  \details        -
 *  \param[in]      schdHandle    The handle
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdStopItemByHandle(
  Dcm_Svc2ASchdItemHandleOptType schdHandle
  );

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdStopItemByDid()
 *********************************************************************************************************************/
/*! \brief          Cancels the reading of a single scheduled item.
 *  \details        -
 *  \param[in]      did    The did
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdStopItemByDid(
  uint16 did
  );

/* --- private members --------------------------------------------------------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdGetItemByDid()
 *********************************************************************************************************************/
/*! \brief          Look up for a scheduled DID.
 *  \details        -
 *  \param[in]      did           The did
 *  \param[in]      schdHandle    Handle of the found entry
 *  \return         TRUE          Entry was found
 *  \return         FALSE         Entry was not found - schdHandle output parameter is invalid
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(boolean, DCM_CODE) Dcm_Svc2ASchdGetItemByDid(
  uint16 did,
  P2VAR(Dcm_Svc2ASchdItemHandleOptType, AUTOMATIC, AUTOMATIC) schdHandle
  );

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdFinishEntryProcessing()
 *********************************************************************************************************************/
/*! \brief          Finalizes scheduler entry processing (with or without response).
 *  \details        Resets all global states after a scheduler entry was processed. Initiates response transmission
 *                  or releases UUDT message.
 *  \param[in]      doSendResponse    Specifies whether a response shall be sent or not
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdFinishEntryProcessing(
  boolean doSendResponse
  );
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2ADidLookUp()
 *********************************************************************************************************************/
/*! \brief          A generic DID look-up for SID 0x2A.
 *  \details        Performs a lookup for a specific DID on any request.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \param[out]     ErrorCode               The NRC
 *  \param[in,out]  pRepContext             Current repeater proxy context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Go to next step
 *  \return         DCM_E_OK                Found a DID, make next step
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADidLookUp(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ARepeaterProxyContextPtrType pRepContext
  );
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_2C_03_SUPPORT_ENABLED == STD_ON)                                                                                                       /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrClear()
 *********************************************************************************************************************/
/*! \brief          Clear all DDID definitions.
 *  \details        Clears all previously defined DDIDs.
 *  \param[in]      dynDidHandle    DynDID reference to be cleared
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2CDefMgrClear(
  Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle
  );
# endif
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CReqLengthGetter()
 *********************************************************************************************************************/
/*! \brief          Service 0x2C sub-function length getter.
 *  \details        Always returns length of 0 byte to show that the requests have dynamic length and the concrete
 *                  length will be checked later.
 *  \param[in]      sfRef                The sub-function zero-based index.
 *  \return         Expected sub-function specific length.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc2CReqLengthGetter(
  Dcm_DiagSubServiceRefOptType sfRef
  );

/**********************************************************************************************************************
 *  Dcm_Svc2CParseAndCheckDynDid()
 *********************************************************************************************************************/
/*! \brief          Parses and validates the DynDID to be defined.
 *  \details        -
 *  \param[in]      pContext       Pointer to the context
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \param[out]     ErrorCode      The NRC
 *  \param[out]     pRepContext    Current repeater proxy context
 *  \return         DCM_E_OK       Send response
 *  \return         DCM_E_NOT_OK   Send neagative response
 *  \return         DCM_E_PENDING  Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CParseAndCheckDynDid(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  );

/**********************************************************************************************************************
 *  Dcm_Svc2CCheckAndSetNumOfItems()
 *********************************************************************************************************************/
/*! \brief          Check DynDID has enough space to keep all requested definitions.
 *  \details        If the check succeeds also stores the number of requested items for further processing.
 *  \param[in]      numRequestedItems  Number of requested Items
 *  \param[out]     ErrorCode          The NRC
 *  \param[in,out]  pRepContext        Current repeater proxy context
 *  \return         DCM_E_OK        Check succeeded
 *  \return         DCM_E_NOT_OK    Check failed (NRC is stored in ErrorCode)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CCheckAndSetNumOfItems(
  Dcm_MsgLenType numRequestedItems,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  );
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc86ReqLengthGetter()
 *********************************************************************************************************************/
/*! \brief          Service 0x86 sub-function length getter.
 *  \details        Always returns the sub-function specific length.
 *  \param[in]      sfRef                The sub-function zero-based index.
 *  \return         Expected sub-function specific length.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc86ReqLengthGetter(
  Dcm_DiagSubServiceRefOptType sfRef
  );
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
#include "Dcm_MemMap.h"                                                                                                                              /* PRQA S 5087 */ /* MD_MSR_MemMap */

/**********************************************************************************************************************
 *  LOCAL DATA DECLARATIONS
 *********************************************************************************************************************/
#define DCM_START_SEC_VAR_NO_INIT_UNSPECIFIED
#include "Dcm_MemMap.h"                                                                                                                              /* PRQA S 5087 */ /* MD_MSR_MemMap */
#if (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON)
/*! Authentication manager data that can be read from and written to NvM (if NvM is configured) */
# if (DCM_STATE_AUTHENTICATION_ENABLED == STD_ON)
VAR(Dcm_AuthMgrNvMDataType, DCM_VAR_NOINIT) Dcm_AuthMgrNvMData[DCM_CFGAUTHMGRNETCONNINFO_SIZE];
# endif
#endif /* (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON) */
/*! Sub-components per-thread memory */
DCM_LOCAL VAR(Dcm_ContextType, DCM_VAR_NOINIT) Dcm_ThreadContext[DCM_NUM_THREADS];                                                                   /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
/*! Sub-components shared memory */
DCM_LOCAL VAR(Dcm_SingletonContextType, DCM_VAR_NOINIT) Dcm_SingletonContext;
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/*! Service 0x2C Data that can be read from and written to NvM (if NvM is configured) */
VAR(Dcm_Svc2CDynDidNvMDataType, DCM_VAR_NOINIT) Dcm_Svc2CNvMData;
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_VAR_NO_INIT_UNSPECIFIED
#include "Dcm_MemMap.h"                                                                                                                              /* PRQA S 5087 */ /* MD_MSR_MemMap */

#define DCM_START_SEC_CONST_8
#include "Dcm_MemMap.h"                                                                                                                              /* PRQA S 5087 */ /* MD_MSR_MemMap */
/*! A map to get the negative response code corresponding to a specific diagnostic entity (i.e. service, sub-service or parameter identifier */
DCM_LOCAL CONST(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_StateSessionNrcs[DCM_DIAG_NUM_CHK_LVLS]=                                                 /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_E_SERVICENOTSUPPORTEDINACTIVESESSION /* on SID level */
 ,DCM_E_REQUESTOUTOFRANGE /* on Parameter (DID, RID, etc.) level */
 ,DCM_E_SUBFUNCTIONNOTSUPPORTEDINACTIVESESSION /* on SubFunction level */
};
/*! Diagnostic service verification level to NRC map */
DCM_LOCAL CONST(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_DiagObjNotFoundNrcs[DCM_DIAG_NUM_CHK_LVLS]=                                              /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_E_SERVICENOTSUPPORTED     /*!< on SID level */
 ,DCM_E_REQUESTOUTOFRANGE       /*!< on Parameter (DID, RID, etc.) level */
 ,DCM_E_SUBFUNCTIONNOTSUPPORTED /*!< on SubFunction level */
};
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
DCM_LOCAL CONST(Dcm_DidMgrOpMemType, DCM_CONST) Dcm_Svc2FCtrlOp2DidOpTypeMap[4]=                                                                     /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU
 ,DCM_DIDMGR_OPTYPE_IO_RST2DEF
 ,DCM_DIDMGR_OPTYPE_IO_FRZCURSTATE
 ,DCM_DIDMGR_OPTYPE_IO_SHRTTRMADJ
};
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CONST_8
#include "Dcm_MemMap.h"                                                                                                                              /* PRQA S 5087 */ /* MD_MSR_MemMap */

#define DCM_START_SEC_CONST_UNSPECIFIED
#include "Dcm_MemMap.h"                                                                                                                              /* PRQA S 5087 */ /* MD_MSR_MemMap */
DCM_LOCAL CONST(Dcm_TmrTimerInfoType, DCM_CONST) Dcm_TmrTimerInfo[DCM_TMR_NUM_TIMERS] =                                                              /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  {Dcm_OnTimeoutP2,                       DCM_TMR_ATR_THREAD_MULTI,  DCM_TMR_CONTEXT_ID_P2 }
 ,{Dcm_OnTimeoutS3,                       DCM_TMR_ATR_THREAD_SINGLE, DCM_TMR_CONTEXT_ID_S3 }
#if (DCM_TMR_NUM_FBLRES > 0u)
 ,{Dcm_OnTimeoutFblRes,                   DCM_TMR_ATR_THREAD_SINGLE, DCM_TMR_CONTEXT_ID_FBLRES }
#endif
#if (DCM_TMR_NUM_SECURITY > 0u)
 ,{Dcm_OnTimeoutSecurityAccess,           DCM_TMR_ATR_THREAD_SINGLE, DCM_TMR_CONTEXT_ID_SECURITY }
#endif
#if (DCM_TMR_NUM_PERIODIC_TX > 0u)
 ,{Dcm_OnTimeoutPeriodicTx,               DCM_TMR_ATR_THREAD_SINGLE, DCM_TMR_CONTEXT_ID_PERIODIC_TX }
#endif
#if (DCM_TMR_NUM_SVC2A_SCHEDULER > 0u)
 ,{Dcm_OnTimeoutSvc2AScheduler,           DCM_TMR_ATR_THREAD_SINGLE, DCM_TMR_CONTEXT_ID_SVC2A_SCHEDULER }
#endif
#if (DCM_TMR_NUM_SVC86_SCHEDULER > 0u)
 ,{Dcm_ExtOnTimeoutSvc86Scheduler, DCM_TMR_ATR_THREAD_SINGLE, DCM_TMR_CONTEXT_ID_SVC86_SCHEDULER }
#endif
#if (DCM_TMR_NUM_KEEP_ALIVE > 0u)
 ,{Dcm_OnTimeoutKeepAlive,                DCM_TMR_ATR_THREAD_SINGLE, DCM_TMR_CONTEXT_ID_KEEP_ALIVE }
#endif
#if (DCM_TMR_NUM_AUTHENTICATION > 0u)
 ,{Dcm_OnTimeoutAuthentication,           DCM_TMR_ATR_THREAD_SINGLE, DCM_TMR_CONTEXT_ID_AUTHENTICATION }
#endif
};
#define DCM_STOP_SEC_CONST_UNSPECIFIED
#include "Dcm_MemMap.h"                                                                                                                              /* PRQA S 5087 */ /* MD_MSR_MemMap */

/**********************************************************************************************************************
 *  LOCAL FUNCTIONS
 *********************************************************************************************************************/
#define DCM_START_SEC_CODE
#include "Dcm_MemMap.h"                                                                                                                              /* PRQA S 5087 */ /* MD_MSR_MemMap */
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferInitByThread()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_PagedBufferInitByThread(
  Dcm_ThreadIdOptType threadId
  )
{
  Dcm_ContextPtrType pContext = Dcm_GetThreadContext(threadId);

  pContext->PagedBuffer.State = DCM_PAGEDBUFFER_STATE_INACTIVE;                                                                                      /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
}
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_PagedBufferInit(
  void
  )
{
  Dcm_ThreadIdOptType lThreadIter;
  for(lThreadIter = 0; lThreadIter < DCM_NUM_THREADS; ++lThreadIter)
  {
    Dcm_PagedBufferInitByThread(lThreadIter);
  }
}
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferDefragmentPage()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_PagedBufferDefragmentPage(
  Dcm_ContextPtrType pContext                                                                                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_PbCfgNetBufferInfoPtrType lBufferInfo;
  Dcm_CfgNetBufferSizeOptType   lPageSize;

  lBufferInfo = Dcm_NetGetBufferInfo(pContext->PagedBuffer.BufferHdl);
  lPageSize = (Dcm_CfgNetBufferSizeOptType)(pContext->PagedBuffer.WriteIndex)
            - (Dcm_CfgNetBufferSizeOptType)(pContext->PagedBuffer.ReadIndex);

  Dcm_UtiMemCopySafe(&(lBufferInfo->BufferPtr[pContext->PagedBuffer.ReadIndex])
                    ,lBufferInfo->BufferPtr
                    ,0u
                    ,lBufferInfo->Size
                    ,(Dcm_MsgLenType)lPageSize);                                                                                                     /* SBSW_DCM_POINTER_WRITE_BUFFERINFO */

  /* Enter critical section (Reason: Protect against hi-priority task /ISR CopyTxData) */
  Dcm_UtiEnterCriticalSection();
  /* Update Read- and Write-Index */
  pContext->PagedBuffer.ReadIndex  = 0u;                                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
  pContext->PagedBuffer.WriteIndex = (Dcm_CfgNetBufferSizeMemType)lPageSize;                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
  /* Leave critical section */
  Dcm_UtiLeaveCriticalSection();
}
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferUpdatePage()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_PagedBufferUpdatePage(
  Dcm_ContextPtrType pContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType                lStdResult;
  Dcm_DiagDataContextType       lDataContext;
  Dcm_PbCfgNetBufferInfoPtrType lBufferInfo;
  uint8                         lUpdaterDataProvisionState;

  lBufferInfo = Dcm_NetGetBufferInfo(pContext->PagedBuffer.BufferHdl);

  Dcm_DebugAssert((pContext->PagedBuffer.State != DCM_PAGEDBUFFER_STATE_INACTIVE), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                           /* COV_DCM_RTM_DEV_DEBUG XF */

  /* If defragmentation needed: */
  if ((pContext->PagedBuffer.UpdaterDataProvisionState == DCM_PAGEDBUFFER_WAIT_FOR_DATA)
    &&(pContext->PagedBuffer.ReadIndex != 0u) )
  {
    Dcm_PagedBufferDefragmentPage(pContext);                                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* Derive new data context for the remaining data to be read */
  Dcm_UtiInitDataContext(&lDataContext, lBufferInfo->BufferPtr, lBufferInfo->Size);                                                                  /* SBSW_DCM_POINTER_INIT_DATA_CONTEXT */
  Dcm_UtiCommitData(&lDataContext, pContext->PagedBuffer.WriteIndex);                                                                                /* SBSW_DCM_POINTER_WRITE_DATA_CONTEXT */

  /* Stronger limitation of the available buffer size - cut to the response length */
  if(lDataContext.AvailLen > pContext->PagedBuffer.RemainingLen)
  {
    Dcm_UtiDataContextSetAvailLen(&lDataContext, pContext->PagedBuffer.RemainingLen);                                                                /* SBSW_DCM_POINTER_WRITE_DATA_CONTEXT */
  }

  /* Delegate to the page writer */
  lStdResult = Dcm_PagedBufferExecute(pContext, &lDataContext, ErrorCode);                                                                           /* SBSW_DCM_COMB_PTR_FORWARD */

  switch(lStdResult)
  {
    case DCM_E_OK:
    case DCM_E_NOT_OK:
      pContext->PagedBuffer.UpdateFinished = TRUE;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
      lUpdaterDataProvisionState = DCM_PAGEDBUFFER_ALL_DATA_PROVIDED;
      break;
    case DCM_E_DATA_READY_PADDING:
      pContext->PagedBuffer.OpStatus = DCM_INITIAL;                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      /* Delegate to the padding writer */
      pContext->PagedBuffer.UpdateFuncRef = DCM_PAGEDBUFFER_PADDING_FUNC_REF;                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
      /* Application is done, now call the padding-bytes provider */
      pContext->PagedBuffer.UpdateFinished = TRUE;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
      lUpdaterDataProvisionState = DCM_PAGEDBUFFER_PAGE_DATA_PROVIDED;
      break;
    case DCM_E_PENDING:
      pContext->PagedBuffer.OpStatus = DCM_PENDING;                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      /* Data could also be written although DCM_E_PENDING was returned */
      lUpdaterDataProvisionState = DCM_PAGEDBUFFER_PAGE_DATA_PROVIDED;
      break;
    case DCM_E_PENDING_LIMITER:
      /* Keep the last opStatus on "pending" forced by Dcm_PagedBufferExecute code */
      /* Data could also be written although DCM_E_PENDING was returned */
      lUpdaterDataProvisionState = DCM_PAGEDBUFFER_PAGE_DATA_PROVIDED;
      lStdResult = DCM_E_PENDING;
      break;
    case DCM_E_BUFFERTOOLOW:
      pContext->PagedBuffer.OpStatus = DCM_PENDING;                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      lUpdaterDataProvisionState = DCM_PAGEDBUFFER_PAGE_DATA_PROVIDED;
      break;
    default:/* Unexpected return value */                                                                                                            /* COV_DCM_RTM_UNREACHABLE X */
      lStdResult = DCM_E_NOT_OK; /* Assure only valid values from here on */
      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      pContext->PagedBuffer.UpdateFinished = TRUE;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
      lUpdaterDataProvisionState = DCM_PAGEDBUFFER_ALL_DATA_PROVIDED;
      break;
  }

  if(lStdResult == DCM_E_NOT_OK)
  {
    if(pContext->PagedBuffer.State == DCM_PAGEDBUFFER_STATE_ACTIVATED)
    {
      /* Reset paged-buffer usage and delegate to the linear buffer processor */
      pContext->PagedBuffer.State = DCM_PAGEDBUFFER_STATE_CANCELED;                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
    {
      /* Wait for under-run transmission interruption (simulate successful update with zero data size) */
      lStdResult = DCM_E_OK;
    }
    pContext->PagedBuffer.UpdaterDataProvisionState = lUpdaterDataProvisionState;                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
  {
    /* Enter critical section (Reason: Protect against hi-priority task /ISR CopyTxData) */
    Dcm_UtiEnterCriticalSection();
    /* Update statistic */
    pContext->PagedBuffer.RemainingLen -= (Dcm_MsgLenType)(lDataContext.Usage - pContext->PagedBuffer.WriteIndex);                                   /* SBSW_DCM_PARAM_PTR_WRITE */
    pContext->PagedBuffer.WriteIndex = (Dcm_CfgNetBufferSizeMemType)lDataContext.Usage;                                                              /* SBSW_DCM_PARAM_PTR_WRITE */

    /* Unlock CopyTx Data if more data is expected to be provided by a paged-buffer updater */
    pContext->PagedBuffer.UpdaterDataProvisionState = lUpdaterDataProvisionState;                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */

    /* Leave critical section */
    Dcm_UtiLeaveCriticalSection();

    /* If transmission not yet started and some data is already available for transmission: */
    if ((pContext->PagedBuffer.State == DCM_PAGEDBUFFER_STATE_ACTIVATED)
      && (lStdResult != DCM_E_PENDING))
    {
      /* Activate transmission */
      pContext->PagedBuffer.State = DCM_PAGEDBUFFER_STATE_ONTX;                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      pContext->Diag.State |= DCM_DIAG_STATE_ON_TX; /* update diagnostic state (PROCESS && ON_TX) */                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
      Dcm_TskSetEventByThread(DCM_TSK_ID_DIAG_TX, DCM_TSK_EV_DIAG_TX_SEND_PAGED, pContext->ThreadId);
    }
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6050 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL */
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferCopyData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_PagedBufferCopyData(
  Dcm_NetTransportObjectPtrType pTranspObj,                                                                                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info,                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) availableDataPtr                                                                                    /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  BufReq_ReturnType  lResult = BUFREQ_OK;
  Dcm_ContextPtrType pContext;

  DCM_IGNORE_UNREF_PARAM(pTranspObj);                                                                                                                /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  pContext = Dcm_GetThreadContext(Dcm_NetGetThreadIdOfTranspObj(pTranspObj));                                                                        /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */

  Dcm_DebugAssert((pContext->PagedBuffer.State != DCM_PAGEDBUFFER_STATE_INACTIVE), DCM_SID_COPYTXDATA
                  ,DCM_E_ILLEGAL_STATE);                                                                                                             /* COV_DCM_RTM_DEV_DEBUG XF */

  *availableDataPtr = (PduLengthType)(pContext->PagedBuffer.WriteIndex)
                                      - (PduLengthType)(pContext->PagedBuffer.ReadIndex); /* Calculate and return page size */                       /* SBSW_DCM_PARAM_PTR_WRITE */

  if( (*availableDataPtr == 0u) /* no data at all */
    ||(*availableDataPtr < info->SduLength) ) /* real under-run */
  {
    if(info->SduLength != 0u)
    {
      lResult = BUFREQ_E_BUSY;
    }/* else - just buffer size check */

    if ((pContext->PagedBuffer.UpdaterDataProvisionState == DCM_PAGEDBUFFER_PAGE_DATA_PROVIDED)
      &&(pContext->PagedBuffer.RemainingLen != 0u) )
    {
      pContext->PagedBuffer.UpdaterDataProvisionState = DCM_PAGEDBUFFER_WAIT_FOR_DATA;                                                               /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
      Dcm_TskSetEventByThread(DCM_TSK_ID_PGDBUF, DCM_TSK_EV_PGDBUF_UPDATE_PAGE, Dcm_NetGetThreadIdOfTranspObj(pTranspObj));/* re-activate page updater */ /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */
    }/* else - still waiting for the data or all data provided */
  }
  else /* (lPageSize != 0u) && (lPageSize >= info->SduLength) => <check buffer availability> */
  {
    if ((pContext->PagedBuffer.UpdaterDataProvisionState == DCM_PAGEDBUFFER_WAIT_FOR_DATA) /* still waiting for data OR data is currently being written */
      &&(pContext->PagedBuffer.ReadIndex != 0u) /* with needed defragmentation */
      &&(info->SduLength != 0u) )/* no buffer availability check request */
    {
      lResult = BUFREQ_E_BUSY;/* avoid coping data during defragmentation of the paged-buffer (i.e. in case of adaptive CopyTxData call with reducing SduLength each time, or when SduLength == 0, and immediately called again with SduLength != 0 */
    }
    else
    {
      Dcm_PbCfgNetBufferInfoPtrType lBufferInfo = Dcm_NetGetBufferInfo(pContext->PagedBuffer.BufferHdl);

      *availableDataPtr -= info->SduLength; /* Update remained data part */                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      /* Take the linear case always */
      Dcm_UtiMemCopySafe(&(lBufferInfo->BufferPtr[pContext->PagedBuffer.ReadIndex])
                        ,info->SduDataPtr
                        ,0u
                        ,info->SduLength
                        ,info->SduLength);                                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
      pContext->PagedBuffer.ReadIndex += (Dcm_CfgNetBufferSizeMemType)(info->SduLength);                                                             /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
    }
  }

  return lResult;
}
#endif
#define DCM_STOP_SEC_CODE
#include "Dcm_MemMap.h"                                                                                                                              /* PRQA S 5087 */ /* MD_MSR_MemMap */

#define DCM_START_SEC_CODE
#include "Dcm_MemMap.h"                                                                                                                              /* PRQA S 5087 */ /* MD_MSR_MemMap */
/**********************************************************************************************************************
 *  Dcm_DiagAcceptNewRequest()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_DiagAcceptNewRequest(
  Dcm_NetTransportObjectPtrType pTranspObj                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  boolean lResult = TRUE;
  /* If SID in range: [0x40, 0x7F]U[0xC0, 0xFF] */
#if (DCM_DIAG_IGNORE_RESPONSE_SID_ENABLED == STD_ON)
  if((pTranspObj->RxData[0] & 0x40u) != 0u)
  {
    pTranspObj->Flags |= DCM_NET_TOBJ_FLAG_IGNORE;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = FALSE;
  }
  else
#endif
  /* If valid functional "0x3E 0x80" */
  if( (pTranspObj->RxData[0] == 0x3Eu)
    &&(pTranspObj->RxData[1] == 0x80u)
    &&(pTranspObj->RxLength  == 2u)
    &&(Dcm_PbCfgNetRxPduInfo[pTranspObj->RxPduId].IsFuncReq == TRUE) )                                                                               /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
  {
#if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
    /* In case of generic connections, a connection can be used by a pool of testers. Tester address has to be checked as well. */
    if( ((DCM_STATE_VALUE_SESSION_INIT & Dcm_StateGetPendingSession()) == 0u) /* A non-default session is/will be active */
      &&( (Dcm_NetGetSessionConnection() != pTranspObj->ConnHdl)
        ||(Dcm_NetGetSessionClientSrcAddr() != pTranspObj->ClientSrcAddr)) ) /* Request from different tester */
    {
      pTranspObj->Flags |= DCM_NET_TOBJ_FLAG_IGNORE;                                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
    }
#endif
    lResult = FALSE;
  }
  else
  {
    /* nothing to do */
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_DiagOnTxFinished()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagOnTxFinished(
  Dcm_NetTransportObjectPtrType pTranspObj,                                                                                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NetTransmissionResultType txStatus
  )
{
  switch(pTranspObj->ResType)
  {
  case DCM_NET_TOBJ_RESTYPE_LINEAR:
  case DCM_NET_TOBJ_RESTYPE_PAGED:
    /* Do finalize main response */
    Dcm_DiagTxFinalization(pTranspObj, txStatus);                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_NET_TOBJ_RESTYPE_RCRRP:
    Dcm_DiagRcrRpTxFinished(pTranspObj, txStatus);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
  case DCM_NET_TOBJ_RESTYPE_UNSOLICITED:
    Dcm_DiagOnFblResTxFinished(pTranspObj, txStatus);                                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
#endif
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    /* Unknown response type */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);
    break;
  }
}
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
# if (DCM_DIDMGR_PERIODICDID_CLR_ON_STATE_CHG_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2AOnStateChanged()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2AOnStateChanged(
  void
  )
{
  if(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries != 0u)
  {
    Dcm_NegativeResponseCodeType   lNrc;
    Dcm_Svc2ASchdItemHandleOptType lSchdIter;
    Std_ReturnType lStdReturn;

    for(lSchdIter = 0; lSchdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++lSchdIter)
    {
      Dcm_Svc2ASchdEntryPtrType pSchdEntry = Dcm_Svc2ASchdGetEntry(lSchdIter);                                                                       /* PRQA S 3679 */ /* MD_Dcm_Design_3679 */
      if(pSchdEntry->Rate < DCM_SVC2A_RATE_TYPE_STOPPED)/* is still an active entry? */
      {
        lStdReturn = Dcm_DidMgrDynDidStateCheck(DCM_NET_INVALID_CONNHDL, &(pSchdEntry->DidContext), &lNrc);                                          /* SBSW_DCM_COMB_PTR_FORWARD */
        if (lStdReturn == DCM_E_NOT_OK)
        {
          Dcm_Svc2ASchdStopItemByHandle(lSchdIter);
        }
      }
    }
  }
}
# endif
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CGetSrcItem()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_Svc2CDynDidSrcItemPtrType, DCM_CODE) Dcm_Svc2CGetSrcItem(
  Dcm_CfgDidMgrDynDidSrcItemIdxOptType srcItemIndex
  )
{
  Dcm_Svc2CDynDidSrcItemPtrType pSourceItem;

  if (Dcm_DebugDetectRuntimeError(srcItemIndex >= DCM_NUM_DYNDID_ITEMS))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    pSourceItem = &Dcm_Svc2CNvMData.SrcItems[0];
  }
  else
  {
    pSourceItem = &Dcm_Svc2CNvMData.SrcItems[srcItemIndex];
  }

  return pSourceItem;
}

/**********************************************************************************************************************
 *  Dcm_Svc2CGetItem()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_Svc2CDynDidItemPtrType, DCM_CODE) Dcm_Svc2CGetItem(
  Dcm_CfgDidMgrDynDidHandleOptType itemIndex
  )
{
  Dcm_Svc2CDynDidItemPtrType pItem;

  if (Dcm_DebugDetectRuntimeError(itemIndex >= DCM_NUM_DYNDIDS))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    pItem = &Dcm_Svc2CNvMData.Items[0];
  }
  else
  {
    pItem = &Dcm_Svc2CNvMData.Items[itemIndex];
  }

  return pItem;
}

/**********************************************************************************************************************
 *  Dcm_Svc2CGetDDDidProcessContext()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_Svc2CDynDidProcessContextPtrType, DCM_CODE) Dcm_Svc2CGetDDDidProcessContext(
  uint8 processContextIndex
  )
{
  Dcm_Svc2CDynDidProcessContextPtrType pProcessContext;

  if (Dcm_DebugDetectRuntimeError(processContextIndex >= DCM_SVC_2C_NUM_PROCESS_CONTEXTS))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    pProcessContext = &Dcm_SingletonContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[0];
  }
  else
  {
    pProcessContext = &Dcm_SingletonContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[processContextIndex];
  }

  return pProcessContext;
}

# if (DCM_DIDMGR_DYNDID_CLR_ON_STATE_CHG_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2COnStateChanged()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2COnStateChanged(
  void
  )
{
  /* clear all DynDID definitions not supported any more */
  Dcm_NegativeResponseCodeType     lNrc;
  Std_ReturnType                   lStdResult;
  Dcm_CfgDidMgrDynDidHandleOptType lDynDidIter;
#  if (DCM_SVC_2C_NVRAM_SUPPORT_ENABLED == STD_ON)
  boolean                          lAnyCleared = FALSE;
#  endif

  for(lDynDidIter = 0; lDynDidIter < DCM_NUM_DYNDIDS; ++lDynDidIter)
  {
    if(Dcm_Svc2CIsDynDidDefined(lDynDidIter))
    {
      lStdResult = Dcm_DidMgrStaticDidNoAuthStateCheck(Dcm_DidMgrGetDynDidReadExecPrecond(lDynDidIter), &lNrc);                                      /* SBSW_DCM_POINTER_FORWARD_STACK */

#  if (DCM_DIDMGR_DYNDID_SRCITEM_CHECK_STATE_ENABLED == STD_ON)
      if(lStdResult == DCM_E_OK) /* all DDDID conditions OK - check inside */
      {
        lStdResult = Dcm_Svc2CStateCheckSrcItems(DCM_NET_INVALID_CONNHDL, lDynDidIter, &lNrc);                                                       /* SBSW_DCM_POINTER_FORWARD_STACK */
      }
#  endif

      if(lStdResult == DCM_E_NOT_OK) /* any condition not fulfilled? */
      {
        Dcm_Svc2CDefMgrClear((Dcm_CfgDidMgrDynDidHandleMemType)lDynDidIter);
#  if (DCM_SVC_2C_NVRAM_SUPPORT_ENABLED == STD_ON)
        if(lAnyCleared == FALSE)
        {
          lAnyCleared = TRUE;
          Dcm_UtiNvMSetRamBlockStatus((uint16)DCM_SVC_2C_NVRAM_BLOCKID);
        }
#  endif
      }
    } /* else - DDDID not defined yet */
  }
}
# endif
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;

  if(opStatus == DCM_INITIAL)
  {
    /* Min Length already checked in DiagDispatcher and expected to be 3 !!! */
    Dcm_UtiConsumeReqDataAsU16(pMsgContext, &(pRepContext->DidInfoContext.Did));                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  lStdResult = Dcm_DidMgrGetDidInfo(opStatus
                                   ,&(pRepContext->DidInfoContext)
                                   ,&(pRepContext->DidOpTypeContext)
                                   ,DCM_DIDMGR_OP_IO);                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */

  switch(lStdResult)
  {
  case DCM_E_OK:
    {
      uint8 lControlOp;
      Dcm_UtiConsumeReqDataAsU8(pMsgContext, &lControlOp);                                                                                           /* SBSW_DCM_COMB_PTR_FORWARD */

      /* convert from UDS to internal operation representation */
      if(lControlOp < 4u)
      {
        pRepContext->OpType = Dcm_Svc2FCtrlOp2DidOpTypeMap[lControlOp]; /* use interpreted value */                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      }
      else
      {
        pRepContext->OpType = (Dcm_DidMgrOpMemType)0x00u; /* no supported operation */                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
      }

      /* Check for supported sub-operation */
      if(Dcm_DidMgrIsOpTypeSupported(Dcm_CfgDidMgrGetDidOpInfo(&pRepContext->DidInfoContext), pRepContext->OpType))                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
      {
        /* Commit response header */
        Dcm_UtiProvideResData(pMsgContext, 3);                                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */

        lStdResult = Dcm_Svc2FIoDidOperationProcessor(pContext, pMsgContext, ErrorCode, pRepContext);                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
      else
      {
        *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
    }
    break;
  case DCM_E_NOT_OK:
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  default: /* DCM_E_PENDING -> try again */
    break;
  }

  return lStdResult;
}

# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FGetActiveIoDids()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_UtiBitSetBasePtrType, DCM_CODE) Dcm_Svc2FGetActiveIoDids(
  Dcm_CfgDidMgrIoDidHandleOptType ioDidIndex
  )
{
  Dcm_UtiBitSetBasePtrType pActiveIoDids;

  if (Dcm_DebugDetectRuntimeError(ioDidIndex >= Dcm_UtiGenericBitSetCalcSize(DCM_NUM_IODIDS)))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    pActiveIoDids = &Dcm_SingletonContext.Diag.Services.Svc2F.ActiveIoDids[0];
  }
  else
  {
    pActiveIoDids = &Dcm_SingletonContext.Diag.Services.Svc2F.ActiveIoDids[ioDidIndex];
  }

  return pActiveIoDids;
}
# endif

# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FOnStateChanged()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FOnStateChanged(
  void
  )
{
  if(Dcm_SingletonContext.Diag.Services.Svc2F.HasAnyActiveIoDid == TRUE)
  {
    Dcm_CfgDidMgrDidOpClassHandleOptType opInfoRefPage = 0;
    Dcm_CfgDidMgrIoDidHandleOptType ioDidIter;

    Dcm_SingletonContext.Diag.Services.Svc2F.HasAnyActiveIoDid = FALSE; /* Assume all IODIDs will be deactivated */

    for(ioDidIter = 0; ioDidIter < Dcm_UtiGenericBitSetCalcSize(DCM_NUM_IODIDS); ioDidIter++)
    {
      Dcm_UtiBitSetBasePtrType pActiveIoDids = Dcm_Svc2FGetActiveIoDids(ioDidIter);
      Dcm_UtiBitSetBaseType lActiveIoDids = *pActiveIoDids;
      Dcm_UtiBitSetBaseType lActiveIoDidScanner = 0x01u;
      Dcm_CfgDidMgrDidOpClassHandleOptType opInfoRef = opInfoRefPage;

      DCM_UTI_LOOP_BIT_SCAN(lActiveIoDids)
      {
        if(Dcm_UtiBitOpTest(Dcm_UtiBitSetBaseType, *pActiveIoDids, lActiveIoDidScanner))
        {
          Dcm_NegativeResponseCodeType lNrc;
          Std_ReturnType lStdReturn;

          /*
           * No Authentication check needed as service 2F is only allowed in the extended session,
           * and therefore no other tester has access to the DCM during that time.
           */
          lStdReturn = Dcm_DidMgrStaticDidNoAuthStateCheck(Dcm_DidMgrGetCtrlOpExecCondRef(opInfoRef), &lNrc);                                        /* SBSW_DCM_POINTER_FORWARD_STACK */
          if (lStdReturn == DCM_E_NOT_OK)
          {
            Dcm_UtiBitOpClr(Dcm_UtiBitSetBaseType, *pActiveIoDids, lActiveIoDidScanner);                                                             /* SBSW_DCM_POINTER_WRITE_2FACTIVEIODIDS */
            Dcm_DidMgrIoControlRtrnCtrl2Ecu(Dcm_DidMgrGetCtrlOpInfoRef(opInfoRef));
          }
        }

        lActiveIoDidScanner<<=1;
        ++opInfoRef;
      }

      /* If still any IODID active in this row: */
      if(*pActiveIoDids != 0u)
      {
        /* Update IODID activity statistics */
        Dcm_SingletonContext.Diag.Services.Svc2F.HasAnyActiveIoDid = TRUE;
      }

      opInfoRefPage += (Dcm_CfgDidMgrDidOpClassHandleOptType)Dcm_UtiGetNumBitsOfXintType(Dcm_UtiBitSetBaseType);/* next bunch of IoDids */           /* PRQA S 2983 */ /* MD_Dcm_Redundant_2983 */
    }
  }
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
#include "Dcm_MemMap.h"                                                                                                                              /* PRQA S 5087 */ /* MD_MSR_MemMap */

#define DCM_START_SEC_CODE
#include "Dcm_MemMap.h"                                                                                                                              /* PRQA S 5087 */ /* MD_MSR_MemMap */
#if (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_AUTHMGR_DEFAULT_SESSION_TIMEOUT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrTimerStart()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrTimerStart(
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  Dcm_AuthMgrTimerType value
  )
{
  /* Start the appropriate authentication timer */
  Dcm_AuthMgrTimerSet(authInfoRef, value);

  if(!Dcm_TmrIsTimerRunning(DCM_TMR_ID_AUTHENTICATION))
  {
    /* Start the base authentication timer */
    Dcm_TmrStartTimer(DCM_TMR_ID_AUTHENTICATION, 1u);
  }
}
# endif

# if (DCM_AUTHMGR_DEFAULT_SESSION_TIMEOUT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrTimerSet()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrTimerSet(
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  Dcm_AuthMgrTimerType value
  )
{
  uint8_least lTimerIdx = Dcm_AuthMgrGetTimerIdx(authInfoRef);

  if(Dcm_DebugDetectRuntimeError(lTimerIdx >= DCM_AUTHMGR_NUM_DELAY_TIMERS))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
  {
    Dcm_SingletonContext.AuthMgr.DelayTime[lTimerIdx] = value;                                                                                       /* SBSW_DCM_POINTER_WRITE_DELAYTIME_AUTH */
  }
}
# endif

# if (DCM_STATE_AUTHENTICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrSetConnAuthState()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrSetConnAuthState(
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  Dcm_AuthenticationStateType value
  )
{
  if(Dcm_DebugDetectRuntimeError(authInfoRef >= DCM_CFGAUTHMGRNETCONNINFO_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
  {
    Dcm_AuthMgrNvMData[authInfoRef].ConnContext.AuthState = value;                                                                                   /* SBSW_DCM_POINTER_WRITE_AUTHNVMDATA */
  }
}
# endif

# if(DCM_AUTHMGR_WHITELISTS_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrGetWLContext()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrGetWLContext(
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  CONSTP2VAR(Dcm_AuthMgrWLContextPtrType, AUTOMATIC, AUTOMATIC) pWLContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lResult;

  if (Dcm_DebugDetectRuntimeError(authInfoRef >= DCM_CFGAUTHMGRNETCONNINFO_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);

    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_NOT_OK;
  }
  else
  {
    *pWLContext = &Dcm_AuthMgrNvMData[authInfoRef].ConnContext.WLContext;                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_OK;
  }

  return lResult;
}
# endif

# if (DCM_STATE_AUTHENTICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrUpdateActiveRole()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrUpdateActiveRole(
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  Dcm_CfgStateGroupMemType authRole
  )
{

  if (Dcm_DebugDetectRuntimeError(authInfoRef >= DCM_CFGAUTHMGRNETCONNINFO_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
  {
    Dcm_AuthMgrNvMData[authInfoRef].ConnContext.ActiveRole = authRole;                                                                               /* SBSW_DCM_POINTER_WRITE_AUTHNVMDATA */
  }
}
# endif

# if (DCM_AUTHMGR_DEFAULT_SESSION_TIMEOUT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrDetectIdleConnection()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrDetectIdleConnection(
  Dcm_CfgStateGroupOptType oldSession
  )
{
  /* If this is not a transition from default to default session: */
  if (oldSession != DCM_STATE_VALUE_SESSION_INIT)
  {
    Dcm_CfgNetAuthInfoRefMemType lAuthInfoRef = Dcm_NetGetAuthInfoRef(Dcm_NetGetSessionConnection());

    if (lAuthInfoRef != DCM_AUTHMGR_INVALID_AUTH_INFO_REF)
    {
      boolean lIsTimerActive;

      /* Enter critical section (Reason: A timer can be modified from an ISR or high priority task) */
      Dcm_UtiEnterCriticalSection();
      /*=================================*
      BEGIN CRITICAL SECTION
      *=================================*/
      lIsTimerActive = Dcm_AuthMgrTimerActive(lAuthInfoRef);                                                                                         /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
      /*=================================*
      END CRITICAL SECTION
      *=================================*/
      /* Leave critical section */
      Dcm_UtiLeaveCriticalSection();

      if (lIsTimerActive == FALSE)
      {
        if (Dcm_AuthMgrAuthenticationState(lAuthInfoRef) == DCM_AUTHENTICATED)
        {
          /* Deauthenticate the connection */
          Dcm_AuthMgrUpdateActiveRole(lAuthInfoRef, DCM_AUTHMGR_DEAUTHENTICATED_ROLE);
          Dcm_AuthMgrSetAuthentication(lAuthInfoRef, DCM_DEAUTHENTICATED);
        }
      }
    }
  }
}
# endif

# if (DCM_STATE_AUTHENTICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrDeauthenticateIdleConn()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrDeauthenticateIdleConn(
  void
  )
{
  Dcm_CfgNetAuthInfoRefOptType    lTmrIter = 0u;
  Dcm_AuthMgrTimerExpiredMaskType lExpiredTimers;

  /* Enter critical section (Reason: A timer can be modified from an ISR) */
  Dcm_UtiEnterCriticalSection();
  /*=================================*
  BEGIN CRITICAL SECTION
  *=================================*/
  /* Retrieve all expired authentication timers atomically */
  lExpiredTimers = Dcm_AuthMgrTimerExpireMaskGet();

  /* Reset global expired timers flag */
  Dcm_AuthMgrTimerExpireMaskReset();
  /*=================================*
  END CRITICAL SECTION
  *=================================*/
  /* Leave critical section */
  Dcm_UtiLeaveCriticalSection();

  DCM_UTI_LOOP_BIT_SCAN(lExpiredTimers)
  {
    if (Dcm_UtiBitOpTest(Dcm_AuthMgrTimerExpiredMaskType, lExpiredTimers, 0x01u))
    {
      /* If the connection is authenticated */
      if (Dcm_AuthMgrAuthenticationState(lTmrIter) == DCM_AUTHENTICATED)
      {
        if ( (Dcm_StateIsDefaultSessionActive())
           ||(lTmrIter != Dcm_NetGetAuthInfoRef(Dcm_NetGetSessionConnection())) )
        {
          Dcm_AuthMgrUpdateActiveRole((Dcm_CfgNetAuthInfoRefMemType)lTmrIter, DCM_AUTHMGR_DEAUTHENTICATED_ROLE);
          Dcm_AuthMgrSetAuthentication((Dcm_CfgNetAuthInfoRefMemType)lTmrIter, DCM_DEAUTHENTICATED);
        }
      }
    }

    ++lTmrIter;
  }
}
# endif

# if (DCM_STATE_AUTHENTICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrSetAuthentication()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrSetAuthentication(
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  Dcm_AuthenticationStateType authState
  )
{
  /* Set Authentication flag for connection to new state */
  Dcm_AuthMgrSetConnAuthState(authInfoRef, authState);
  /* Rte mode switch to new state */
  Dcm_ModeSwitchAuthentication(authInfoRef, authState);
}
# endif

/**********************************************************************************************************************
 *  Dcm_AuthMgrInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrInit(
  void
  )
{
# if (DCM_STATE_AUTHENTICATION_ENABLED == STD_ON)
#  if (DCM_AUTHMGR_PERSIST_STATE_ENABLED == STD_ON)
  Dcm_NegativeResponseCodeType lErrorCode;
#  endif

#  if (DCM_AUTHMGR_PERSIST_STATE_ENABLED == STD_ON)
  if (Dcm_ModeCheck(DCM_MODE_AUTH_PERSIST_STATE_MODERULE_REF, &lErrorCode) != DCM_E_OK)                                                              /* SBSW_DCM_POINTER_FORWARD_STACK */
#  endif
  {
    Dcm_CfgNetAuthInfoRefOptType lAuthInfoRef;

    for (lAuthInfoRef = 0u; lAuthInfoRef < DCM_CFGAUTHMGRNETCONNINFO_SIZE; lAuthInfoRef++)
    {
      Dcm_AuthMgrSetConnAuthState((Dcm_CfgNetAuthInfoRefMemType)lAuthInfoRef, DCM_DEAUTHENTICATED);
      Dcm_AuthMgrUpdateActiveRole((Dcm_CfgNetAuthInfoRefMemType)lAuthInfoRef, DCM_AUTHMGR_DEAUTHENTICATED_ROLE);
    }
  }

#  if (DCM_AUTHMGR_SET_DEAUTH_ROLE_ENABLED == STD_ON)
  Dcm_SingletonContext.AuthMgr.PendingData.ConnectionMask = 0u;
#  endif
  Dcm_AuthMgrTimerExpireMaskReset();
# endif
}

# if (DCM_AUTHMGR_SET_DEAUTH_ROLE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrSetDeauthenticatedRole()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrSetDeauthenticatedRole(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext
  )
{
  /* If diagnostic kernel is still busy with a diagnostic job, retry next task activation */
  if (pContext->Diag.State != DCM_DIAG_STATE_IDLE)
  {
    Dcm_TskSetLocalEvent(pEventContext->PostEv, DCM_TSK_EV_DIAG_WORK_EXT_SETROLE);                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
  {
    Dcm_NetConnRefOptType lConnHdl = 0u;
    uint32 lMask;

    /* Enter critical section (Reason: Protect against interrupts from Dcm_SetDeauthenticatedRole() API) */
    Dcm_UtiEnterCriticalSection();
    /*=================================*
     BEGIN CRITICAL SECTION
     *=================================*/
    lMask = Dcm_SingletonContext.AuthMgr.PendingData.ConnectionMask;

    DCM_UTI_LOOP_BIT_SCAN(lMask)
    {
      if (Dcm_UtiBitOpTest(uint32, lMask, 0x01u))
      {
        Dcm_CfgNetAuthInfoRefMemType lAuthInfoRef = Dcm_NetGetAuthInfoRef(lConnHdl);

        if (Dcm_AuthMgrAuthenticationState(lAuthInfoRef) == DCM_DEAUTHENTICATED)
        {
          Dcm_AuthMgrUpdateActiveRole(lAuthInfoRef, Dcm_SingletonContext.AuthMgr.PendingData.Role[lAuthInfoRef]);
        }
      }

      ++lConnHdl;
    }

    Dcm_SingletonContext.AuthMgr.PendingData.ConnectionMask = 0u;
    /*=================================*
     END CRITICAL SECTION
     *=================================*/
    /* Leave critical section */
    Dcm_UtiLeaveCriticalSection();
  }
}

/**********************************************************************************************************************
 *  Dcm_AuthMgrSetPendingRole()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_AuthMgrSetPendingRole(
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  Dcm_CfgStateGroupMemType pendingRole
  )
{
  if (Dcm_DebugDetectRuntimeError(authInfoRef >= DCM_CFGAUTHMGRNETCONNINFO_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
  {
    Dcm_SingletonContext.AuthMgr.PendingData.Role[authInfoRef] = pendingRole;                                                                        /* SBSW_DCM_ARRAY_WRITE_PENDINGROLEDATA */
  }
}
# endif
#endif /* (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_NetIsKeepAliveTimeStartOnFunc3E80Enabled()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetIsKeepAliveTimeStartOnFunc3E80Enabled(
  void
  )
{
  return (DCM_NET_KEEP_ALIVE_TIME_START_ON_FUNC_3E_80_ENABLED == STD_ON);                                                                            /* PRQA S 2995, 2996 */ /* MD_Dcm_ConstExpr */
}
/**********************************************************************************************************************
 *  Dcm_NetIsRxPduIdValid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetIsRxPduIdValid(
  PduIdType rxPduId
  )
{
  boolean lResult = TRUE;

  if( (rxPduId >= Dcm_PbCfgNetNumRxPduIds)
#if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
    ||(Dcm_NetGetConnHdlOfRxPduId(rxPduId) >= Dcm_PbCfgNetNumConnections)
#endif
    )
  {
    lResult = FALSE;
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_NetIsTxPduIdValid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetIsTxPduIdValid(
  PduIdType txPduId
  )
{
  boolean lResult = TRUE;

  if( (txPduId >= Dcm_PbCfgNetNumTxPduIds)
#if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
    ||(Dcm_NetGetConnHdlOfTxPduId(txPduId) >= Dcm_PbCfgNetNumConnections)
#endif
    )
  {
    lResult = FALSE;
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_NetGetComMContext()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_NetComMContextPtrType, DCM_CODE) Dcm_NetGetComMContext(
  Dcm_CfgNetNetIdRefOptType index
  )
{
  Dcm_NetComMContextPtrType lResult;

  if(Dcm_DebugDetectRuntimeError(index >= Dcm_PbCfgNetNumComMChannels))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    lResult = &Dcm_PbRamNetComMContext[0];
  }
  else
  {
    lResult = &Dcm_PbRamNetComMContext[index];
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_NetGetBufferContext()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_NetBufferContextPtrType, DCM_CODE) Dcm_NetGetBufferContext(
  Dcm_CfgNetBufferRefOptType index
  )
{
  Dcm_NetBufferContextPtrType lResult;

  if(Dcm_DebugDetectRuntimeError(index >= Dcm_PbCfgNetNumBuffers))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    lResult = &Dcm_PbRamNetBufferContext[0];
  }
  else
  {
    lResult = &Dcm_PbRamNetBufferContext[index];
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_NetPutToConn2TObjMap()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPutToConn2TObjMap(
  Dcm_NetConnRefOptType index,
  Dcm_CfgNetTObjHandleMemType value
  )
{
  if(Dcm_DebugDetectRuntimeError(index >= Dcm_PbCfgNetNumConnections))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
  {
    Dcm_PbRamNetConnHdl2TObjMap[index] = value;                                                                                                      /* SBSW_DCM_POINTER_WRITE_TOBJHANDLE */
  }
}

/**********************************************************************************************************************
 *  Dcm_NetWriteAddBufferU8At()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetWriteAddBufferU8At(
  Dcm_NetTransportObjectPtrType pTranspObj,
  uint8_least index,
  Dcm_MsgItemType value
  )
{
  if(Dcm_DebugDetectRuntimeError(index >= DCM_NET_TOBJ_ADDBUFFER_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
  {
    pTranspObj->AddBuffer[index] = value;                                                                                                            /* SBSW_DCM_POINTER_WRITE_TOBJ_ADDBUFFER */
  }
}

/**********************************************************************************************************************
 *  Dcm_NetGetBufferInfo()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_PbCfgNetBufferInfoPtrType, DCM_CODE) Dcm_NetGetBufferInfo(
  Dcm_CfgNetBufferRefOptType index
  )
{
  Dcm_PbCfgNetBufferInfoPtrType lResult;

  if(Dcm_DebugDetectRuntimeError(index >= Dcm_PbCfgNetNumBuffers))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    lResult = &Dcm_PbCfgNetBufferInfo[0];
  }
  else
  {
    lResult = &Dcm_PbCfgNetBufferInfo[index];
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_NetCommonInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetCommonInit(
  Dcm_ConfigPtrType configPtr
  )
{
  DCM_IGNORE_UNREF_PARAM(configPtr);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

#if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
  Dcm_SingletonContext.Network.ComVariant = configPtr->ComVariant;
#endif
#if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
  Dcm_SingletonContext.Network.RamVariant = configPtr->RamVariant->NetworkRam;
  Dcm_SingletonContext.Network.RomVariant = configPtr->RomVariant->NetworkRom;
#endif

  Dcm_SingletonContext.Network.NumActiveConnections = 0u;
  Dcm_SingletonContext.Network.ActiveProtocol = DCM_NET_INVALID_PROTID;
  Dcm_SingletonContext.Network.ActiveDiagnostic = DCM_NET_COMM_ACTIVE;
#if (DCM_NET_RX_BLOCKING_ENABLED == STD_ON)
  Dcm_SingletonContext.Network.RxAllowed = TRUE;
#endif
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
  Dcm_SingletonContext.Network.KeepAlive = FALSE;
#endif
}

/**********************************************************************************************************************
 *  Dcm_NetComMInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetComMInit(
  void
  )
{
  Dcm_CfgNetNetIdRefOptType lNetHandleIter;

  for(lNetHandleIter = 0; lNetHandleIter < Dcm_PbCfgNetNumComMChannels; ++lNetHandleIter)
  {
    Dcm_NetComMContextPtrType pComMContext;

    pComMContext = Dcm_NetGetComMContext(lNetHandleIter);

    pComMContext->ComState           = DCM_NET_COMM_STATE_RX_DIS_TX_DIS;                                                                             /* SBSW_DCM_POINTER_WRITE_COMMCONTEXT */
    pComMContext->RegisteredNetworks = 0u;                                                                                                           /* SBSW_DCM_POINTER_WRITE_COMMCONTEXT */
  }
}

/**********************************************************************************************************************
 *  Dcm_NetBufferInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetBufferInit(
  void
  )
{
  Dcm_CfgNetBufferRefOptType lBufferIter;

  for(lBufferIter = 0; lBufferIter < Dcm_PbCfgNetNumBuffers; ++lBufferIter)
  {
    Dcm_NetBufferContextPtrType pBufferContext;

    pBufferContext = Dcm_NetGetBufferContext(lBufferIter);

    pBufferContext->IsInUseCnt = 0u;                                                                                                                 /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
  }
}

/**********************************************************************************************************************
 *  Dcm_NetConnectionInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetConnectionInit(
  void
  )
{
  Dcm_NetConnRefOptType lConnIter;

  for(lConnIter = 0; lConnIter < Dcm_PbCfgNetNumConnections; ++lConnIter)
  {
    Dcm_NetPutToConn2TObjMap(lConnIter, DCM_NET_INVALID_TOBJID);
  }
}

/**********************************************************************************************************************
 *  Dcm_NetTranspObjInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTranspObjInit(
  void
  )
{
  Dcm_CfgNetTObjHandleOptType lTObjIter;

  for(lTObjIter = 0; lTObjIter < Dcm_PbCfgNetNumTransportObjects; ++lTObjIter)
  {
    Dcm_NetTransportObjectPtrType pTranspObj;

    pTranspObj = Dcm_NetGetTransportObject(lTObjIter);

    pTranspObj->ResType  = DCM_NET_TOBJ_RESTYPE_NONE;                                                                                                /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    pTranspObj->State    = DCM_NET_TOBJ_STATE_FREE;                                                                                                  /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    pTranspObj->Flags    = DCM_NET_TOBJ_FLAG_NONE;                                                                                                   /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    Dcm_NetWriteAddBufferU8At(pTranspObj, 0, 0x7Fu); /* always used for negative responses */                                                        /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    pTranspObj->Handle   = (Dcm_CfgNetTObjHandleMemType)lTObjIter;                                                                                   /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
  }
}

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgInit(
  void
  )
{
  /* Initialize periodic transmission manager state machine */
  Dcm_NetPeriodicMsgResetConnection();
  Dcm_NetPeriodicMsgInitDelayCntr();
  Dcm_NetPeriodicMsgInitFastestRate();
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
  {
    /* Initialization of delay timers */
    uint8_least lDelayTmrIter;
    for (lDelayTmrIter = 0; lDelayTmrIter < DCM_NET_DELAY_BULK_TRANSMISSION; ++lDelayTmrIter)
    {
      Dcm_NetDelayTimerSet(lDelayTmrIter, 0);
    }

    Dcm_NetPeriodicMsgResetNextDelayTimer();
  }
# endif
  {
    Dcm_CfgNetPTxObjHandleOptType lPerTxObjIter;
    for(lPerTxObjIter = 0; lPerTxObjIter < Dcm_PbCfgNetNumPerTxObjects; ++lPerTxObjIter)
    {
      Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj;

      pPeriodicTxObj = Dcm_NetGetPeriodicTxObject(lPerTxObjIter);

      /* Initialize the transport object */
      pPeriodicTxObj->Timer = 0u;                                                                                                                    /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */
      pPeriodicTxObj->State = DCM_NET_PERIODIC_TX_STATE_FREE;                                                                                        /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */
      pPeriodicTxObj->TxPduInfo.SduDataPtr = pPeriodicTxObj->TxBuffer;                                                                               /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */
    }
  }
}
#endif

/**********************************************************************************************************************
 *  Dcm_NetInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetInit(
  Dcm_ConfigPtrType configPtr
  )
{
  /* First initialize common variables */
  Dcm_NetCommonInit(configPtr);                                                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* Now initialize all remaining network related sub-elements. The order of execution shall not be relevant */
  Dcm_NetComMInit();                                                                                                                                 /* PRQA S 2987 */ /* MD_Dcm_2987 */
  Dcm_NetBufferInit();
  Dcm_NetConnectionInit();                                                                                                                           /* PRQA S 2987 */ /* MD_Dcm_2987 */
  Dcm_NetTranspObjInit();
#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
  Dcm_NetPeriodicMsgInit();
#endif
}

/**********************************************************************************************************************
 *  Dcm_NetComposeAddNegResponse()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetComposeAddNegResponse(                                                                                  /* COV_DCM_RTM_NO_RCR_RP_TX */
  Dcm_NetTransportObjectPtrType pTranspObj,
  Dcm_NetResponseType resType,
  Dcm_NegativeResponseCodeType nrc
  )
{
  Dcm_NetWriteAddBufferU8At(pTranspObj, 2, nrc); /* NRC = nrc, 0x7F and SID are already copied! */                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
  pTranspObj->BuffInfo.SduDataPtr = pTranspObj->AddBuffer; /* use the temp buffer to free the main buffer now */                                     /* SBSW_DCM_PARAM_PTR_WRITE */
  pTranspObj->BuffInfo.SduLength  = 3u;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
  pTranspObj->ResType             = resType;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
  pTranspObj->State               = DCM_NET_TOBJ_STATE_PREPTX;                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
}

#if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetOnRequestDetection()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetOnRequestDetection(
  Dcm_NetConnRefMemType connHdl
  )
{
  Dcm_NetTransportObjectPtrType pTranspObj;
  BufReq_ReturnType             lBufReqResult;

  /* Retrieve the transport object from the given connection */
  lBufReqResult = Dcm_NetGetTranspObjOfConnection(connHdl, &pTranspObj);                                                                             /* SBSW_DCM_POINTER_FORWARD_STACK */

  /* Check whether a transport object is in use */
  if(lBufReqResult == BUFREQ_OK)
  {
    /* Enter critical section (Reason: the transport object may not be modified from outside (e.g. Dcm_TpTxConfirmation releases it) */
    Dcm_UtiEnterCriticalSection();
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    /*  Retrieve again the transport object from connection to guarantee it has still the same state */
    lBufReqResult = Dcm_NetGetTranspObjOfConnection(connHdl, &pTranspObj);                                                                           /* SBSW_DCM_POINTER_FORWARD_STACK */

    /* Check the connection still uses the same transport object (it is always 1:1 association between connection and a transport object) */
    if(lBufReqResult == BUFREQ_OK)                                                                                                                   /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY TX */
    {
      /* Check whether the connection is free */
      if(pTranspObj->State != DCM_NET_TOBJ_STATE_FREE)
      {
        /* Check if suppression of responses on functional addressed requests is enabled */
        if( (Dcm_NetIsPropertieSet(pTranspObj, DCM_NET_CONN_PROP_TX_ON_FUNC_RX))
          &&(Dcm_PbCfgNetRxPduInfo[pTranspObj->RxPduId].IsFuncReq == TRUE) )
        {
          /*
           * Interruption of functional addressed request is not necessary because response will already be
           * suppressed
           */
        }
        /* Otherwise, interrupt ongoing service processing */
        else
        {
          /* If a new request is being received: */
          if(pTranspObj->State == DCM_NET_TOBJ_STATE_ONRX)
          {
            /* Isolate this connection */
            pTranspObj->Flags |= DCM_NET_TOBJ_FLAG_CANCELED;                                                                                         /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */

            /* Terminate the ongoing reception immediately */
            (void)PduR_DcmCancelReceive(pTranspObj->RxPduId);
          }
          /* Otherwise, let the task cancel any pending jobs */
          else
          {
            /* Mark transport object as obsolete. This is used to distinguish between two allocations of the same transport object before the Dcm_NetTaskTaMonitor is called */
            pTranspObj->Flags |= DCM_NET_TOBJ_FLAG_OBSOLETE;                                                                                         /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */
            Dcm_TskSetEvent(DCM_TSK_ID_NET_TA_MONITOR, Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, pTranspObj->Handle));
          }
        }
      }/* else - nothing to interrupt */
    }/* else - request no more in progress -> ignore */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    /* Leave critical section */
    Dcm_UtiLeaveCriticalSection();
  }/* else - no request in progress or different tester -> ignore */
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

/**********************************************************************************************************************
 *  Dcm_NetExecStartProtocolOp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetExecStartProtocolOp(
  Dcm_ProtocolType newProtocol
  )
{
  boolean      lResult = TRUE;
  uint16_least lIter;

  for (lIter = 0u; Dcm_CfgNetProtocolNotificationInfo[lIter].StartFunc != NULL_PTR; ++lIter)                                                         /* PRQA S 2842 */ /* MD_Dcm_DerefInvalidPointer */
  {
    if(Dcm_CfgNetProtocolNotificationInfo[lIter].StartFunc(newProtocol) != DCM_E_OK)                                                                 /* SBSW_DCM_CALL_FUNCPTR_TERMINATED_LIST */
    {
      lResult = FALSE;
      break;
    }
  }
  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_NetProcessStartProtocol()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetProcessStartProtocol(
  Dcm_NetTransportObjectPtrType pTranspObj
  )
{
  boolean startProtocolAllowed;

  startProtocolAllowed = Dcm_NetExecStartProtocolOp(Dcm_PbCfgNetProtocolInfo[Dcm_NetGetProtIdOfTranspObj(pTranspObj)].Id);
  if(startProtocolAllowed == FALSE)
  {
    Dcm_NetBufferContextPtrType pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);
    /* Neg response 0x22 */
    Dcm_NetComposeAddNegResponse(pTranspObj
                                ,DCM_NET_TOBJ_RESTYPE_SIMPLE
                                ,DCM_E_CONDITIONSNOTCORRECT);                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_NetBufferRelease(pBufferContext); /* the buffer is free now */                                                                               /* PRQA S 3387 */ /* MD_Dcm_OptimizedInlineCode_3387 */ /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
    Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND_USDT);
  }
  else
  {
#if (DCM_NET_PROTOCOL_PARALLELISATION_ENABLED == STD_ON)
    if( (Dcm_NetGetThreadIdOfTranspObj(pTranspObj) == DCM_THREAD_ID_BASIC)
      ||(Dcm_StateGetPendingSession() != DCM_STATE_VALUE_SESSION_INIT) )
#endif
    {
      if(Dcm_DiagIsCancellationNeeded(pTranspObj) == TRUE)                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
      {
        Dcm_DiagCancelProcessing(pTranspObj);                                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */

        /* According to AR DCM SWS the session switch is executed at start protocol, not at stop! */
        Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_INT_SET2DEF);
      }/* else - no protocol enabled -> no need to reset anything in case that parallelization is not enabled */
    }

#if (DCM_NET_PROTOCOL_PARALLELISATION_ENABLED == STD_ON)
    if(Dcm_NetGetThreadIdOfTranspObj(pTranspObj) == DCM_THREAD_ID_BASIC)
#endif
    {
      Dcm_SingletonContext.Network.ActiveProtocol = Dcm_NetGetProtIdOfTranspObj(pTranspObj); /* Set new active protocol */
    }

    /* Update P2 timings at once */
    Dcm_DiagSetP2Timings(0, Dcm_NetGetProtIdOfTranspObj(pTranspObj), Dcm_NetGetThreadIdOfTranspObj(pTranspObj));

    Dcm_DiagRxIndication(pTranspObj);                                                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */

/**********************************************************************************************************************
 *  Dcm_NetRxPrioritisationFindWinner()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_CfgNetTObjHandleOptType, DCM_CODE) Dcm_NetRxPrioritisationFindWinner(
  Dcm_TskTaskEvOptType ev,
  Dcm_TskTaskEvPtrType pBusyEvents
  )
{
  Dcm_TskTaskEvOptType lEv = ev;
  uint16 lMaxPrio = 0x100u;/* lower than the lowest configurable priority (256 > 255) */

  Dcm_CfgNetTObjHandleOptType lTObjCntr = 0u;
  Dcm_CfgNetTObjHandleOptType lTranspObjWinnerId = DCM_NET_INVALID_TOBJID;

  *pBusyEvents = 0;                                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */

  DCM_TSK_EVENT_SCAN_LOOP(lEv)
  {
    /* Scan all arrived transport objects */
    if (Dcm_TskIsLocalEventSet(lEv, 0x01u)) /* start scan from the LSB since TObjects are allocated by reversed iteration and thus -> first allocated (last checked here) will be the winner */
    {
      uint8 tmpProtPrio = Dcm_NetGetProtObjOfTranspObj(Dcm_NetGetTransportObject(lTObjCntr))->Priority;

      /* Higher priority */
      if(lMaxPrio <= tmpProtPrio)
      {
        /* Lower priority than current request/pending response */
        *pBusyEvents |= Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, lTObjCntr);                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
      }
      else
      {
        if(lTranspObjWinnerId < DCM_NET_INVALID_TOBJID)
        {
          /* Mark busy for the last winner */
          *pBusyEvents |= Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, lTranspObjWinnerId);                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
        }

        /* Update maximum priority */
        lMaxPrio = tmpProtPrio;

        /* potential winner found */
        lTranspObjWinnerId = lTObjCntr;
      }
    }
    ++lTObjCntr;
  }
  return lTranspObjWinnerId;
}

/**********************************************************************************************************************
 *  Dcm_NetRxPrioritisationProcessWinner()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetRxPrioritisationProcessWinner(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NetTransportObjectPtrType pTranspObj,
  Dcm_TskTaskEvPtrType pBusyEvents
  )
{
  if(Dcm_NetGetProtIdOfActiveProtocol() != Dcm_NetGetProtIdOfTranspObj(pTranspObj))/* the winner is a different protocol as the old one -> interrupt the old protocol */
  {
    if( (Dcm_NetGetProtIdOfActiveProtocol() >= DCM_NET_INVALID_PROTID) /* very first protocol activation - start the protocol/send NRC 0x21 responses */
      ||(Dcm_PbCfgNetProtocolInfo[Dcm_NetGetProtIdOfTranspObj(pTranspObj)].Priority
         < Dcm_PbCfgNetProtocolInfo[Dcm_NetGetProtIdOfActiveProtocol()].Priority) /* new one is higher priority */
      ||( (((DCM_DIAG_QUEUE_FLAG_IS_ACTIVE | DCM_DIAG_QUEUE_FLAG_IS_WAITING)
            & pContext->Diag.QueuedSet.Flags) == 0u ) /* if idle or post-processing (considered for back-to-back requests) ... */
        &&((DCM_STATE_VALUE_SESSION_INIT & Dcm_StateGetPendingSession()) != 0u) ) /* ... still default session - continue with new request */
      )
    {
      Dcm_NetProcessStartProtocol(pTranspObj);                                                                                                       /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    }
    else
    {
      /* Mark busy for the winner */
      *pBusyEvents |= Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, pTranspObj->Handle);                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }
  else /* same protocol - proceed with the new request/NRC 0x21 responses */
  {
    Dcm_DiagRxIndication(pTranspObj);                                                                                                                /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
  }
}

/**********************************************************************************************************************
 *  Dcm_NetRxPrioritisationProcessLoosers()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetRxPrioritisationProcessLoosers(
  Dcm_TskTaskEvOptType BusyEvents
  )
{
  Dcm_CfgNetTObjHandleOptType lTObjCntr = 0u;
  Dcm_TskTaskEvOptType        lBusyEvents = BusyEvents;

  DCM_TSK_EVENT_SCAN_LOOP(lBusyEvents)
  {
    /* Check who did just loose */
    if (Dcm_TskIsLocalEventSet(lBusyEvents, 0x01u))
    {
      Dcm_NetTransportObjectPtrType pTranspObj = Dcm_NetGetTransportObject(lTObjCntr);
      Dcm_NetBufferContextPtrType pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);

      Dcm_NetBufferRelease(pBufferContext); /* the buffer is free now */                                                                             /* PRQA S 3387 */ /* MD_Dcm_OptimizedInlineCode_3387 */ /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
#if (DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
      pTranspObj->Flags |= (Dcm_NetTransportObjectFlagType)(DCM_NET_TOBJ_FLAG_BUSY | DCM_NET_TOBJ_FLAG_IGNORE);                                      /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND_USDT);
#else
# if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
      if ((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) == 0u) /* internal requests do not manage the ComM state */
# endif
      {
        Dcm_NetUnRegisterComMActivity(pTranspObj->ConnHdl);
      }
      Dcm_NetUnRegisterActiveConnection(pTranspObj);/* no further processing needed */                                                               /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
#endif
    }
    ++lTObjCntr;
  }
}

/**********************************************************************************************************************
 *  Dcm_NetRegisterActiveConnection()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetRegisterActiveConnection(
  Dcm_NetTransportObjectPtrType pTranspObj                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  DCM_IGNORE_UNREF_PARAM(pTranspObj);                                                                                                                /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
#if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
  if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) == 0u)/* internal requests do not manage the S3 timer */
#endif
  {
    Dcm_DebugAssert((Dcm_SingletonContext.Network.NumActiveConnections != Dcm_UtiMaxValueOfUintType(uint8)), DCM_SID_INTERNAL, DCM_E_PARAM);         /* COV_DCM_RTM_DEV_DEBUG XF */

    /* Enter critical section (Reason: protect the statistic counter against parallel request notifications or transmission confirmations, executed from within interrupts ) */
    Dcm_UtiEnterCriticalSection();
    /*=================================*
     BEGIN CRITICAL SECTION
     *=================================*/
    /* Reset the idle connection deauthentication timer for this connection */
#if (DCM_AUTHMGR_DEFAULT_SESSION_TIMEOUT_ENABLED == STD_ON)
    /* Check if authentication restriction is supported for this connection */
    if(Dcm_NetGetAuthInfoRef(pTranspObj->ConnHdl) != DCM_AUTHMGR_INVALID_AUTH_INFO_REF)
    {
      Dcm_AuthMgrTimerReset(Dcm_NetGetAuthInfoRef(pTranspObj->ConnHdl));
    }
#endif

    if(Dcm_SingletonContext.Network.NumActiveConnections == 0u)
    {
      Dcm_TmrStopTimer(DCM_TMR_ID_S3);
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
      Dcm_TmrStopTimer(DCM_TMR_ID_KEEP_ALIVE);
#endif
    }

    /* Register a new active connection */
    ++Dcm_SingletonContext.Network.NumActiveConnections;
    /*=================================*
     END CRITICAL SECTION
     *=================================*/
    Dcm_UtiLeaveCriticalSection();
  }
}

/**********************************************************************************************************************
 *  Dcm_NetTransmitUsdtResponse()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTransmitUsdtResponse(
  Dcm_NetTransportObjectPtrType pTranspObj
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  boolean doCallTxConfirmation = TRUE;

  /* The Tx path must be still "ready" here. if not, check the caller - it shall take care about this state! */
  Dcm_DebugAssert((pTranspObj->State == DCM_NET_TOBJ_STATE_PREPTX), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                          /* COV_DCM_RTM_DEV_DEBUG XF */

  /* Prepare the given transport object for USDT response transmission (set all relevant attributes to their initial values) */
  pTranspObj->BuffPos = 0u;                                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
  pTranspObj->State = DCM_NET_TOBJ_STATE_ONTX;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */

  /* If the USDT response shall be suppressed for any non-diagnostic but transport protocol reasons (e.g. no response on functional requests or no TxPduId configured), do: */
  if( (Dcm_NetIsPropertieSet(pTranspObj, DCM_NET_CONN_PROP_TX_ON_FUNC_RX))
    &&(Dcm_PbCfgNetRxPduInfo[pTranspObj->RxPduId].IsFuncReq == TRUE)
#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
    &&(pTranspObj->ResType != DCM_NET_TOBJ_RESTYPE_UNSOLICITED)
#endif
    )
  {
    lStdResult = DCM_E_OK; /* No response on functional requests required -> leave with success */
  }
  else if (Dcm_NetIsPropertieSet(pTranspObj, DCM_NET_CONN_PROP_NO_MAIN_TX))
  {
    lStdResult = DCM_E_OK; /* No associated TxPduId -> leave with success */
  }
  else
  {
    /* Otherwise, if the communication mode on the ComM channel associated with the transport object still allows any response transmissions: */
    if((DCM_NET_COMM_STATE_FLAG_TX_EN & Dcm_NetGetComStateByTranspObject(pTranspObj)) != 0u)
    {
      PduInfoType    lTpTransmitData;
#if (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
      uint8          lMetaData[DCM_NET_METADATA_LENGTH];
#endif

#if (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
      /* In case of generic connection, the transmit data references the meta data, otherwise, it references the payload. */
      if(Dcm_NetIsGenericConnection(pTranspObj->ConnHdl))
      {
        lMetaData[DCM_NET_METADATA_SA_OFFSET] = Dcm_NetGetNodeAddress(pTranspObj->ConnHdl);                                                          /* SBSW_DCM_LOCAL_ARRAY_WRITE */
        lMetaData[DCM_NET_METADATA_TA_OFFSET] = (uint8)pTranspObj->ClientSrcAddr; /* safe cast, since ClientSrcAddr is source address of MetaData because ConnHdl is generic */ /* SBSW_DCM_LOCAL_ARRAY_WRITE */
        lTpTransmitData.SduDataPtr = &lMetaData[0];
      }
      else
#endif
      {
        lTpTransmitData.SduDataPtr = pTranspObj->BuffInfo.SduDataPtr;
      }

      /* The length of the Sdu does not consider the meta data. */
      lTpTransmitData.SduLength = pTranspObj->BuffInfo.SduLength;

      lStdResult = PduR_DcmTransmit(Dcm_PbCfgNetConnectionInfo[pTranspObj->ConnHdl].TxPduIdMain
                                   ,&lTpTransmitData);                                                                                               /* SBSW_DCM_POINTER_FORWARD_STACK */

      /* If this transmission request was accepted, wait for the Tx-Confirmation from the XxxTp */
      if(lStdResult == E_OK)
      {
        doCallTxConfirmation = FALSE;
      }
    }
  }
  /* Otherwise, take the shortcut and loop-back through the USDT message confirmation with failed result (this response had to be sent, but couldn't and no retry is allowed (SWS)) */

  /* Make a loop-back and finalize transmission */
  if(doCallTxConfirmation == TRUE)
  {
    Dcm_NetUsdtTxConfirmation(pTranspObj, lStdResult);                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
}

#if (DCM_NET_CONN_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetLockConnection()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetLockConnection(
  Dcm_NetConnRefMemType connHdl,
  CONSTP2VAR(Dcm_NetTransportObjectPtrType, AUTOMATIC, AUTOMATIC) pTranspObj
  )
{
  BufReq_ReturnType lResult;

  Dcm_UtiEnterCriticalSection();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  /* Try allocating a new or getting an already allocated transport object */
  lResult = Dcm_NetAllocateOrGetTranspObject(connHdl, pTranspObj);                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lResult == BUFREQ_OK)
  {
    if((*pTranspObj)->State == DCM_NET_TOBJ_STATE_FREE)
    {
      Dcm_NetBufferContextPtrType pBufferContext;

      /* Setup the transport object */
      (*pTranspObj)->ConnHdl = connHdl;                                                                                                              /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
      (*pTranspObj)->BufferHdl = Dcm_NetGetProtObjOfConnection(connHdl)->RxTxBufferRef;                                                              /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */

      pBufferContext = Dcm_NetGetBufferContext((*pTranspObj)->BufferHdl);

      /* Is the buffer still free ? */
      if(Dcm_NetBufferIsFree(pBufferContext))
      {
        Dcm_NetBufferLock(pBufferContext); /* the buffer is in use now */                                                                            /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
        (*pTranspObj)->State = DCM_NET_TOBJ_STATE_RESERVED;                                                                                          /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
        lResult = BUFREQ_OK;
      }
      else
      {
        Dcm_NetTranspObjRelease(*pTranspObj);                                                                                                        /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
        lResult = BUFREQ_E_NOT_OK;
      }
    }
    else
    {
      lResult = BUFREQ_E_NOT_OK;
    }
  }/* else - nothing found to be free */
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiLeaveCriticalSection();

  return lResult;
}
#endif

/**********************************************************************************************************************
 *  Dcm_NetTpRxIndicationNotOk()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpRxIndicationNotOk(
  Dcm_NetTransportObjectPtrType pTranspObj
  )
{
#if (DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
  if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_BUSY) == 0u) /* consider only real buffer usage */                                                       /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
#endif
  {
    Dcm_NetBufferContextPtrType pBufferContext;

    pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);

    Dcm_NetBufferRelease(pBufferContext); /* the buffer is free now */                                                                               /* PRQA S 3387 */ /* MD_Dcm_OptimizedInlineCode_3387 */ /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
  }
  Dcm_NetUnRegisterActiveConnection(pTranspObj);/* no further processing needed */                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
}

/**********************************************************************************************************************
 *  Dcm_NetTpRxIndicationOk()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpRxIndicationOk(
  Dcm_NetTransportObjectPtrType pTranspObj
  )
{
#if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
  if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_CANCELED) != 0u) /* CancelReceive was called before -> ignore request although reception couldn't be canceled */
  {
    Dcm_NetBufferContextPtrType pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);
    Dcm_NetBufferRelease(pBufferContext); /* the buffer is free now */                                                                               /* PRQA S 3387 */ /* MD_Dcm_OptimizedInlineCode_3387 */ /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
    Dcm_NetUnRegisterActiveConnection(pTranspObj);/* no further processing needed */                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else
#endif
  {
    boolean keepTranspObj;
    keepTranspObj = Dcm_DiagAcceptNewRequest(pTranspObj);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
    pTranspObj->State = DCM_NET_TOBJ_STATE_RX_END;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */

    if(keepTranspObj == TRUE)
    {
      Dcm_NetRegisterComMActivity(pTranspObj);                                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
#if (DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
      if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_BUSY) != 0u)
      {
        Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND_USDT);
      }
      else
#endif
      {
        /* Store SID for RCR-RP/busy on protocol prioritisation responses */
        Dcm_NetWriteAddBufferU8At(pTranspObj, 1u, pTranspObj->RxData[0]);                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
        /* Signal processing start */
        Dcm_TskSetEventByThread(DCM_TSK_ID_NET_RX, Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, pTranspObj->Handle), Dcm_NetGetThreadIdOfTranspObj(pTranspObj)); /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */
      }
    }
    else
    {
      if (Dcm_NetIsKeepAliveTimeStartOnFunc3E80Enabled())
      {
        if ((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_IGNORE) == 0u)
        {
          /* Register at ComM */
          Dcm_NetRegisterComMActivity(pTranspObj);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
          Dcm_SingletonContext.Network.KeepAlive = TRUE;
          /* Unregister at ComM */
          Dcm_NetUnRegisterComMActivity(pTranspObj->ConnHdl);
        }
      }
      Dcm_NetTpRxIndicationNotOk(pTranspObj);                                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
  }
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetDelayTimerGet()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_TmrTimerCntrOptType, DCM_CODE) Dcm_NetDelayTimerGet(
  uint8_least timer
  )
{
  return Dcm_SingletonContext.Network.PeriodicTxContext.DelayTimer[timer];
}
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetDelayTimerSet()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetDelayTimerSet(
  uint8_least timer,
  Dcm_TmrTimerCntrOptType timeout
  )
{
  if (Dcm_DebugDetectRuntimeError(timer >= DCM_NET_DELAY_BULK_TRANSMISSION))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
  {
    Dcm_SingletonContext.Network.PeriodicTxContext.DelayTimer[timer] = (Dcm_TmrTimerCntrMemType)timeout;                                             /* SBSW_DCM_POINTER_WRITE_DELAYTIMER */
  }
}
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetDelayTimerExpired()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetDelayTimerExpired(
  uint8_least timer
  )
{
  return (boolean)(Dcm_SingletonContext.Network.PeriodicTxContext.DelayTimer[timer] == 0u);                                                          /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPTxObjTimerSet()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPTxObjTimerSet(
  Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj,
  Dcm_TmrTimerCntrMemType timeout
  )
{
  Dcm_SplitTaskEnterCS();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  pPeriodicTxObj->Timer = timeout;                                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_SplitTaskLeaveCS();
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPTxObjTimerStart()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPTxObjTimerStart(
  Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj,
  Dcm_TmrTimerCntrMemType timeout
  )
{
  Dcm_NetPTxObjTimerSet(pPeriodicTxObj, timeout);                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */

  if (!Dcm_TmrIsTimerRunning(DCM_TMR_CONTEXT_ID_PERIODIC_TX))
  {
    Dcm_TmrStartTimer(DCM_TMR_ID_PERIODIC_TX, 1u);
  }
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPTxObjTimerStop()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPTxObjTimerStop(
  Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj
  )
{
  Dcm_NetPTxObjTimerSet(pPeriodicTxObj, 0u);                                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
}
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgIncNextDelayTimer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgIncNextDelayTimer(
  void
  )
{
  ++Dcm_SingletonContext.Network.PeriodicTxContext.NextDelayTimer;
  if (Dcm_NetPeriodicMsgGetNextDelayTimer() >= DCM_NET_DELAY_BULK_TRANSMISSION)
  {
    Dcm_NetPeriodicMsgResetNextDelayTimer();
  }
}
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgSetFastestRate()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgSetFastestRate(
  Dcm_Svc2ASchedRateOptType Rate
  )
{
  /* If the new rate differs from the previous rate */
  if (Dcm_NetPeriodicMsgGetFastestRate() != Rate)
  {
    Dcm_TmrTimerCntrMemType lRateDiff;
    uint8_least lDelayTmrIter;

    /* If changing to a faster rate */
    if (Rate > Dcm_NetPeriodicMsgGetFastestRate())
    {
      lRateDiff = (Dcm_TmrTimerCntrMemType) ( Dcm_NetGetPeriodicDelayTime(Dcm_NetPeriodicMsgGetFastestRate())
                                            - Dcm_NetGetPeriodicDelayTime(Rate) );

      for (lDelayTmrIter = 0; lDelayTmrIter < DCM_NET_DELAY_BULK_TRANSMISSION; ++lDelayTmrIter)
      {
        /*=================================*
          BEGIN CRITICAL SECTION
         *=================================*/
        Dcm_SplitTaskEnterCS(); /* Protect against interrupt from timer task */
        /* If delay timer is set */
        if (Dcm_NetDelayTimerExpired(lDelayTmrIter) == FALSE)
        {
          if (Dcm_NetDelayTimerGet(lDelayTmrIter) <= lRateDiff)
          {
            Dcm_NetDelayTimerSet(lDelayTmrIter, 1); /* immediate timeout */
          }
          else
          {
            /* decrease timer value by rate difference */
            Dcm_NetDelayTimerSet(lDelayTmrIter, (Dcm_TmrTimerCntrOptType)(Dcm_NetDelayTimerGet(lDelayTmrIter) - lRateDiff));
          }
        }
        Dcm_SplitTaskLeaveCS();
        /*=================================*
          END CRITICAL SECTION
         *=================================*/
      }
    }
    else /* Otherwise (changing to a slower rate) */
    {
      lRateDiff = (Dcm_TmrTimerCntrMemType) ( Dcm_NetGetPeriodicDelayTime(Rate)
                                            - Dcm_NetGetPeriodicDelayTime(Dcm_NetPeriodicMsgGetFastestRate()) );

      for (lDelayTmrIter = 0; lDelayTmrIter < DCM_NET_DELAY_BULK_TRANSMISSION; ++lDelayTmrIter)
      {
        /*=================================*
          BEGIN CRITICAL SECTION
         *=================================*/
        Dcm_SplitTaskEnterCS(); /* Protect against interrupt from timer task */
        /* If delay timer is set */
        if (Dcm_NetDelayTimerExpired(lDelayTmrIter) == FALSE)
        {
          /* increase timer value by rate difference */
          Dcm_NetDelayTimerSet(lDelayTmrIter, (Dcm_TmrTimerCntrOptType)(Dcm_NetDelayTimerGet(lDelayTmrIter) + lRateDiff));
        }
        Dcm_SplitTaskLeaveCS();
        /*=================================*
          END CRITICAL SECTION
         *=================================*/
      }
    }

    Dcm_SingletonContext.Network.PeriodicTxContext.FastestRate = (Dcm_Svc2ASchedRateMemType)Rate;
  }
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPTxDelayTimerStart()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPTxDelayTimerStart(
  void
  )
{
  Dcm_NetDelayTimerSet(Dcm_NetPeriodicMsgGetNextDelayTimer()
                      ,Dcm_NetGetPeriodicDelayTime(Dcm_NetPeriodicMsgGetFastestRate()));
  Dcm_NetPeriodicMsgIncNextDelayTimer();

  /* Make sure system timer for periodic tx is running */
  Dcm_TmrStartTimer(DCM_TMR_ID_PERIODIC_TX, 1u);
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutTxObjectHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_OnTimeoutTxObjectHandler(
  void
  )
{
  Dcm_CfgNetPTxObjHandleOptType lPerTxObjIter;
  boolean                       lReloadTimer = FALSE;

  for(lPerTxObjIter = 0; lPerTxObjIter < Dcm_PbCfgNetNumPerTxObjects; ++lPerTxObjIter)
  {
    Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj;

    pPeriodicTxObj = Dcm_NetGetPeriodicTxObject(lPerTxObjIter);
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    Dcm_UtiEnterCriticalSection(); /* protect against high level interrupts from the network interface */
    if(!Dcm_NetPTxObjTimerExpired(pPeriodicTxObj))
    {
      Dcm_NetPTxObjTimerSet(pPeriodicTxObj, (Dcm_TmrTimerCntrMemType)(Dcm_NetPTxObjTimerGet(pPeriodicTxObj) - 1u));                                  /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */
      if(Dcm_NetPTxObjTimerExpired(pPeriodicTxObj))
      {
        (void)PduR_DcmCancelTransmit(Dcm_NetPeriodicMsgGetTxPduIdCurrConn(lPerTxObjIter)); /* try to cancel still ongoing Tx */                      /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */
        Dcm_NetPeriodicMsgRelease(pPeriodicTxObj);                                                                                                   /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */
      }
      else
      {
        lReloadTimer = TRUE; /* at least one active timer - reload timer */
      }
    }
    Dcm_UtiLeaveCriticalSection();
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
  }

  return lReloadTimer;
}
#endif

#if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutDelayTimerHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_OnTimeoutDelayTimerHandler(
  void
  )
{
  uint8_least lDelayTmrIter;
  boolean     lReloadTimer = FALSE;
  boolean     lSetTxEvent = FALSE;
  for(lDelayTmrIter = 0; lDelayTmrIter < DCM_NET_DELAY_BULK_TRANSMISSION; ++lDelayTmrIter)
  {
    if(Dcm_NetDelayTimerExpired(lDelayTmrIter) == FALSE)
    {
      Dcm_NetDelayTimerSet(lDelayTmrIter, (Dcm_TmrTimerCntrOptType)(Dcm_NetDelayTimerGet(lDelayTmrIter)-1u));
      if(Dcm_NetDelayTimerExpired(lDelayTmrIter) == TRUE)
      {
        Dcm_NetPeriodicMsgIncDelayCntr();
        lSetTxEvent = TRUE;
      }
      else
      {
        lReloadTimer = TRUE; /* at least one active timer - reload timer */
      }
    }
  }

  if (lSetTxEvent == TRUE)
  {
    Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND_UUDT);
  }

  return lReloadTimer;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetGetPeriodicTxObject()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_NetPeriodicTxObjectPtrType, DCM_CODE) Dcm_NetGetPeriodicTxObject(
  Dcm_CfgNetPTxObjHandleOptType index
  )
{
  Dcm_NetPeriodicTxObjectPtrType lResult;

  if(Dcm_DebugDetectRuntimeError(index >= Dcm_PbCfgNetNumPerTxObjects))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    lResult = &Dcm_PbRamNetPeriodicTxObject[0];
  }
  else
  {
    lResult = &Dcm_PbRamNetPeriodicTxObject[index];
  }

  return lResult;
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgResetConnection()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgResetConnection(
  void
  )
{
  Dcm_NetPeriodicMsgResetNextMsgHdl();
  Dcm_NetPeriodicMsgResetTxObjectSentCntr();
  Dcm_NetPeriodicMsgSetConnection(DCM_NET_INVALID_CONNHDL);
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgStopDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgStopDid(
  uint16 Did
  )
{
  Dcm_CfgNetPTxObjHandleOptType lPerTxObjIter;
  for (lPerTxObjIter = 0; lPerTxObjIter < Dcm_NetPeriodicMsgGetNextMsgHdl(); lPerTxObjIter++)
  {
    Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj;

    pPeriodicTxObj = Dcm_NetGetPeriodicTxObject(lPerTxObjIter);

    if (  (pPeriodicTxObj->State != DCM_NET_PERIODIC_TX_STATE_FREE)
       && (pPeriodicTxObj->Did == Did))
    {
      /*=================================*
        BEGIN CRITICAL SECTION
       *=================================*/
      Dcm_UtiEnterCriticalSection(); /* Enter critical section (Reason: Protect against high level interrupts from the network interface) */
      switch (pPeriodicTxObj->State)
      {
        case DCM_NET_PERIODIC_TX_STATE_ONTX:
          (void)PduR_DcmCancelTransmit(Dcm_NetPeriodicMsgGetTxPduIdCurrConn(lPerTxObjIter)); /* try to cancel still ongoing Tx */                    /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */
          /* fall through */
        case DCM_NET_PERIODIC_TX_STATE_RESERVED:                                                                                                     /* PRQA S 2003 */ /* MD_Dcm_Optimize_2003 */
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
        case DCM_NET_PERIODIC_TX_STATE_QUEUED:
# endif
          Dcm_NetPeriodicMsgRelease(pPeriodicTxObj);                                                                                                 /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */
          break;
        default:
          /* nothing to do */
          break;
      }
      Dcm_UtiLeaveCriticalSection();
      /*=================================*
        END CRITICAL SECTION
       *=================================*/
    }
  }
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgGetTxBuffer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_MsgType, DCM_CODE) Dcm_NetPeriodicMsgGetTxBuffer(
  Dcm_CfgNetPTxObjHandleOptType perTxObjHandle
  )
{
  return Dcm_NetGetPeriodicTxObject(perTxObjHandle)->TxBuffer;
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgTransmitTxObj()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgTransmitTxObj(
  Dcm_CfgNetPTxObjHandleOptType perTxObjHandle
  )
{
  Std_ReturnType lStdResult;
  Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj;

  pPeriodicTxObj = Dcm_NetGetPeriodicTxObject(perTxObjHandle);

  if ((DCM_NET_COMM_STATE_FLAG_TX_EN & Dcm_NetGetComStateByConnection(Dcm_NetPeriodicMsgGetConnection())) != 0u)
  {
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
    if (Dcm_NetPeriodicMsgGetDelayCntr() == 0u)
    {
      /* Retry sending */
      lStdResult = DCM_E_OK;
    }
    else
# endif
    {
      P2CONST(PduInfoType, AUTOMATIC, PDUR_APPL_DATA) pPduInfo;

      Dcm_NetPeriodicMsgDecDelayCntr();

      pPeriodicTxObj->State = DCM_NET_PERIODIC_TX_STATE_ONTX;                                                                                        /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */
      /* Note: In case the following two lines are not executed within 100ms, the timeout may occur before the message
       * was sent (only if split tasks used). This may lead to inconsistent periodic data, since the transmitted
       * message is free to be reused again while it is on transmission. The design avoiding this very rare scenario
       * will increase the software complexity unnecessarily. Entering such conditions means that the ECU is not
       * capable of holding the periodic rates too.
       */
      Dcm_NetPTxObjTimerStart(pPeriodicTxObj, Dcm_PbCfgNetConnectionInfo[Dcm_NetPeriodicMsgGetConnection()].PeriodicTxConfTimeout);                  /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */

      pPduInfo = &(pPeriodicTxObj->TxPduInfo);
      lStdResult = PduR_DcmTransmit(Dcm_NetPeriodicMsgGetTxPduIdCurrConn(perTxObjHandle), pPduInfo);                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
  }
  else
  {
    lStdResult = DCM_E_NOT_OK;
  }

  if(lStdResult != DCM_E_OK)
  {
    /* Do not retry transmission -> make a loop-back and finalize transmission */
    Dcm_NetPeriodicMsgRelease(pPeriodicTxObj);                                                                                                       /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */
  }
}
#endif

/**********************************************************************************************************************
 *  Dcm_NetIsPduInfoValid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetIsPduInfoValid(
  P2CONST(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info
  )
{
  boolean lResult;

  if(info == NULL_PTR)
  {
    lResult = FALSE;
  }
  else if( (info->SduLength  != 0u)
         &&(info->SduDataPtr == NULL_PTR) )
  {
    lResult = FALSE;
  }
  else
  {
    lResult = TRUE;
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_NetCopyRxData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetCopyRxData(
  Dcm_NetTransportObjectPtrType pTranspObj,
  P2CONST(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info,
  P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) bufferSizePtr
  )
{
  BufReq_ReturnType lResult  = BUFREQ_E_NOT_OK;                                                                                                      /* PRQA S 2981 */ /* MD_Dcm_RetVal */
  uint8             lErrorId = DCM_E_NO_ERROR;

  /* If the XxxTp (e.g. CanTp or FrTp) requests Dcm to copy any data: */
  if(info->SduLength != 0u) /* any payload now? */
  {
    /* ----- Development Error Checks -------------------------------------- */
    if (Dcm_DebugDetectError(pTranspObj->BuffPos >= pTranspObj->RxLength))
    {
      lErrorId = DCM_E_PARAM;
    }
    else if(Dcm_DebugDetectError(((PduLengthType)(pTranspObj->RxLength) - (PduLengthType)(pTranspObj->BuffPos)) < info->SduLength))
    {
      lErrorId = DCM_E_PARAM;
    }
    else
    {
      /* ----- Implementation ---------------------------------------------- */
#if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
      /* If connection has been yet canceled (if RxPath supports cancellation), do return failed copy data result */
      if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_CANCELED) != 0u)
      {
        lResult = BUFREQ_E_NOT_OK;
      }
      else
#endif
      {

        /* If the transmission is for a main-client (full request reception), do copy the data portion provided by the XxxTp */
#if (DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
        if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_BUSY) != 0u)
        {
          /* For the very first call of this function for this request reception, do copy the request head (SID and SubFunction) for later usage (i.e. for 0x3E 0x80 detection) */
          if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_COPYHEAD) != 0u)
          {
            Dcm_UtiBitOpClr(Dcm_NetTransportObjectFlagType, pTranspObj->Flags, DCM_NET_TOBJ_FLAG_COPYHEAD);  /* Toggle flag for next calls to not extract any SID/SUBSID data */ /* SBSW_DCM_PARAM_PTR_WRITE */
            Dcm_NetWriteAddBufferU8At(pTranspObj, 1, info->SduDataPtr[0]); /* copy the SID */                                                        /* PRQA S 2822 */ /* MD_Dcm_2822 */ /* SBSW_DCM_PARAM_PTR_FORWARD */
            Dcm_NetWriteAddBufferU8At(pTranspObj, 2, info->SduDataPtr[1]); /* copy the SUBSID */                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
          }
        }
        else
#endif
        {
          Dcm_PbCfgNetBufferInfoPtrType lBufferInfo;

          lBufferInfo = Dcm_NetGetBufferInfo(pTranspObj->BufferHdl);

          Dcm_UtiMemCopySafe(info->SduDataPtr
                            ,lBufferInfo->BufferPtr
                            ,pTranspObj->BuffPos
                            ,lBufferInfo->Size
                            ,info->SduLength);                                                                                                       /* SBSW_DCM_POINTER_WRITE_BUFFERINFO */
        }
        /* Update the transport object's buffer-copy-progress */
        pTranspObj->BuffPos += (Dcm_CfgNetBufferSizeMemType)(info->SduLength);                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */

        /* Report the remaining available DCM buffer size to the XxxTp */
        *bufferSizePtr = (PduLengthType)(pTranspObj->RxLength) - (PduLengthType)(pTranspObj->BuffPos);                                               /* SBSW_DCM_PARAM_PTR_WRITE */
        lResult = BUFREQ_OK;
      }
    }
    /* Otherwise if connection has been canceled, return negative result to signal the XxxTp to abort the transmission (if RxPath supports cancellation) */
  }
  else
  {
    /* Otherwise, the XxxTp requests Dcm only to report the available buffer size  */
    *bufferSizePtr = (PduLengthType)(pTranspObj->RxLength) - (PduLengthType)(pTranspObj->BuffPos); /* Notify lower layer about available buffer space */ /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = BUFREQ_OK;
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_COPYRXDATA, lErrorId);

  return lResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_NetTpRxIndication()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpRxIndication(
  PduIdType rxPduId,
  Std_ReturnType result
  )
{
  Dcm_NetTransportObjectPtrType pTranspObj;
  BufReq_ReturnType             lBufReqResult;
  lBufReqResult = Dcm_NetGetTranspObjOfConnection(Dcm_NetGetConnHdlOfRxPduId(rxPduId), &pTranspObj);                                                 /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_POINTER_FORWARD_STACK */

  /* If no transport object has been associated with this connection yet, do ignore this indication */
  if(lBufReqResult == BUFREQ_OK)
  {
    /* Otherwise, if the transport object is determined to belong to the expected request, that means: */
    if( (pTranspObj->State == DCM_NET_TOBJ_STATE_ONRX) /* expected state for Rx indication? */
      &&(rxPduId == pTranspObj->RxPduId) ) /* Consider also any nested request on different TP connection but from the same tester! */
    {
      if(result != DCM_NET_ARENV_NTFRSLT_OK)
      {
        Dcm_NetTpRxIndicationNotOk(pTranspObj);                                                                                                      /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */
      }
      else
      {
        Dcm_NetTpRxIndicationOk(pTranspObj);                                                                                                         /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */
      }
    }/* Otherwise, just ignore this call since this API call is most probably due to a (concurrent request (i.e. 0x3E 0x80) from the same tester) OR
      * (indication of unexpected connection) */
  }
}

/**********************************************************************************************************************
 *  Dcm_NetCopyLinearTxData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetCopyLinearTxData(
  Dcm_NetTransportObjectPtrType pTranspObj,
  P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info ,                                                                                                /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) availableDataPtr
  )
{
  BufReq_ReturnType lResult  = BUFREQ_E_NOT_OK;                                                                                                      /* PRQA S 2981 */ /* MD_Dcm_RetVal */
  uint8             lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError( (info->SduLength != 0u)
                         &&(pTranspObj->BuffPos >= pTranspObj->BuffInfo.SduLength) ))
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(Dcm_DebugDetectError((PduLengthType)(pTranspObj->BuffInfo.SduLength - pTranspObj->BuffPos) < info->SduLength))
  {
    lErrorId = DCM_E_PARAM;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    /* Copy requested amount of data to the XxxTp */
    Dcm_UtiMemCopySafe(&(pTranspObj->BuffInfo.SduDataPtr[pTranspObj->BuffPos])
                      ,info->SduDataPtr
                      ,0u
                      ,info->SduLength
                      ,info->SduLength);                                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
    /* Update Tx-buffer read progress */
    pTranspObj->BuffPos += (Dcm_CfgNetBufferSizeMemType)(info->SduLength);                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */

    /* Report remaining amount of data in the Tx-buffer */
    *availableDataPtr = (PduLengthType)(pTranspObj->BuffInfo.SduLength - pTranspObj->BuffPos);                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = BUFREQ_OK;
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_COPYTXDATA, lErrorId);

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_NetCopyTxData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetCopyTxData(
  Dcm_NetTransportObjectPtrType pTranspObj,
  P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info ,                                                                                                /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) availableDataPtr
  )
{
  BufReq_ReturnType lResult;

  if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_CANCELED) != 0u)
  {
    lResult = BUFREQ_E_NOT_OK;
  }
  else
  {
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
    if(pTranspObj->ResType == DCM_NET_TOBJ_RESTYPE_PAGED)
    {
      lResult = Dcm_PagedBufferCopyData(pTranspObj, info, availableDataPtr);                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
#endif
    {
      lResult = Dcm_NetCopyLinearTxData(pTranspObj, info, availableDataPtr);                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
  }

  return lResult;
}
/**********************************************************************************************************************
 *  Dcm_StateInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_StateInit(
  void
  )
{
  Dcm_SingletonContext.StateMgr.Preconditions.Session  = DCM_STATE_VALUE_SESSION_INIT;
#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
  Dcm_SingletonContext.StateMgr.Preconditions.Security = DCM_STATE_VALUE_SECURITY_INIT;
#endif
  Dcm_StateSyncPendingSession();
}

/**********************************************************************************************************************
 *  Dcm_StateExecOnStateChangeFunc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_StateExecOnStateChangeFunc(
  Dcm_CfgStateNotificationInfoPtrType notifList,                                                                                                     /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  uint8 formerStateId,
  uint8 newStateId
  )
{
  Dcm_CfgStateNotificationInfoPtrType lNotifList = notifList;
  /* Iterate over all with the diagnostic state group state change related notifications, as long as the EndOfList marker is not reached */
  while (lNotifList->OnChgFunc != NULL_PTR)
  {
    /* Invoke the configured notification function */
    lNotifList->OnChgFunc(formerStateId, newStateId);                                                                                                /* SBSW_DCM_PARAM_FUNCPTR_CALL */
    Dcm_UtiNextItemByPtr(lNotifList, 1u);/* take next function */
  }
}

#if (DCM_STATE_SECURITY_LOOKUP_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateFindStateIndexFromSecLevel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(sint8_least, DCM_CODE) Dcm_StateFindStateIndexFromSecLevel(
  Dcm_SecLevelType secLevel
  )
{
  sint8_least lResult;

  /* If "locked" level: */
  if(secLevel == DCM_SEC_LEV_LOCKED)
  {
    /* Return the only possible index - 0 */
    lResult = 0;
  }
  else
  {
    /* Otherwise locate the index of the security level value in the security info table */
    uint8_least lSecLvlIter;

    lResult = -1;
    for(lSecLvlIter = 0; lSecLvlIter < DCM_STATE_SECURITY_NUM_LEVELS; ++lSecLvlIter)
    {
      if (Dcm_CfgStateSecurityInfo[lSecLvlIter].Value == secLevel)
      {
        /* Found the correct index into the table - compensate zero offset for locked level */
        lResult = (sint8_least)((sint16_least)lSecLvlIter + 1);
        break;
      }
    }
    /* If the security level is not found, return -1 */
  }
  return lResult;
}
#endif

#if ((DCM_STATE_SECURITY_FIXED_BYTES_ENABLED == STD_ON)  &&  (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON))
/**********************************************************************************************************************
 *  Dcm_StateVsgGetSecurityFixedByteStateIdx()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_StateVsgGetSecurityFixedByteStateIdx(
  P2VAR(sint32_least, AUTOMATIC, DCM_APPL_DATA) pStateIndex
  )
{
  Std_ReturnType  lStdResult;
  Dcm_VsgSizeType lNumberOfFixedBytes;
  sint32_least    lRefToVsg;

  lRefToVsg = (sint32) Dcm_StateGetVsgMaskInfoIdx(*pStateIndex);
  lStdResult = DCM_E_NOT_OK;

  /* If there is any Securtiy Level with more than 1 security fixed byte configured */
  lNumberOfFixedBytes = Dcm_StateGetNumberOfVsgs((uint16)(*pStateIndex));                                                                            /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */

  /* Iterate over all securtiy fixed bytes that are assigned to referenced security level */
  /* If lNumberOfFixedBytes is 0 -> no security fixed byte is configured for securtiy level */
  for (; lNumberOfFixedBytes > 0u; --lNumberOfFixedBytes)
  {
    if (Dcm_VarMgrIsEnabledInActiveVariants(Dcm_CfgStateVsgMaskSecurityFixedByte[lRefToVsg]))                                                        /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
    {
      *pStateIndex = lRefToVsg;                                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_OK;
      break;
    }

    ++lRefToVsg;                                                                                                                                     /* PRQA S 2983 */ /* MD_Dcm_Redundant_2983 */
  }

  return lStdResult;
}
#endif

#if (DCM_STATE_SECURITY_FIXED_BYTES_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateGetSecurityLevelFixedBytes()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_StateGetSecurityLevelFixedBytes(
  Dcm_SecLevelType secLevel,
  P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) fixedBytes,
  P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) bufferSize
  )
{
  Std_ReturnType  lResult;
  sint32_least    lStateIdx;

  lStateIdx = Dcm_StateFindStateIndexFromSecLevel(secLevel);
  if (lStateIdx <= 0)
  {
    /* Locked, or unsupported security level */
    lResult = DCM_E_NOT_OK;
  }
  else
  {
    uint8 lFixedByteSize;
    --lStateIdx; /* norm to zero index (excluded locked state offset) */

# if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
    lResult = Dcm_StateVsgGetSecurityFixedByteStateIdx(&lStateIdx);                                                                                  /* SBSW_DCM_POINTER_FORWARD_STACK */
    if (lResult == DCM_E_NOT_OK)
    {
      lFixedByteSize = 0;
      lResult = E_OK;
    }
    else
# endif
    {
      lFixedByteSize = (uint8)(Dcm_CfgStateSecurityFixedByteInfo[lStateIdx + 1]
                             - Dcm_CfgStateSecurityFixedByteInfo[lStateIdx + 0]);                                                                    /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */
      if (lFixedByteSize > *bufferSize)
      {
        lResult = DCM_E_BUFFERTOOLOW;
      }
      else
      {
        Dcm_UtiMemCopySafe(&Dcm_CfgStateSecurityFixedBytes[Dcm_CfgStateSecurityFixedByteInfo[lStateIdx]]
                          ,fixedBytes
                          ,0u
                          ,*bufferSize
                          ,lFixedByteSize);                                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
        lResult = E_OK;
      }
    }
    *bufferSize = lFixedByteSize;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  return lResult;
}
#endif

#if (DCM_STATE_NOTIFY_SVC_PRO_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateNotifyServiceProcessors()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_StateNotifyServiceProcessors(
  void
  )
{
  /* now process session/security state updates:
    - on any session transition: security is always changed
    - on security state transition: security is always changed
  */
# if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc27OnStateChanged();
# endif
# if (DCM_DIDMGR_DYNDID_CLR_ON_STATE_CHG_ENABLED == STD_ON)
  Dcm_Svc2COnStateChanged();
# endif
# if (DCM_DIDMGR_PERIODICDID_CLR_ON_STATE_CHG_ENABLED == STD_ON)
  Dcm_Svc2AOnStateChanged();
# endif
# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
  Dcm_Svc2FOnStateChanged();
# endif
}
#endif
/**********************************************************************************************************************
 *  Dcm_TmrGetTimerInfo()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_TmrTimerInfoPtrType, DCM_CODE) Dcm_TmrGetTimerInfo(
  Dcm_TmrTimerIdOptType index
  )
{
  Dcm_TmrTimerInfoPtrType lResult;

  if(Dcm_DebugDetectRuntimeError(index >= DCM_TMR_NUM_TIMERS_CASTED))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    lResult = &Dcm_TmrTimerInfo[0];
  }
  else
  {
    lResult = &Dcm_TmrTimerInfo[index];
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_TmrGetTimerContext()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_TmrTimerContextPtrType, DCM_CODE) Dcm_TmrGetTimerContext(
  Dcm_TmrTimerIdOptType index
  )
{
  Dcm_TmrTimerContextPtrType lResult;

  if(Dcm_DebugDetectRuntimeError(index >= DCM_TMR_NUM_TIMER_CONTEXTS_CASTED))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    lResult = &Dcm_SingletonContext.TimerMgr.TimerContext[0];
  }
  else
  {
    lResult = &Dcm_SingletonContext.TimerMgr.TimerContext[index];
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_TmrInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TmrInit(
  void
  )
{
  Dcm_TmrTimerIdMemType  lTimerInfoIter;
  Dcm_TmrTimerIdOptType  lTimerContextIter;

  lTimerInfoIter    = DCM_TMR_NUM_TIMERS_CASTED - 1u;
  lTimerContextIter = DCM_TMR_NUM_TIMER_CONTEXTS_CASTED;

  do
  {
    --lTimerContextIter;

    Dcm_SingletonContext.TimerMgr.TimerContext[lTimerContextIter].TimerInfoRef = lTimerInfoIter;                                                     /* SBSW_DCM_LOOP */

#if (DCM_MULTI_THREAD_ENABLED == STD_ON)
    if(Dcm_TmrTimerInfo[lTimerInfoIter].TimerContextRef == lTimerContextIter)
#endif
    {
      --lTimerInfoIter;
    }
  }
  while(lTimerContextIter != 0u);

  Dcm_SingletonContext.TimerMgr.ControlMask = 0; /* mark all timers as not running */
}

/**********************************************************************************************************************
 *  Dcm_DiagSetNewReqBaseToCurProgress()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagSetNewReqBaseToCurProgress(
  Dcm_MsgContextPtrType pMsgContext
  )
{
  if (Dcm_DebugDetectRuntimeError(pMsgContext->reqIndex >= pMsgContext->reqBufSize))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
  {
    pMsgContext->reqBufSize -= pMsgContext->reqIndex;                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_UtiNextItemByPtr(pMsgContext->reqData, pMsgContext->reqIndex);                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
    pMsgContext->reqIndex = 0;                                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
  }
}

/**********************************************************************************************************************
 *  Dcm_DiagSetQueuedTranspObj()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagSetQueuedTranspObj(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NetTransportObjectPtrType pTranspObj                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  pContext->Diag.QueuedSet.TObjHdl = pTranspObj->Handle;                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
#if (DCM_DIAG_GARB_COL_ENABLED == STD_ON)
  Dcm_UtiBitOpSet(Dcm_TskTaskEvMemType                                                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
                 ,pContext->Diag.QueuedSet.QueuedTObjects
                 ,Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, pTranspObj->Handle));                                                                 /* PRQA S 3453 */ /* MD_MSR_FctLikeMacro */
#endif
}

/**********************************************************************************************************************
 *  Dcm_DiagSetNewResBaseToCurProgress()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagSetNewResBaseToCurProgress(
  Dcm_MsgContextPtrType pMsgContext
  )
{
  if (Dcm_DebugDetectRuntimeError(pMsgContext->resIndex >= pMsgContext->resBufSize))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
  {
    pMsgContext->resBufSize -= pMsgContext->resIndex;                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
    pMsgContext->resMaxDataLen = pMsgContext->resBufSize;                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    pMsgContext->resProtHeadLen += pMsgContext->resDataLen;                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
    pMsgContext->resDataLen = 0;                                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_UtiNextItemByPtr(pMsgContext->resData, pMsgContext->resIndex);                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
    pMsgContext->resIndex = 0;                                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
  }
}

/**********************************************************************************************************************
 *  Dcm_DiagGetPostProcessorFunc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_DiagSvcConfirmationFuncType, DCM_CODE) Dcm_DiagGetPostProcessorFunc(
  uint8_least index
  )
{
  Dcm_DiagSvcConfirmationFuncType lResult;

  if(Dcm_DebugDetectRuntimeError(index >= DCM_CFGDIAGSVCPOSTPROCESSORS_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    lResult = Dcm_CfgDiagSvcPostProcessors[0];
  }
  else
  {
    lResult = Dcm_CfgDiagSvcPostProcessors[index];
  }

  return lResult;
}

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagGetUpdateFunc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_DiagSvcUpdateFuncType, DCM_CODE) Dcm_DiagGetUpdateFunc(
  uint8_least index
  )
{
  Dcm_DiagSvcUpdateFuncType lResult;

  if(Dcm_DebugDetectRuntimeError(index >= DCM_CFGDIAGSVCUPDATERS_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    lResult = Dcm_CfgDiagSvcUpdaters[0];
  }
  else
  {
    lResult = Dcm_CfgDiagSvcUpdaters[index];
  }

  return lResult;
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagInit(
  Dcm_ConfigPtrType configPtr
  )
{
  DCM_IGNORE_UNREF_PARAM(configPtr);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

#if (DCM_VARMGR_MODE_POSTBUILD_ANY_ENABLED == STD_ON) && (DCM_VARMGR_SUPPORT_ENABLED == STD_ON)
  Dcm_SingletonContext.Diag.Svc2ProtocolMap = configPtr->BridgeVariant.Svc2ProtocolMap;
#endif
#if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON) && (DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
  Dcm_SingletonContext.Diag.RomVariant = configPtr->RomVariant->DiagRom;
#endif

#if (DCM_STATE_SECURITY_BYPASS_ENABLED == STD_ON)
  Dcm_SingletonContext.Diag.IsSecurityBypass = FALSE;
#endif

  {
    Dcm_ThreadIdOptType lThreadIter;
    for(lThreadIter = 0; lThreadIter < DCM_NUM_THREADS; ++lThreadIter)
    {
      Dcm_ContextPtrType pContext = Dcm_GetThreadContext(lThreadIter);

      pContext->ThreadId = (Dcm_ThreadIdMemType)lThreadIter;                                                                                         /* SBSW_DCM_POINTER_INIT_MESSAGE_CONTEXT */

      /*
      * Initialize pMsgContext so that it points always to a valid buffer.
      * From now on the buffer information can only be changed via Dcm_DiagInitiateServiceProcessing().
      * So in case that Dcm_DiagInitiateServiceProcessing() was called, but for a different (wrong) thread,
      * DCM still never writes to an invalid memory locations due to this initialization.
      */
      Dcm_DiagInitMsgContextBufferInfo(&(pContext->Diag.MsgContext), 0u);                                                                            /* SBSW_DCM_POINTER_INIT_MESSAGE_CONTEXT */
    }
  }

  /* Initialize all processors */
  {
    uint8_least lIter;

    for(lIter = 0u; Dcm_CfgDiagSvcInitializers[lIter] != NULL_PTR; ++lIter)                                                                          /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
    {
      Dcm_CfgDiagSvcInitializers[lIter]();                                                                                                           /* SBSW_DCM_CALL_FUNCPTR_TERMINATED_LIST */
    }
  }

  {
    Dcm_ThreadIdOptType lThreadIter;

    /* Initialize all P2 Timers */
    for(lThreadIter = 0u; lThreadIter < DCM_NUM_THREADS; ++lThreadIter)
    {
      Dcm_ContextPtrType pContext = Dcm_GetThreadContext(lThreadIter);

      pContext->Diag.QueuedSet.Flags = DCM_DIAG_QUEUE_FLAG_NONE;                                                                                     /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
#if (DCM_DIAG_GARB_COL_ENABLED == STD_ON)
      pContext->Diag.QueuedSet.QueuedTObjects = 0;                                                                                                   /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
#endif
      pContext->Diag.State = DCM_DIAG_STATE_IDLE;                                                                                                    /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */

      Dcm_DiagSetP2Timings(0, 0, pContext->ThreadId);
    }
  }

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
  Dcm_SingletonContext.Network.RxAllowed = FALSE;
  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_RECOVERY, DCM_TSK_EV_DIAG_RECOVERY_GETSTATE);
#endif

#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
  /* Delegate to the first task activation */
  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_FBLRES, DCM_TSK_EV_DIAG_FBLRES_SEND);
#endif
}

#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagPutStartUpFblResBuffer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagPutStartUpFblResBuffer(
  uint8_least index,
  Dcm_MsgItemType value
  )
{
  if(Dcm_DebugDetectRuntimeError(index >= DCM_DIAG_START_UP_FBL_RES_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
  {
    Dcm_SingletonContext.Diag.StartUpFbl.ResBuffer[index] = value;                                                                                   /* SBSW_DCM_POINTER_WRITE_START_UP_FBL_RES_BUFFER */
  }
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagExecConfirmationFunc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagExecConfirmationFunc(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_CfgDiagNotificationInfoPtrType notifList,                                                                                                      /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_ConfirmationStatusType confStatus
  )
{
  uint16_least lIter;

  for(lIter = 0u; notifList[lIter].ConfFunc != NULL_PTR; ++lIter)                                                                                    /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
  {
    (void)notifList[lIter].ConfFunc(pContext->Diag.PostProcessorContext.Sid
                                   ,pContext->Diag.PostProcessorContext.ReqType
                                   ,pContext->Diag.PostProcessorContext.SrcAddr
                                   ,confStatus);                                                                                                     /* SBSW_DCM_CALL_FUNCPTR_TERMINATED_LIST */
  }
}

/**********************************************************************************************************************
 *  Dcm_DiagGetPostProcessResult()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_ConfirmationStatusType, DCM_CODE) Dcm_DiagGetPostProcessResult(
  Dcm_ContextPtrType pContext                                                                                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_ConfirmationStatusType confStatus  = DCM_DIAG_RES_ANY_OK;

  if(pContext->Diag.TxStatus != DCM_E_OK)                                                                                                            /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
  {
    /* Set Tx error flag */
    confStatus |= DCM_DIAG_RES_ANY_NOT_OK;
  }

  if(pContext->Diag.ErrorRegister != DCM_E_POSITIVERESPONSE)
  {
    /* Set neg response flag */
    confStatus |= DCM_DIAG_RES_NEG_ANY;
  }
  return confStatus;
}

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagGetRecoverySignature()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(uint32, DCM_CODE) Dcm_DiagGetRecoverySignature(
  void
  )
{
  uint32 lResult;

  lResult = Dcm_PbCfgNetNumComMChannels;

# if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
  lResult |= Dcm_UtiMake32Bit(0u, 0u, Dcm_PbCfgNetNumAllComMChannels, 0u);                                                                           /* PRQA S 2985, 2986 */ /* MD_Dcm_Redundant_2985, MD_Dcm_Redundant_2986 */
# endif

  lResult |= Dcm_UtiMake32Bit(Dcm_UtiGetHiNibble(Dcm_PbCfgNetNumProtocols) /* Since at most 32 protocols are allowed the high nibble never exceeds 1 bit */ /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */
                             ,Dcm_UtiGetLoNibble(Dcm_PbCfgNetNumProtocols)
                             ,0u
                             ,0u);

  lResult |= Dcm_UtiGetBitFromIndex(uint32, 21u);

# if (DCM_STATE_SECURITY_ENABLED == STD_ON)
  lResult |= Dcm_UtiGetBitFromIndex(uint32, 22u);
# endif

# if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
  lResult |= Dcm_UtiGetBitFromIndex(uint32, 23u);
# endif

# if (DCM_SVC_85_DTC_GRP_ENABLED == STD_ON)
  lResult |= Dcm_UtiGetBitFromIndex(uint32, 24u);
# endif

# if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
  lResult |= Dcm_UtiGetBitFromIndex(uint32, 25u);
# endif

  lResult |= Dcm_UtiMake32Bit(0x08, 0x00, 0u, 0u);

  lResult |= Dcm_UtiMake32Bit(0xA0, 0u, 0u, 0u);

  return lResult;
}
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagProvideRecoveryStates()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagProvideRecoveryStates(
  P2VAR(Dcm_RecoveryInfoType, AUTOMATIC, DCM_APPL_DATA) RecoveryInfo
  )
{
  /* Retrieve ComM channel states */
  Dcm_CfgNetNetIdRefOptType lNetHandleIter;
  Dcm_RecoveryInfoComMChannelStatePtrType pChannelState;
  for(lNetHandleIter = 0; lNetHandleIter < Dcm_PbCfgNetNumComMChannels; ++lNetHandleIter)
  {
    pChannelState = Dcm_DiagGetRecoveryInfoComMChannelState(RecoveryInfo, lNetHandleIter);                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
    *pChannelState = (boolean)(Dcm_PbRamNetComMContext[lNetHandleIter].RegisteredNetworks != 0u);                                                    /* SBSW_DCM_POINTER_WRITE_RECOVERYINFOCOMMCHANNELSTATE */ /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
  }

  /* Retrieve session state */
  RecoveryInfo->SessionLevel = Dcm_UtiGetBitPosition(Dcm_StateGetSession());                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */

  /* Retrieve session connection and tester */
  RecoveryInfo->SessionConnection = Dcm_NetGetSessionConnection();                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
  RecoveryInfo->SessionClientSrcAddr = Dcm_NetGetSessionClientSrcAddr();                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */

  /* Retrieve active protocol */
  RecoveryInfo->ActiveProtocol = Dcm_NetGetProtIdOfActiveProtocol();                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */

  /* Retrieve security state */
# if (DCM_STATE_SECURITY_ENABLED == STD_ON)
#  if (DCM_STATE_SECURITY_BYPASS_ENABLED == STD_ON)
  if(Dcm_SingletonContext.Diag.IsSecurityBypass == TRUE)
  {
    /* Store locked security */
    RecoveryInfo->SecurityLevel = 0u;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
#  endif
  {
    RecoveryInfo->SecurityLevel = Dcm_UtiGetBitPosition(Dcm_StateGetSecurity());                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
  }
# endif

  /* Retrieve DTC settings state */
# if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
#  if (DCM_SVC_85_DTC_GRP_ENABLED == STD_ON)
  RecoveryInfo->ControlDTCSettingDTCGroup = Dcm_ModeGetControlDtcSettingGroup();                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
#  endif
  RecoveryInfo->ControlDTCSettingDisabled = (boolean)(Dcm_ModeGetControlDtcSettingMode() == RTE_MODE_DcmControlDtcSetting_DISABLEDTCSETTING);        /* SBSW_DCM_PARAM_PTR_WRITE */ /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
# endif

  /* Retrieve communication control state */
# if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
  {
    uint8_least lChannelIter;
    Dcm_RecoveryInfoCommControlStatePtrType pControlState;
    for(lChannelIter = 0; lChannelIter < Dcm_PbCfgNetNumAllComMChannels; ++lChannelIter)
    {
      pControlState = Dcm_DiagGetRecoveryInfoCommControlState(RecoveryInfo, lChannelIter);                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
      *pControlState = Dcm_ModeGetCommControlState(lChannelIter);                                                                                    /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_POINTER_WRITE_RECOVERYINFOCOMMCONTROLSTATE */
    }
  }
# endif

  RecoveryInfo->Signature = Dcm_DiagGetRecoverySignature();                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagProcessRecoveryInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagProcessRecoveryInfo(
  P2CONST(Dcm_RecoveryInfoType, AUTOMATIC, DCM_VAR_NOINIT) RecoveryInfo,
  Dcm_OpStatusType opStatus
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;

  if (opStatus == DCM_INITIAL)
  {
    /* If a non-default session was active: */
    if(RecoveryInfo->SessionLevel != 0u)
    {
      /* Activate ComM channels */
      Dcm_CfgNetNetIdRefOptType lNetHandleIter;
      for(lNetHandleIter = 0; lNetHandleIter < Dcm_PbCfgNetNumComMChannels; ++lNetHandleIter)
      {
        if(RecoveryInfo->ComMChannelState[lNetHandleIter] == TRUE)
        {
          ComM_DCM_ActiveDiagnostic(Dcm_PbCfgNetAllComMChannelMap[Dcm_PbCfgNetConnComMChannelMap[lNetHandleIter]]);
        }
      }

      /* Recover session state */
      Dcm_StateSetSession(RecoveryInfo->SessionLevel);

      /* Recover active protocol */
      Dcm_SingletonContext.Network.ActiveProtocol = RecoveryInfo->ActiveProtocol;

      /* Update P2 timings at once */
      Dcm_DiagSetP2Timings(RecoveryInfo->SessionLevel, Dcm_NetGetProtIdOfActiveProtocol(), DCM_THREAD_ID_BASIC);

      /* Recover session connection */
      Dcm_NetSetSessionConnection(RecoveryInfo->SessionConnection);
      Dcm_NetSetSessionClientSrcAddr(RecoveryInfo->SessionClientSrcAddr);

      Dcm_TmrStartTimer(DCM_TMR_ID_S3, DCM_DIAG_TIME_S3);
    }

# if (DCM_STATE_SECURITY_ENABLED == STD_ON)
    /* If any security level was unlocked: */
    if(RecoveryInfo->SecurityLevel != 0u)
    {
      /* Recover security state */
      Dcm_StateSetSecurity(RecoveryInfo->SecurityLevel);
    }
# endif
  }

# if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
  /* If DTC settings were disabled: */
  if(RecoveryInfo->ControlDTCSettingDisabled == TRUE)
  {
    /* Recover DTC updating state */
    lStdResult = Dcm_Svc85DisableDtcSetting(
#  if (DCM_SVC_85_DTC_GRP_ENABLED == STD_ON)
                                            RecoveryInfo->ControlDTCSettingDTCGroup
#  else
                                            DEM_DTC_GROUP_ALL_DTCS
#  endif
                                           ,Dcm_NetGetProtObjOfProtId(Dcm_NetGetProtIdOfActiveProtocol())->DemClientId                               /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */
                                           );

  }
# endif

# if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
#  if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
  /* If no DTC settings update was necessary or it succeeded */
  if (lStdResult == DCM_E_OK)
#  endif
  /* Recover communication control states */
  {
    uint8_least lChannelIter;
    for(lChannelIter = 0; lChannelIter < Dcm_PbCfgNetNumAllComMChannels; ++lChannelIter)
    {
      if(RecoveryInfo->CommControlState[lChannelIter] != DCM_ENABLE_RX_TX_NORM_NM)
      {
        Dcm_ModeSwitchCommControl(lChannelIter, RecoveryInfo->CommControlState[lChannelIter]);
      }
    }
  }
# endif
  return lStdResult;
}
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagSafeProcessRecoveryInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagSafeProcessRecoveryInfo(
  P2CONST(Dcm_RecoveryInfoType, AUTOMATIC, DCM_VAR_NOINIT) RecoveryInfo,
  Dcm_OpStatusType opStatus
  )
{
  uint8          lErrorId   = DCM_E_NO_ERROR;
  Std_ReturnType lStdResult = DCM_E_NOT_OK;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(RecoveryInfo->Signature != Dcm_DiagGetRecoverySignature()))
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(Dcm_DebugDetectError(RecoveryInfo->SessionLevel >= DCM_STATE_NUM_SESSION))
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(Dcm_DebugDetectError( (RecoveryInfo->SessionLevel != 0u) /* non-default session */
                              &&(RecoveryInfo->ActiveProtocol >= DCM_NET_INVALID_PROTID) ))
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(Dcm_DebugDetectError( (RecoveryInfo->SessionLevel != 0u) /* non-default session */
                              &&(RecoveryInfo->SessionConnection >= DCM_NET_INVALID_CONNHDL) ))
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(Dcm_DebugDetectError( (RecoveryInfo->SessionLevel != 0u) /* non-default session */
                              &&(Dcm_NetGetProtIdOfConnection(RecoveryInfo->SessionConnection) != RecoveryInfo->ActiveProtocol) ))
  {
    lErrorId = DCM_E_PARAM;
  }
  else
# if (DCM_STATE_SECURITY_ENABLED == STD_ON)
  if(Dcm_DebugDetectError(RecoveryInfo->SecurityLevel >= DCM_STATE_NUM_SECURITY))
  {
    lErrorId = DCM_E_PARAM;
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    lStdResult = Dcm_DiagProcessRecoveryInfo(RecoveryInfo, opStatus);                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_GETRECOVERYSTATES, lErrorId);

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if (DCM_DIAG_SPECIFIC_CAUSE_CODE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagSetSpecificCauseCode()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagSetSpecificCauseCode(
  Dcm_SpecificCauseCodeType specificCauseCode
  )
{
  if(Dcm_SingletonContext.Diag.CauseCodeContext.SendCauseCode == FALSE)
  {
    Dcm_SingletonContext.Diag.CauseCodeContext.CauseCode = specificCauseCode;
    Dcm_SingletonContext.Diag.CauseCodeContext.SendCauseCode = TRUE;
  }
}
#endif

#if (DCM_MULTI_THREAD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagIsSessionChangeAllowed()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagIsSessionChangeAllowed(
  Dcm_ContextPtrType pContext                                                                                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;

  /* If a non-default session will be active: */
  if((DCM_STATE_VALUE_SESSION_INIT & Dcm_StateGetPendingSession()) == 0u)
  {
    Dcm_ThreadIdOptType lThreadIter;

    for(lThreadIter = 0u; lThreadIter < DCM_NUM_THREADS; ++lThreadIter)
    {
      /* Skip own thread */
      if(lThreadIter != pContext->ThreadId)
      {
        Dcm_ContextConstPtrType otherContext = Dcm_GetThreadContext(lThreadIter);

        if( (otherContext->Diag.State != DCM_DIAG_STATE_IDLE)
          ||(otherContext->Diag.QueuedSet.Flags != DCM_DIAG_QUEUE_FLAG_NONE) )
        {
          lStdResult = DCM_E_NOT_OK;
        }
      }
    }
  }

  return lStdResult;
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoCancelProcCancelOpenJobs()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoCancelProcCancelOpenJobs(
  Dcm_ContextPtrType pContext
  )
{
  /* #10 If any diagnostic job still open (PagedBuffer transfers are not part of them), call the job handle one last time with DCM_CANCEL signal */
  if(pContext->Diag.State == DCM_DIAG_STATE_PROCESS)
  {
    Dcm_NegativeResponseCodeType lNrc = DCM_E_PANIC_NRC; /* to avoid compiler warnings */
    pContext->Repeater.OpStatus = DCM_CANCEL;/* Override any other opStatus values up to now */                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
    (void)Dcm_RepeaterExecute(pContext, &lNrc);/* signal cancellation */                                                                             /* SBSW_DCM_COMB_PTR_FORWARD */
    Dcm_SetNegResponse(lNrc, pContext->ThreadId); /* register negative result */
  }

  /* #20 If any diagnostic job still open (including PagedBuffer transfers) or already on transmission: */
  if(((DCM_DIAG_STATE_PROCESS | DCM_DIAG_STATE_ON_TX) & pContext->Diag.State) != 0u) /* any open diagnostic job? (optimize interrupt lock times) */
  {
    /* Immediately cancel any ongoing transmission (RCR-RP, final response (RoE or external)) */
    Dcm_UtiEnterCriticalSection();
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    if(((DCM_DIAG_STATE_PROCESS | DCM_DIAG_STATE_ON_TX) & pContext->Diag.State) != 0u) /* STILL any open diagnostic job -> diagnostic transport object is still in use -> try cancel it */ /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY TX */
    {
      Dcm_NetTransportObjectPtrType pTranspObj;

      pTranspObj = Dcm_DiagGetTranspObj(pContext);

      /* #30 If any USDT response transmission is still ongoing (incl. RCR-RPs): */
      if(pTranspObj->State == DCM_NET_TOBJ_STATE_ONTX)
      {
        pTranspObj->Flags |= DCM_NET_TOBJ_FLAG_CANCELED;/* isolate this connection */                                                                /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
        /* Short cut to speed up the service processing finalization - RCR-RP responses will just end with the cancellation below */
        Dcm_DiagTxFinalization(pTranspObj, DCM_E_NOT_OK);                                                                                            /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */

        /* Try cancel any ongoing response. The return value does not matter:
          * OK -> there will be a confirmation for this cancellation
          * N_OK -> request rejected, but there will be a confirmation due to the ongoing transmission */
        (void)PduR_DcmCancelTransmit(Dcm_PbCfgNetConnectionInfo[pTranspObj->ConnHdl].TxPduIdMain);
        /* Any response (final, RCR-RP, etc) will just end with releasing the connection assigned to the tObject! No confirmation post-processing will be performed! */
      }
      /* Otherwise, if there is no USDT response initiated yet, just notify the diagnostic kernel for the transmission finalization to accomplish the diagnostic job cycle */
      else if (pTranspObj->State == DCM_NET_TOBJ_STATE_READY)                                                                                        /* COV_DCM_RTM_UNREACHABLE TX */
      {
        /* no transmission yet started -> just loop back the diagnostic confirmation immediately. Note: no other Tx-confirmation type is expected here */
        Dcm_DiagTxFinalization(pTranspObj, DCM_E_NOT_OK);                                                                                            /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      }
      else
      {
        /* Otherwise, unexpected transport object state reached (inconsistent in the context of diagnostic kernel state, showing a job is still in progress) */
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);
      }
    }
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiLeaveCriticalSection();
  }
  /* Otherwise, diagnostic kernel is in "post processing" or "idle" state and they are to be handled in a normal way
         Note: This case can be reached since the prioritization just fires a cancellation event, disregarding any internal states of the diagnostic kernel */
}                                                                                                                                                    /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoCancelProcReviveKilledTasks()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoCancelProcReviveKilledTasks(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  DCM_IGNORE_UNREF_PARAM(pEventContext);                                                                                                             /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* All cancellation activities are done now - revive all killed tasks to allow normal processing of the newly received diagnostic job (the one caused the interruption) */
  /* Look ahead: Any nested kill job received? If so, no task revival! */
  if((DCM_TSK_EV_DIAG_WORK_KILL_JOBS & Dcm_TskGetEventByThread(DCM_TSK_ID_DIAG_WORK, pContext->ThreadId)) == 0u)                                     /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY TX */
  {
#if (DCM_DIAG_GARB_COL_ENABLED == STD_ON)
    Dcm_TskTaskEvOptType queuedTObjBitSet = 0; /* nothing to clean (for now) */
#endif
    Dcm_UtiEnterCriticalSection();
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
     /* STILL no nested kill job received? */
    if((DCM_TSK_EV_DIAG_WORK_KILL_JOBS & Dcm_TskGetEventByThread(DCM_TSK_ID_DIAG_WORK, pContext->ThreadId)) == 0u)                                   /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY TX */
    {
      Dcm_TskReviveAllTasks();/* from now on enable tasks for working */
#if (DCM_DIAG_GARB_COL_ENABLED == STD_ON)
      queuedTObjBitSet = pContext->Diag.QueuedSet.QueuedTObjects;

# if (DCM_MULTI_THREAD_ENABLED == STD_ON)
      /* The queued transport object is only initialized if a request was received (and not e.g. by state recovery). */
      if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_NEW_REQ))
# endif
      {
        /* Clear all except the last queued one  */
        Dcm_UtiBitOpClr(Dcm_TskTaskEvOptType, queuedTObjBitSet, Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, Dcm_DiagGetQueuedTranspObj(pContext)->Handle));
      }

      /* Remove all processed transport objects from the queue (the last queued one will be removed from the queue once transfered to the active tObject or canceled by higher prio request here again) */
      Dcm_UtiBitOpClr(Dcm_TskTaskEvMemType, pContext->Diag.QueuedSet.QueuedTObjects, queuedTObjBitSet);                                              /* SBSW_DCM_PARAM_PTR_WRITE */
#endif
    }
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiLeaveCriticalSection();
#if (DCM_DIAG_GARB_COL_ENABLED == STD_ON)
    if(queuedTObjBitSet > 0u)
    {
      /* Some connections to clean up (in background)? */
      Dcm_TskSetEventByThread(DCM_TSK_ID_DIAG_GARB_COL, (Dcm_TskTaskEvMemType)queuedTObjBitSet, pContext->ThreadId);
    }
#endif
  }
}

/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoCancelProcessing()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoCancelProcessing(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_DiagWorkerDoCancelProcCancelOpenJobs(pContext); /* Cancel open diagnostic jobs */                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* Sync with TxEnd events set above OR Tx confirmation. No ISR lock since:
   * - No Tx confirmation can occur from now on
   * - If above Tx confirmation executed -> no other changes of the state are possible!
   * - If there was already a Tx Confirmation (above code not executed) -> the task will just be re-triggered
   */
  /* If the Dcm_DiagTaskWorker() has (by finished transmission or through the above cancellation activity) already received a post-processing event: */
  if((DCM_TSK_EV_DIAG_WORK_TX_END_FINAL & Dcm_TskGetEventByThread(DCM_TSK_ID_DIAG_WORK, pContext->ThreadId)) != 0u)
  {
    Dcm_TskClrEventByThread(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_TX_END_FINAL, pContext->ThreadId);/* clear any potentially globally set Tx-end-response (from the above Tx cancellation code) */
    Dcm_TskSetLocalEvent(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_TX_END_FINAL);/* set/transfer the Tx end event */                                   /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  /* Otherwise, either no Tx-end event OR nothing to do OR it is already set in the local "ev" -> will be post-processed in next task stages */

  Dcm_DiagWorkerDoCancelProcReviveKilledTasks(pContext, pEventContext); /* Revive killed tasks */                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
}

/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoPostProcessing()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoPostProcessing(
  Dcm_ContextPtrType pContext
  )
{
  Dcm_ConfirmationStatusType   confStatus;
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
  Dcm_NegativeResponseCodeType lNrc = DCM_E_PANIC_NRC; /* to avoid compiler warnings */
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
  /* Reset any pending PB processing */
  if(Dcm_PagedBufferCancel(pContext, &lNrc) == DCM_E_NOT_OK)                                                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
  {
    Dcm_SetNegResponse(lNrc, pContext->ThreadId);/* Set NRC now to affect the post-processor confirmation status */
  }
#endif

  confStatus = Dcm_DiagGetPostProcessResult(pContext);                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
  /* First process any diagnostic service post-handler (e.g. to perform any state transitions at this stage): */
  if((DCM_DIAG_APPL_NOTIFICATION_POSTPROCESSOR & pContext->Diag.ApplNotification) != 0u)
  {
    Dcm_DiagSvcConfirmationFuncType lPostProcessorFunc;
    lPostProcessorFunc = Dcm_DiagGetPostProcessorFunc(Dcm_CfgDiagServiceInfo[pContext->Diag.SidIndex].ConfFuncRef);

    lPostProcessorFunc(pContext, confStatus);/* execute any internal service processor post-handlers */                                              /* SBSW_DCM_CALL_FUNCPTR_SVCPOSTPROCESSORS */
  }

  /* Process the application notification confirmation */
  if((DCM_DIAG_APPL_NOTIFICATION_CONFIRMATION & pContext->Diag.ApplNotification) != 0u)
  {
    Dcm_Confirmation(0, pContext->Diag.MsgContext.rxPduId, confStatus);/* notify the application about transmission end (of any service) */
  }

  /* At next process any system supplier and OEM notification (e.g. to perform any additional state transitions at this stage): */
  if((DCM_DIAG_APPL_NOTIFICATION_SYS & pContext->Diag.ApplNotification) != 0u)
  {
    Dcm_DiagExecConfirmationFunc(pContext, Dcm_CfgDiagSysNotificationInfo, confStatus);                                                              /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
  }

  if((DCM_DIAG_APPL_NOTIFICATION_OEM & pContext->Diag.ApplNotification) != 0u)
  {
    Dcm_DiagExecConfirmationFunc(pContext, Dcm_CfgDiagOemNotificationInfo, confStatus);                                                              /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
  }

#if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
  if(pContext->Diag.IsInternRequest == FALSE)/* manage ComM states only on processed requests from external clients */
#endif
  {
    /* Process here to take a potentially new session change into account */
    Dcm_NetUnRegisterComMActivity(Dcm_NetGetConnHdlOfRxPduId(pContext->Diag.MsgContext.rxPduId));                                                    /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
  }
  pContext->Diag.State = DCM_DIAG_STATE_IDLE;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */

/**********************************************************************************************************************
 *  Dcm_DiagWorkerSetDefSessionExtern()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerSetDefSessionExtern(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext
  )
{
  /* If diagnostic kernel is still busy with a diagnostic job, retry next task activation if there is no other such request yet */
  if(pContext->Diag.State != DCM_DIAG_STATE_IDLE)
  {
    if(!Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_INT_SET2DEF))                                                                 /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY XX */
    {
      Dcm_TskSetLocalEvent(pEventContext->PostEv, DCM_TSK_EV_DIAG_WORK_EXT_SET2DEF); /* retry later again */                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }
  else
  {
    /* Redirect the external request for resetting the session to the internal request handler (same activity) */
    Dcm_TskSetLocalEvent(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_INT_SET2DEF);                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */

    /* If non-default session is active the current protocol id is unequal to DCM_NET_INVALID_PROTID */
    if(!Dcm_StateIsDefaultSessionActive())
    {
      Dcm_DiagSetP2Timings(0, Dcm_NetGetProtIdOfActiveProtocol(), pContext->ThreadId);
    }/* else - P2 timings of default session already set */

#if (DCM_NET_RX_BLOCKING_ENABLED == STD_ON)
    Dcm_SingletonContext.Network.RxAllowed = TRUE;
#endif
  }
}

/**********************************************************************************************************************
 *  Dcm_DiagSwitchProcessingContext()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagSwitchProcessingContext(
  Dcm_ContextPtrType pContext                                                                                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;

  Dcm_SplitTaskEnterCS();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
#if (DCM_DIAG_GARB_COL_ENABLED == STD_ON) && \
    (DCM_SPLIT_TASKS_ENABLED == STD_ON)
  if((DCM_TSK_EV_DIAG_WORK_KILL_JOBS & Dcm_TskGetEventByThread(DCM_TSK_ID_DIAG_WORK, DCM_THREAD_ID_BASIC)) != 0u)/* STILL no (nested) kill job received? */
  {
    lStdResult = DCM_E_NOT_OK; /* skip any further processing in this Dcm_DiagTaskWorker() activation (i.e. return immediately) */
  }
  else
#endif
  {
    Dcm_NetTransportObjectConstPtrType pQueuedTObj;

    pQueuedTObj = Dcm_DiagGetQueuedTranspObj(pContext);

    Dcm_UtiBitOpClr(Dcm_DiagProcessorFlagType, pContext->Diag.QueuedSet.Flags, DCM_DIAG_QUEUE_FLAG_IS_CANCELING);                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_UtiBitOpClr(Dcm_DiagProcessorFlagType, pContext->Diag.QueuedSet.Flags, DCM_DIAG_QUEUE_FLAG_IS_WAITING);                                      /* SBSW_DCM_PARAM_PTR_WRITE */

    Dcm_UtiBitOpSet(Dcm_DiagProcessorFlagType, pContext->Diag.QueuedSet.Flags, DCM_DIAG_QUEUE_FLAG_IS_ACTIVE);                                       /* SBSW_DCM_PARAM_PTR_WRITE */

    Dcm_DiagSetTranspObj(pContext, pQueuedTObj); /* switch work contexts! RCR-RP will be sent also from this one (QueuedCtxt) */                     /* SBSW_DCM_PARAM_PTR_WRITE */

#if (DCM_DIAG_GARB_COL_ENABLED ==STD_ON)
    Dcm_UtiBitOpClr(Dcm_TskTaskEvMemType, pContext->Diag.QueuedSet.QueuedTObjects, (Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, pQueuedTObj->Handle))); /* SBSW_DCM_PARAM_PTR_WRITE */
#endif
  }
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_SplitTaskLeaveCS();

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_DiagInitMsgContextBufferInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_GLOBAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagInitMsgContextBufferInfo(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_CfgNetBufferRefOptType index
  )
{
  Dcm_PbCfgNetBufferInfoPtrType lBufferInfo;

  lBufferInfo = Dcm_NetGetBufferInfo(index);

  pMsgContext->reqData = &(lBufferInfo->BufferPtr[0]);                                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->resData = &(lBufferInfo->BufferPtr[0]);                                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->reqDataLen = 0;                                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->resDataLen = 0u;                                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->reqBufSize = lBufferInfo->Size;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->resBufSize = lBufferInfo->Size;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->resMaxDataLen = lBufferInfo->Size;                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->resProtHeadLen = 0;                                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->reqIndex = 0u;                                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->resIndex = 0u;                                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
}

/**********************************************************************************************************************
 *  Dcm_DiagInitiateServiceProcessing()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagInitiateServiceProcessing(
  Dcm_ContextPtrType pContext                                                                                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_NetTransportObjectConstPtrType pTranspObj;
  Dcm_MsgContextPtrType              pMsgContext;

  /* Now take the active transport object */
  pTranspObj = Dcm_DiagGetTranspObj(pContext);
  pMsgContext = &(pContext->Diag.MsgContext);

  /* Compose message context (skip SID byte) */
  Dcm_DiagInitMsgContextBufferInfo(pMsgContext, pTranspObj->BufferHdl);                                                                              /* SBSW_DCM_POINTER_INIT_MESSAGE_CONTEXT */

  pMsgContext->reqDataLen = pTranspObj->RxLength;                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->rxPduId = pTranspObj->RxPduId;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->msgAddInfo.reqType  = (uint8)((Dcm_PbCfgNetRxPduInfo[pTranspObj->RxPduId].IsFuncReq == TRUE)?1u:0u);                                  /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->msgAddInfo.suppressPosResponse = 0;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
  pMsgContext->threadId = pContext->ThreadId;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */

  /* Update diagnostic kernel context */
#if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
  pContext->Diag.IsInternRequest    = (boolean)((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) != 0u);                                             /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */ /* SBSW_DCM_PARAM_PTR_WRITE */
#endif
  pContext->Diag.ErrorRegister      = DCM_E_POSITIVERESPONSE;                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
  pContext->Diag.ApplNotification   = DCM_DIAG_APPL_NOTIFICATION_NONE;                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
  pContext->Diag.DoSuppressResponse = FALSE;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
  pContext->Diag.State              = DCM_DIAG_STATE_PROCESS;                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */

#if (DCM_DIAG_SPECIFIC_CAUSE_CODE_ENABLED == STD_ON)
  /* Initialize cause code context */
  Dcm_SingletonContext.Diag.CauseCodeContext.CauseCode = 0x00;
  Dcm_SingletonContext.Diag.CauseCodeContext.SendCauseCode = FALSE;
#endif

  /* Initialize IdsM security event */
  Dcm_DebugResetSecurityEventStatus(pContext->ThreadId);

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
  Dcm_PagedBufferInitByThread(pContext->ThreadId);
#endif
}

/**********************************************************************************************************************
 *  Dcm_DiagHandleSuppressBit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagHandleSuppressBit(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NetTransportObjectPtrType pTranspObj,                                                                                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_MsgContextPtrType pMsgContext
  )
{
  DCM_IGNORE_UNREF_PARAM(pTranspObj);                                                                                                                /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Check if the new service supports sub-function parameter */
  if((Dcm_CfgDiagServiceInfo[pContext->Diag.SidIndex].Props & DCM_DIAG_SVC_CFG_PROP_HAS_SUBFUNC)  != 0u)
  {
    uint8 reqSf = Dcm_UtiGetReqDataAsU8(pMsgContext);                                                                                                /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */
    /* If so, deal with the SPRMIB: extract and store */
    if ((reqSf & 0x80u) != 0u)
    {
      Dcm_UtiSetReqDataAsU8(pMsgContext, (uint8)(reqSf & 0x7Fu));/* mask out the SPRMIB */                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

      Dcm_SplitTaskEnterCS();/* protect against hi-priority Dcm_DiagTaskRx/Tx */
      /*=================================*
        BEGIN CRITICAL SECTION
       *=================================*/
#if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
      /* On split task it could happen that RCR-RP is already on transmission */
      if((pTranspObj->Flags & (DCM_NET_TOBJ_FLAG_RCRRP_ON_TX | DCM_NET_TOBJ_FLAG_RCRRP_SENT)) == 0u)/* RCR-RP is NOT on transmission or was sent */
#endif
      {
        pMsgContext->msgAddInfo.suppressPosResponse = 1;                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
      }
      /*=================================*
        END CRITICAL SECTION
       *=================================*/
      Dcm_SplitTaskLeaveCS();
    }
    /* copy the sub-function byte once split Rx/Tx buffers are supported.
    pMsgContext->resData[0] = pMsgContext->reqData[0];
    */
  }
}

/**********************************************************************************************************************
 *  Dcm_DiagHandleDispatching()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagHandleDispatching(
  uint8 sid,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_ContextPtrType pContext                                                                                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  DCM_IGNORE_UNREF_PARAM(sid);                                                                                                                       /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  pContext->Diag.ProcessServiceExtern = FALSE;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */

#if (DCM_DIAG_SERVICE_DISPATCHER_ENABLED == STD_ON)
  /*  Check for necessity of service dispatching (service supports the dispatching parameter) */
  if((Dcm_CfgDiagServiceInfo[pContext->Diag.SidIndex].Props & DCM_DIAG_SVC_CFG_PROP_CALL_SVC_DISPATCHER) != 0u)
  {
    boolean lResult;

    /* Execute the call-out to the application and verify the result */
    lResult = Dcm_HandleServiceExtern(sid
                                     ,pMsgContext->reqData
                                     ,(uint16)pMsgContext->reqDataLen
                                     ,(uint8) pMsgContext->msgAddInfo.reqType
                                     ,Dcm_DiagGetTranspObj(pContext)->ClientSrcAddr);                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */

    if (Dcm_DebugDetectError((lResult != TRUE) && (lResult != FALSE)))
    {
      Dcm_DebugReportError(DCM_SID_SVCDISPATCHER, DCM_E_INTERFACE_RETURN_VALUE);                                                                     /* PRQA S 2880 */ /* MD_MSR_Unreachable */
    }
    else
    {
      pContext->Diag.ProcessServiceExtern = lResult;                                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }

  /* Set the flags for post processing on internal service handling */
  if(pContext->Diag.ProcessServiceExtern == FALSE)
#endif
  {
    if(Dcm_CfgDiagServiceInfo[pContext->Diag.SidIndex].ConfFuncRef != 0u)
    {
      pContext->Diag.ApplNotification |= DCM_DIAG_APPL_NOTIFICATION_POSTPROCESSOR; /* mark application post processor */                             /* SBSW_DCM_PARAM_PTR_WRITE */
    }

    if(Dcm_CfgDiagServiceInfo[pContext->Diag.SidIndex].FastConfFuncRef != 0u)
    {
      pContext->Diag.ApplNotification |= DCM_DIAG_APPL_NOTIFICATION_FASTPOSTPROCESSOR; /* mark application fast post processor */                    /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }

  /* From now on, mark application calls for post-processing later */
  pContext->Diag.ApplNotification |= DCM_DIAG_APPL_NOTIFICATION_CONFIRMATION; /* mark application notification at last here */                       /* SBSW_DCM_PARAM_PTR_WRITE */
}

/**********************************************************************************************************************
 *  Dcm_DiagValidateAndDispatchService()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagValidateAndDispatchService(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_ContextPtrType pContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  Dcm_MsgItemType lSid;

  Dcm_UtiConsumeReqDataAsU8(pMsgContext, &lSid);                                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
  Dcm_UtiProvideResDataAsU8(pMsgContext, (uint8)(lSid + 0x40u));                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* Skip SID data, since already processed */
  Dcm_DiagSetNewReqBaseToCurProgress(pMsgContext);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
  Dcm_DiagSetNewResBaseToCurProgress(pMsgContext);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* Execute manufacturer specific environment checks */
  if(Dcm_DiagExecIndicationFunc(pContext, lSid, DCM_DIAG_APPL_NOTIFICATION_OEM, Dcm_CfgDiagOemNotificationInfo, ErrorCode) == DCM_E_OK)              /* SBSW_DCM_COMB_PTR_FORWARD */
  {
    sint16_least sidIter = Dcm_DiagLookUpFilter(pMsgContext
                                               ,Dcm_CfgDiagSvcIdLookUpTable
                                               ,Dcm_CfgDiagSvcIdExecPrecondTable
                                               ,lSid
                                               ,DCM_DIAG_CHK_LVL_SERVICE_ID
                                               ,ErrorCode);                                                                                          /* SBSW_DCM_POINTER_FORWARD_GLOBAL */ /* SBSW_DCM_COMB_PTR_FORWARD */
    /* Service found? */
    if(sidIter >= 0)
    {
      pContext->Diag.SidIndex = (uint8)sidIter;                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */

      if((Dcm_CfgDiagServiceInfo[pContext->Diag.SidIndex].Props & DCM_DIAG_SVC_CFG_PROP_CALL_POST_HDLR_ALWAYS)  != 0u)
      {
        /* mark application notification once the SID is identified! */
        pContext->Diag.ApplNotification |= DCM_DIAG_APPL_NOTIFICATION_POSTPROCESSOR;                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
      }

#if (DCM_STATE_AUTHENTICATION_ENABLED == STD_ON)
      /* Check authentication access rights */
      lStdResult = Dcm_AuthMgrCheckDispatcherLevel(lSid
                                                  ,Dcm_CfgDiagSvcIdExecPrecondTable[pContext->Diag.SidIndex]
                                                  ,pMsgContext
                                                  ,Dcm_AuthMgrGetAuthInfoRef(pMsgContext)
                                                  ,ErrorCode);                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */

      if(lStdResult == DCM_E_OK)
#endif
      {
        /* Check SID pre-conditions */
        lStdResult = Dcm_StateCheck(Dcm_CfgDiagSvcIdExecPrecondTable[pContext->Diag.SidIndex]
                                   ,DCM_DIAG_CHK_LVL_SERVICE_ID
                                   ,ErrorCode);                                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */

        if(lStdResult == DCM_E_OK)
        {
          /* Execute supplier specific environment checks */
          lStdResult = Dcm_DiagExecIndicationFunc(pContext, lSid, DCM_DIAG_APPL_NOTIFICATION_SYS, Dcm_CfgDiagSysNotificationInfo, ErrorCode);        /* SBSW_DCM_COMB_PTR_FORWARD */

          if(lStdResult == DCM_E_OK)
          {
            /* Check for available minimum length */
            if(pMsgContext->reqDataLen >= Dcm_CfgDiagServiceInfo[pContext->Diag.SidIndex].MinLength)
            {
              /* Handle SPRMIB */
              Dcm_DiagHandleSuppressBit(pContext, Dcm_DiagGetTranspObj(pContext), pMsgContext);                                                      /* SBSW_DCM_COMB_PTR_FORWARD */

              /* Handle service dispatching and set the flags for post-processing */
              Dcm_DiagHandleDispatching(lSid, pMsgContext, pContext);                                                                                /* SBSW_DCM_COMB_PTR_FORWARD */
            }
            else
            {
              /* Minimum length is not reached  */
              *ErrorCode = (Dcm_NegativeResponseCodeType)( (lSid < 0x10u)
                                                          ? DCM_E_REQUESTOUTOFRANGE
                                                          : DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT);                                            /* SBSW_DCM_PARAM_PTR_WRITE */
              lStdResult = DCM_E_NOT_OK;
            }
          } /* else - NRC already set - finalize processing */
        }/* else - NRC already set - finalize processing */
      }/* else - NRC already set - finalize processing */
    }/* else - already written "Unsupported service requested" */
  }/* else - NRC already set - finalize processing */

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_DiagWorkerProcessNewRequest()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerProcessNewRequest(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType               lStdResult;
  Dcm_NegativeResponseCodeType lNrc = DCM_E_PANIC_NRC; /* to avoid compiler warnings */

  lStdResult = Dcm_DiagSwitchProcessingContext(pContext);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)                                                                                                                         /* PRQA S 2991, 2995 */ /* MD_Dcm_ConstExpr, MD_Dcm_ConstExpr */
  {
    Dcm_DiagInitiateServiceProcessing(pContext);                                                                                                     /* SBSW_DCM_POINTER_INIT_MESSAGE_CONTEXT */

    /* Validate received diagnostic service on SID level */
    lStdResult = Dcm_DiagValidateAndDispatchService(&(pContext->Diag.MsgContext)
                                                   ,pContext
                                                   ,&lNrc);                                                                                          /* SBSW_DCM_COMB_PTR_FORWARD */

    if(lStdResult == DCM_E_OK)
    {
      /* Execute Main-Handler (register it and it will be called immediately) */
      Dcm_RepeaterSetCallee(pContext, pContext->Diag.SidIndex);                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
      /* Let the service processor take over immediately */
      Dcm_TskSetLocalEvent(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_REPEAT);                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
    {
      /* DCM_E_NOT_OK */
      Dcm_SetNegResponse(lNrc, pContext->ThreadId);
      Dcm_ProcessingDone(pContext->ThreadId);
    }
  }
  else
  {
    /* DCM_E_NOT_OK */
#if (DCM_MULTI_THREAD_ENABLED == STD_ON)
    if(pContext->ThreadId != DCM_THREAD_ID_BASIC)
    {
      Dcm_TskSetLocalEvent(pEventContext->PostEv, DCM_TSK_EV_DIAG_WORK_NEW_REQ); /* Retry next time */                                               /* PRQA S 2880 */ /* MD_MSR_Unreachable */ /* SBSW_DCM_PARAM_PTR_WRITE */
    }
#endif

    /* skip any further processing in this Dcm_DiagTaskWorker() activation (i.e. return immediately) */
    pEventContext->Ev = 0;                                                                                                                           /* PRQA S 2880 */ /* MD_MSR_Unreachable */ /* SBSW_DCM_PARAM_PTR_WRITE */
  }
}

/**********************************************************************************************************************
 *  Dcm_DiagWorkerProcessRcrRpTxEnd()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerProcessRcrRpTxEnd(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_NetTransportObjectPtrType pTranspObj;

  pTranspObj = Dcm_DiagGetTranspObj(pContext);

  if((DCM_NET_TOBJ_FLAG_RCRRP_TYPE_APPL & pTranspObj->Flags) != 0u)/* this is a RCR-RP response - check which kind */
  {
    Dcm_UtiBitOpClr(Dcm_NetTransportObjectFlagType, pTranspObj->Flags, DCM_NET_TOBJ_FLAG_RCRRP_TYPE_APPL);                                           /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    pContext->Repeater.OpStatus = (Dcm_OpStatusType)((pContext->Diag.TxStatus != DCM_E_OK)
                                        ? DCM_FORCE_RCRRP_NOT_OK
                                        : DCM_FORCE_RCRRP_OK);                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_TskSetLocalEvent(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_REPEAT); /* notify immediately */                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
  }
}

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON) && \
    (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagWorkerCancelOperation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerCancelOperation(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_NegativeResponseCodeType lNrc;

  DCM_IGNORE_UNREF_PARAM(pEventContext);                                                                                                             /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if(Dcm_PagedBufferCancel(pContext, &lNrc) == DCM_E_NOT_OK)                                                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
  {
    /* Stop polling and wait for confirmation */
    Dcm_SetNegResponse(lNrc, pContext->ThreadId);
    Dcm_ProcessingDone(pContext->ThreadId);
  }
}
#endif

#if (DCM_STATE_SECURITY_BYPASS_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagWorkerSetSecurityBypass()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerSetSecurityBypass(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  /* Enforce bypass mode if no service is in processing! */
  if(pContext->Diag.State != DCM_DIAG_STATE_IDLE)
  {
    Dcm_TskSetLocalEvent(pEventContext->PostEv, DCM_TSK_EV_DIAG_WORK_EXT_SETSECBYPASS); /* retry later again */                                      /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
  {
    if(Dcm_SingletonContext.Diag.IsSecurityBypass == TRUE)
    {
      /* Unlock security (excluding locked level = 0x00) */
      Dcm_SingletonContext.StateMgr.Preconditions.Security = (Dcm_CfgStateGroupMemType)(Dcm_UtiMaxValueOfUintType(Dcm_CfgStateGroupMemType) - 1u);
    }
    else
    {
      /* Lock security */
      Dcm_StateSetSecurity(0);
    }
  }
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoRepeat()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoRepeat(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  )
{
  Std_ReturnType lStdResult;
  Dcm_NegativeResponseCodeType lNrc = DCM_E_CONDITIONSNOTCORRECT;
  Dcm_NetTransportObjectPtrType pTranspObj;

  pTranspObj = Dcm_DiagGetTranspObj(pContext);

#if (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
  if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_CANCEL_OP))
  {
    pContext->Repeater.OpStatus = DCM_CANCEL; /* override any other opStatus values up to now */                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
  }
#endif
  lStdResult = Dcm_RepeaterExecute(pContext, &lNrc);                                                                                                 /* SBSW_DCM_COMB_PTR_FORWARD */

  switch(lStdResult)
  {
  case DCM_E_NOT_OK:
    Dcm_SetNegResponse(lNrc, pContext->ThreadId);
    /* fall through */
  case DCM_E_OK:                                                                                                                                     /* PRQA S 2003 */ /* MD_Dcm_Optimize_2003 */
  case DCM_E_PROCESSINGDONE:
    Dcm_ProcessingDone(pContext->ThreadId);
    break;
  case DCM_E_PENDING:
    pContext->Repeater.OpStatus = DCM_PENDING;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
    /* fall through - keep the last opStatus on "pending" forced by Dcm_RepeaterExecute code */
  case DCM_E_PENDING_LIMITER:                                                                                                                        /* PRQA S 2003 */ /* MD_Dcm_Optimize_2003 */
    /* Retry next cycle with the same parameter */
    Dcm_TskSetLocalEvent(pEventContext->PostEv, DCM_TSK_EV_DIAG_WORK_REPEAT);                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  case DCM_E_FORCE_RCRRP:
    Dcm_UtiEnterCriticalSection();/* protect against Dcm_TpTxConfirmation or hi-priority Dcm_DiagTaskRx */
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    pTranspObj->Flags |= DCM_NET_TOBJ_FLAG_RCRRP_TYPE_APPL;                                                                                          /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    if((pTranspObj->Flags & (DCM_NET_TOBJ_FLAG_RCRRP_ON_TX | DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ))  == 0u)/* no RCR-RP already requested for transmission/ongoing? */
    {
      Dcm_TskSetEventByThread(DCM_TSK_ID_DIAG_RX, DCM_TSK_EV_DIAG_RX_TMR_P2_TO, pContext->ThreadId);/* trigger a RCR-RP event timeout */
    }/* else - just wait for confirmation signal */

    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiLeaveCriticalSection();
    break;
  default: /* DCM_E_STOP_REPEATER */
    Dcm_RepeaterSetCallee(pContext, DCM_DIAG_SERVICEINFO_REPEATEREND_IDX); /* any other return value leads to a dead end */                          /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  }
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */

#if (DCM_TSK_NUM_DIAG_FBLRES > 0u)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoGetProgCond()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagFblResDoGetProgCond(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext
  )
{
  /* Read the programming conditions of the pre-boot cycle */
  /* #10 If the ECU boot type is marked as a transition from the bootloader: */
  if(Dcm_GetProgConditions(&Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions) == DCM_WARM_START)                                                  /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
  {
    sint16_least sesSfIter = -1;

# if (DCM_DIAG_NOTIF_BSWM_APPL_UPDATED_ENABLED == STD_ON)
    /* #20 If the application has been updated, notify the BswM (if enabled BswM notification) */
    if(Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.ApplUpdated == TRUE)
    {
      BswM_Dcm_ApplicationUpdated();
    }
# endif

    /* Check the diagnostic service identifier to be processed here: */
# if (DCM_SVC_11_RST2BOOT_HIS_ENABLED == STD_ON)
    /* #30 If the SID is for "EcuReset": */
    if(Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.Sid == 0x11u)
    {
      sint16_least subFncIter = -1;

      subFncIter = Dcm_DiagVariantLookUpFilter(Dcm_CfgSvc11SubFuncLookUpTable
                                              ,Dcm_CfgSvc11SubFuncExecPrecondTable
                                              ,Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.SubFuncId);                                       /* SBSW_DCM_POINTER_FORWARD_GLOBAL */

      /* Check if reset was internally triggered */
      if( (subFncIter >= 0)
        &&(Dcm_CfgSvc11SubFuncInfo[subFncIter].ResponseType == DCM_SVC11_RESPONSE_AFTER_RESET) )
      {
        Dcm_DebugReportSecurityEvent(pContext->ThreadId, DCM_DEBUG_SEV_ECU_RESET);
      }
    }
# endif

    /* #40 If the SID is for "DiagnosticSessionControl": */
    if(Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.Sid == 0x10u)
    {
      sesSfIter = Dcm_DiagVariantLookUpFilter(Dcm_CfgSvc10SubFuncLookUpTable
                                             ,Dcm_CfgSvc10SubFuncExecPrecondTable
                                             ,Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.SubFuncId);                                        /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
    }
    /* Otherwise, send a response with any other SID and sub-function directly */

    if( (Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.ResponseRequired == TRUE) /* a response is to be sent */
      ||(sesSfIter > 0) ) /* OR a non-default session is to be activated (need ComM active) */
    {
      Dcm_NetConnRefMemType lConnHdl;

# if (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
      lConnHdl = Dcm_NetGetConnHdlByConnectionId(Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.ConnectionId);
# else
      lConnHdl = Dcm_NetGetConnHdlByTesterAddress(Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.TesterSourceAddr);
# endif

      if( (lConnHdl < DCM_NET_INVALID_CONNHDL)
# if (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
        &&( ( (Dcm_NetIsGenericConnection(lConnHdl))
            &&(Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.TesterSourceAddr <= DCM_NET_MAX_VAL_GENERIC_SRC_ADDRESS) )
          ||( (!Dcm_NetIsGenericConnection(lConnHdl))
            &&(Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.TesterSourceAddr == Dcm_NetGetTesterAddress(lConnHdl)) ) )
# endif
         )
      {
        Dcm_NetTransportObjectPtrType pTranspObj; /* use a local copy to avoid collision with a RxIndication! */
        BufReq_ReturnType             lResult;

        lResult = Dcm_NetLockConnection(lConnHdl, &pTranspObj);                                                                                      /* SBSW_DCM_POINTER_FORWARD_STACK */

        if(lResult == BUFREQ_OK) /* try to lock the connection to this tester */
        {
          Dcm_SingletonContext.Diag.StartUpFbl.ConnHdl = pTranspObj->ConnHdl;
          /* Source address of the request shall be the target address of the response. */
          pTranspObj->ClientSrcAddr = Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.TesterSourceAddr;                                          /* SBSW_DCM_POINTER_WRITE_RESERVEDTOBJ */
          Dcm_DiagSetTranspObj(pContext, pTranspObj);/* store working context */                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
          Dcm_TmrStartTimer(DCM_TMR_ID_FBLRES, pContext->Diag.P2Timings.P2Star); /* wait at most P2 star to finalize the FBL positive response */
          /* Start communication */
          Dcm_NetRegisterActiveConnection(pTranspObj);                                                                                               /* SBSW_DCM_POINTER_WRITE_RESERVEDTOBJ */
          Dcm_NetRegisterComMActivity(pTranspObj);                                                                                                   /* SBSW_DCM_POINTER_WRITE_RESERVEDTOBJ */
          Dcm_TskSetLocalEvent(pEventContext->Ev, DCM_TSK_EV_DIAG_FBLRES_WAITTXCOMM);/* Try immediately */                                           /* SBSW_DCM_PARAM_PTR_WRITE */
        }
        /* else - there is a problem locking the channel (there is already a tester request) */
      }
      else
      {
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_PARAM);
      }
    }
    /* In any case store any analysis results for later use (i.e. during the clear response required flag) */
    Dcm_SingletonContext.Diag.StartUpFbl.SessStateRef = (sint8)sesSfIter;
    Dcm_SingletonContext.Diag.StartUpFbl.IsResponseRequired = Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.ResponseRequired;
    /* Signal the current task to start immediately the parallel job for clearing the response required flag, to avoid re-triggering of this sequence at next power on cycle */
    Dcm_TskSetLocalEvent(pEventContext->Ev, DCM_TSK_EV_DIAG_FBLRES_RSTFLAGS);                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
  }
}                                                                                                                                                    /* PRQA S 6050, 6080 */ /* MD_MSR_STCAL */ /* MD_MSR_STMIF */
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0u)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoWaitTxComm()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagFblResDoWaitTxComm(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext
  )
{
  Dcm_NetTransportObjectPtrType pTranspObj;

  pTranspObj = Dcm_DiagGetTranspObj(pContext);

  /* If the corresponding ComM channel state is in "FullComMode": */
  if((DCM_NET_COMM_STATE_FLAG_TX_EN & Dcm_NetGetComStateByTranspObject(pTranspObj)) != 0u)
  {
    Dcm_TmrStopTimer(DCM_TMR_ID_FBLRES);

    if(Dcm_SingletonContext.Diag.StartUpFbl.IsResponseRequired == FALSE) /* is final response required ? */
    {
      Dcm_DiagOnFblResTxFinished(pTranspObj, DCM_E_OK);/* Loop-back to the confirmation (successful "virtual" transmission) to clean up transportObject and ComM */ /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    }
    else
    {
      pTranspObj->State   = DCM_NET_TOBJ_STATE_PREPTX;                                                                                               /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      pTranspObj->ResType = DCM_NET_TOBJ_RESTYPE_UNSOLICITED;                                                                                        /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      pTranspObj->BuffInfo.SduDataPtr = &Dcm_SingletonContext.Diag.StartUpFbl.ResBuffer[0];                                                          /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      pTranspObj->BuffInfo.SduLength  = 2u; /* only service and a sub-function to be sent */                                                         /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      /* Prepare final response to be sent */
      Dcm_DiagPutStartUpFblResBuffer(0, (uint8)(Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.Sid + 0x40u));
      Dcm_DiagPutStartUpFblResBuffer(1, Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.SubFuncId);

      if(Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.Sid == 0x10u)
      {
        if(Dcm_SingletonContext.Diag.StartUpFbl.SessStateRef >= 0)
        {
          Dcm_DiagPutStartUpFblResBuffer(2, Dcm_UtiGetHiByte(Dcm_CfgSvc10SubFuncInfo[Dcm_SingletonContext.Diag.StartUpFbl.SessStateRef].ResponseTime.P2));
          Dcm_DiagPutStartUpFblResBuffer(3, Dcm_UtiGetLoByte(Dcm_CfgSvc10SubFuncInfo[Dcm_SingletonContext.Diag.StartUpFbl.SessStateRef].ResponseTime.P2));
          Dcm_DiagPutStartUpFblResBuffer(4, Dcm_UtiGetHiByte(Dcm_CfgSvc10SubFuncInfo[Dcm_SingletonContext.Diag.StartUpFbl.SessStateRef].ResponseTime.P2Star));
          Dcm_DiagPutStartUpFblResBuffer(5, Dcm_UtiGetLoByte(Dcm_CfgSvc10SubFuncInfo[Dcm_SingletonContext.Diag.StartUpFbl.SessStateRef].ResponseTime.P2Star));
          pTranspObj->BuffInfo.SduLength = 6u;                                                                                                       /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
        }
        else
        {
          Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_PARAM);
        }
      }/* else - for SID 0x11 or other it is not critical to send any response - it will be up to the application to use the API! */

      Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND_USDT);
    }
  }
  else
  { /* Otherwise, check if still shall wait for ComM (deadline not yet expired): */
    if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_FBLRES_CANCEL))/* stop polling since time is up */
    {
      /* Loop-back to the confirmation (failed transmission) to clean up transportObject and ComM */
      Dcm_DiagOnFblResTxFinished(pTranspObj, DCM_E_NOT_OK);                                                                                          /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
    }
    else
    {
      Dcm_TskSetLocalEvent(pEventContext->PostEv, DCM_TSK_EV_DIAG_FBLRES_WAITTXCOMM); /* Retry next time */                                          /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }
}
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0u)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoResetFlags()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagFblResDoResetFlags(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Reset all programming condition fields to their inactive states */
  Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.ReprogrammingRequest = FALSE;
  Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.ApplUpdated      = FALSE;
  Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.ResponseRequired = FALSE;

  /* Write the updated pre-conditions */
  lStdResult = Dcm_SetProgConditions(&Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions);                                                          /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
  switch(lStdResult)
  {
  case DCM_E_OK:
    break;
  case DCM_E_PENDING:
    Dcm_TskSetLocalEvent(pEventContext->PostEv, DCM_TSK_EV_DIAG_FBLRES_RSTFLAGS);/* Retry next time */                                               /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  default:                                                                                                                                           /* PRQA S 2016 */ /* MD_MSR_EmptyClause */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    break;
  }
}
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0u)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoProcessTxConfirmation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagFblResDoProcessTxConfirmation(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  DCM_IGNORE_UNREF_PARAM(pEventContext);                                                                                                             /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* If the final response was for a non-default session and was successfully sent: */
  if( (Dcm_SingletonContext.Diag.StartUpFbl.TxStatus == DCM_E_OK) /* only if successfully sent response ... */
    &&(Dcm_SingletonContext.Diag.StartUpFbl.SessStateRef > 0) )/* ... of diagnostic session control for a non-default session ... */
  {
    /* Enter critical section (Reason: Protect against Dcm_StartOfReception) */
    Dcm_UtiEnterCriticalSection();

    /* Register the diagnostic client for this session */
    Dcm_NetSetSessionConnection(Dcm_SingletonContext.Diag.StartUpFbl.ConnHdl); /* set connection for the session */
    Dcm_NetSetSessionClientSrcAddr(Dcm_SingletonContext.Diag.StartUpFbl.ProgConditions.TesterSourceAddr); /* set tester for the session */

    /* Register new active protocol */
    Dcm_SingletonContext.Network.ActiveProtocol = Dcm_NetGetProtIdOfConnection(Dcm_SingletonContext.Diag.StartUpFbl.ConnHdl);

    /* Leave critical section */
    Dcm_UtiLeaveCriticalSection();

    /* Perform the corresponding session transition */
    Dcm_StateSetSession((Dcm_StateIndexMemType)Dcm_SingletonContext.Diag.StartUpFbl.SessStateRef);

    /* Update P2 timings at once */
    Dcm_DiagSetP2Timings((Dcm_StateIndexMemType)Dcm_SingletonContext.Diag.StartUpFbl.SessStateRef
                        ,Dcm_NetGetProtIdOfActiveProtocol()
                        ,pContext->ThreadId);
  }
  /* Unregister diagnostic client in order to consider any non-default session activated above */
  Dcm_NetUnRegisterComMActivity(Dcm_SingletonContext.Diag.StartUpFbl.ConnHdl);
}
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagTxPostponeFinalPagedResponse()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagTxPostponeFinalPagedResponse(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext
  )
{
  /* Wait for RCR-RP if SPRMIB was set */
  if (pContext->Diag.MsgContext.msgAddInfo.suppressPosResponse != 0u)
  {
    /* wait for P2 timeout and RCR-RP response transmission */
    Dcm_TskSetLocalEvent(pEventContext->PostEv, DCM_TSK_EV_DIAG_TX_SEND_PAGED); /* retry later */                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_TskClrLocalEvent(pEventContext->Ev, DCM_TSK_EV_DIAG_TX_SEND_PAGED); /* avoid transmit attempt now */                                         /* SBSW_DCM_PARAM_PTR_WRITE */
  }
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagTxStartFinalResponse()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagTxStartFinalResponse(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext
  )
{
  Dcm_NetTransportObjectPtrType pTranspObj;

  pTranspObj = Dcm_DiagGetTranspObj(pContext);

  /* kill any pending RCR-RP orders */
  Dcm_TskClrLocalEvent(pEventContext->Ev, DCM_TSK_EV_DIAG_TX_SEND_RCRRP);                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
  /* stop in any case since from now on only the service will be finalized (either with or without response) */
  Dcm_TmrStopTimerByThread(DCM_TMR_ID_P2, pContext->ThreadId);

  if ( (pContext->Diag.DoSuppressResponse == TRUE)                 /* No response to send */
      &&(0u == (pTranspObj->Flags & (DCM_NET_TOBJ_FLAG_RCRRP_SENT | DCM_NET_TOBJ_FLAG_RCRRP_ON_TX /* Suppress only if RcrRp was not sent or not waiting for RCR-RP confirmation. If just attempted -> skip RCR-RP transmission */
                              /* | DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ - since DCM_TSK_EV_DIAG_TX_SEND_RCRRP cleared -> RCR-RP will not be sent. Instead finish the service processing at P2 time */))) )
  {
    Dcm_DiagTxFinalization(pTranspObj, DCM_E_OK);/* always OK */                                                                                     /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
  }
  else
  {
    /* prepare final response transmission */
    if(pTranspObj->State == DCM_NET_TOBJ_STATE_READY)
    {
      Dcm_PbCfgNetBufferInfoPtrType lBufferInfo;

      lBufferInfo = Dcm_NetGetBufferInfo(pTranspObj->BufferHdl);

      /* clear flag */
      Dcm_UtiBitOpClr(Dcm_NetTransportObjectFlagType, pTranspObj->Flags, (DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ | DCM_NET_TOBJ_FLAG_RCRRP_ON_TX));          /* PRQA S 4399 */ /* MD_Dcm_BitNegation_4399 */ /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      pTranspObj->State = DCM_NET_TOBJ_STATE_PREPTX;                                                                                                 /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      pTranspObj->BuffInfo.SduDataPtr = lBufferInfo->BufferPtr;/* reassign the worker buffer */                                                      /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */

      if(pContext->Diag.ErrorRegister == DCM_E_POSITIVERESPONSE)
      {
        /* Positive response */
        pTranspObj->BuffInfo.SduLength = (PduLengthType)(pContext->Diag.MsgContext.resDataLen
                                                       + pContext->Diag.MsgContext.resProtHeadLen); /* don't forget the SID or/and SF bytes */       /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
        if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_TX_SEND_PAGED))
        {
          pTranspObj->ResType = DCM_NET_TOBJ_RESTYPE_PAGED;                                                                                          /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
        }
        else
#endif
        {
          pTranspObj->ResType = DCM_NET_TOBJ_RESTYPE_LINEAR;                                                                                         /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
        }
      }
      else
      {
        /* Neg response */
        Dcm_NetComposeAddNegResponse(pTranspObj
                                    ,DCM_NET_TOBJ_RESTYPE_LINEAR
                                    ,pContext->Diag.ErrorRegister);                                                                                  /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */

#if (DCM_DIAG_SPECIFIC_CAUSE_CODE_ENABLED == STD_ON)
        if(Dcm_SingletonContext.Diag.CauseCodeContext.SendCauseCode == TRUE)
        {
          /* Provide specific cause code to negative response */
          Dcm_NetWriteAddBufferU8At(pTranspObj, 3, Dcm_SingletonContext.Diag.CauseCodeContext.CauseCode);                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
          /* Add the additional byte of the cause code to the SduLength */
          pTranspObj->BuffInfo.SduLength = 4u;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
          Dcm_SingletonContext.Diag.CauseCodeContext.SendCauseCode = FALSE;
        }
#endif
      }

      Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND_USDT);
    }
    else
    {
      /* retry later */
      Dcm_TskSetLocalEvent(pEventContext->PostEv, (pEventContext->Ev & (Dcm_TskTaskEvOptType)(DCM_TSK_EV_DIAG_TX_SEND_PAGED | DCM_TSK_EV_DIAG_TX_SEND_LINEAR))); /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }
}

/**********************************************************************************************************************
 *  Dcm_DiagTxStartRcrRpResponse()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagTxStartRcrRpResponse(
  Dcm_ContextPtrType pContext                                                                                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_NetTransportObjectPtrType pQueuedTObj;

  pQueuedTObj = Dcm_DiagGetQueuedTranspObj(pContext);

  /*
   * Don't start the P2* timer within the RCR-RP confirmation but here because of prioritization and synchronization
   * issues which could occur otherwise.
   * Start now to cover also the application triggered RCR-RPs.
   */
  Dcm_TmrStartTimerByThread(DCM_TMR_ID_P2, pContext->Diag.P2Timings.P2Star, pContext->ThreadId);

  pContext->Diag.MsgContext.msgAddInfo.suppressPosResponse = 0; /* reset the suppress bit and send final response */                                 /* SBSW_DCM_PARAM_PTR_WRITE */

  Dcm_UtiBitOpClr(Dcm_NetTransportObjectFlagType, pQueuedTObj->Flags, DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ);                                               /* SBSW_DCM_POINTER_WRITE_QUEUEDTOBJ */
  Dcm_UtiBitOpSet(Dcm_NetTransportObjectFlagType, pQueuedTObj->Flags, DCM_NET_TOBJ_FLAG_RCRRP_ON_TX); /* mark transmission flag */                   /* SBSW_DCM_POINTER_WRITE_QUEUEDTOBJ */

#if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
  if((pQueuedTObj->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) != 0u)
  {
    /* suppress any RCR-RP responses on RoE - just do loop back ! */
    Dcm_DiagRcrRpTxFinished(pQueuedTObj, DCM_E_OK); /* always OK */                                                                                  /* SBSW_DCM_POINTER_WRITE_QUEUEDTOBJ */
  }
  else
#endif
  {
    Dcm_NetComposeAddNegResponse(pQueuedTObj
                                ,DCM_NET_TOBJ_RESTYPE_RCRRP
                                ,DCM_E_REQUESTCORRECTLYRECEIVEDRESPONSEPENDING);                                                                     /* SBSW_DCM_POINTER_WRITE_QUEUEDTOBJ */

    Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND_USDT); /* delegate job */
  }
}

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagGetRecoveryInfoComMChannelState()
*********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_RecoveryInfoComMChannelStatePtrType, DCM_CODE) Dcm_DiagGetRecoveryInfoComMChannelState(
  P2VAR(Dcm_RecoveryInfoType, AUTOMATIC, DCM_APPL_DATA) RecoveryInfo ,                                                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_CfgNetNetIdRefOptType index
  )
{
  Dcm_RecoveryInfoComMChannelStatePtrType lResult;

  if (Dcm_DebugDetectRuntimeError(index >= DCM_NET_MAX_NUM_COMM_CHANNELS))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    lResult = &(RecoveryInfo->ComMChannelState[0]);
  }
  else
  {
    lResult = &(RecoveryInfo->ComMChannelState[index]);
  }
  return lResult;
}
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON && DCM_MODE_COMMCTRL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagGetRecoveryInfoCommControlState()
*********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_RecoveryInfoCommControlStatePtrType, DCM_CODE) Dcm_DiagGetRecoveryInfoCommControlState(
  P2VAR(Dcm_RecoveryInfoType, AUTOMATIC, DCM_APPL_DATA) RecoveryInfo ,                                                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_CfgNetNetIdRefOptType index
  )
{
  Dcm_RecoveryInfoCommControlStatePtrType lResult;

  if (Dcm_DebugDetectRuntimeError(index >= DCM_NET_MAX_NUM_ALL_COMM_CHANNELS))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    lResult = &(RecoveryInfo->CommControlState[0]);
  }
  else
  {
    lResult = &(RecoveryInfo->CommControlState[index]);
  }
  return lResult;
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagIsCancellationNeeded()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_DiagIsCancellationNeeded(
  Dcm_NetTransportObjectPtrType pTranspObj                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  boolean lResult = TRUE;

  DCM_IGNORE_UNREF_PARAM(pTranspObj);                                                                                                                /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if(Dcm_NetGetProtIdOfActiveProtocol() >= DCM_NET_INVALID_PROTID)
  {
    lResult = FALSE;
  }
#if (DCM_MULTI_THREAD_ENABLED == STD_ON)
  else
  {
    Dcm_ContextConstPtrType pContext = Dcm_GetThreadContext(DCM_THREAD_ID_BASIC);

    /*
     * In case that multiple winners are detected during non-default session and one of the winners is from
     * basic thread, the cancellation procedure shall be executed only once.
     * Otherwise the P2 timer of new basic thread winner would be stopped (the P2 timers are thread specific and not
     * protocol specific). Since the DCM_TSK_EV_DIAG_WORK_NEW_REQ event is unkillable, Dcm would proceed with
     * parallel service processing in default session, although NRC 0x78 can no longer be send for basic thread.
     * Note: The problem does not occur for multiple non-basic thread winner, because they are unkillable.
     */
    if( (Dcm_NetGetThreadIdOfTranspObj(pTranspObj) != DCM_THREAD_ID_BASIC)
      &&((DCM_DIAG_QUEUE_FLAG_IS_CANCELING & pContext->Diag.QueuedSet.Flags) != 0u) )
    {
      lResult = FALSE;
    }
  }
#endif

  return lResult;
}
#if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc10_TriggerReset()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10_TriggerReset(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc10RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;
  Dcm_NetTransportObjectConstPtrType pTranspObj = Dcm_DiagGetTranspObj(pContext);

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Prepare programming conditions */
  (void)Dcm_GetActiveProtocol(&pRepContext->ProgConditions.ProtocolId);                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
# if (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
  pRepContext->ProgConditions.ConnectionId = Dcm_PbCfgNetConnectionInfo[pTranspObj->ConnHdl].ConnectionId;                                           /* SBSW_DCM_PARAM_PTR_WRITE */
# endif
  pRepContext->ProgConditions.TesterSourceAddr = pTranspObj->ClientSrcAddr;                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
  pRepContext->ProgConditions.Sid = 0x10u;                                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
  pRepContext->ProgConditions.SubFuncId = Dcm_CfgSvc10SubFuncLookUpTable[pRepContext->SesStateIdx+1u];                                               /* SBSW_DCM_PARAM_PTR_WRITE */
  pRepContext->ProgConditions.ReprogrammingRequest = TRUE;                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
  /* This flag shall be initialized from the FBL, not the DCM!
  pRepContext->ProgConditions.ApplUpdated = TRUE; */
  /* To be set once the Dcm_setProgCond API is called in order to consider the current RCR-RP status!
    * pRepContext->ProgConditions.ResponseRequired = ...; */
  pRepContext->ResetMode = (Rte_ModeType_DcmEcuReset)( (Dcm_CfgSvc10SubFuncInfo[pRepContext->SesStateIdx].BootType == DCM_SVC10_BOOT_TYPE_OEM)
                                                      ? RTE_MODE_DcmEcuReset_JUMPTOBOOTLOADER
                                                      : RTE_MODE_DcmEcuReset_JUMPTOSYSSUPPLIERBOOTLOADER);                                           /* SBSW_DCM_PARAM_PTR_WRITE */

  if(Dcm_ModeSwitchEcuReset(pRepContext->ResetMode) == DCM_E_OK)                                                                                     /* PRQA S 2991, 2995 */ /* MD_Dcm_ConstExpr, MD_Dcm_ConstExpr */
  {
    /* Determine entry point - with or without RCR-RP */
    Dcm_RepeaterNextStep(pContext, DCM_SVC10_PROGRESS_WAIT_RESET_ACK);                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP; /* start immediately */
  }
  else
  {
    /* for some reason, no mode switch is possible - exit with NRC */
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */ /* PRQA S 2880 */ /* MD_MSR_Unreachable */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}
#endif

#if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc10_WaitForResetAck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10_WaitForResetAck(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc10RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Check mode switch state */
  lStdResult = Dcm_ModeSwitchAckEcuReset();
  switch(lStdResult)
  {
  case DCM_E_PENDING:                                                                                                                                /* PRQA S 2880 */ /* MD_MSR_Unreachable */
    break;
  case DCM_E_OK:
    Dcm_RepeaterNextStep(pContext, DCM_SVC10_PROGRESS_WAIT_RCRRP_ACK);                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
    if(Dcm_NetGetProtObjOfTranspObj(Dcm_DiagGetTranspObj(pContext))->HasRespPendOnBoot == TRUE)                                                      /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */ /* COV_DCM_RTM_DEPENDS_ON_UNSUPPORTED TX */
    {
      lStdResult = DCM_E_FORCE_RCRRP;
    }
    else
    {
      lStdResult = DCM_E_LOOP;
    }
    break;/* go on with next step - fall through */
  default:
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }

  return lStdResult;
}
#endif

#if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc10_WaitForRcrRpAck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10_WaitForRcrRpAck(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc10RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if(opStatus == DCM_FORCE_RCRRP_NOT_OK)
  {
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
  {
# if (DCM_SVC_10_RST2BOOT_HIS_ENABLED == STD_ON)
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    Dcm_SplitTaskEnterCS();/* avoid interrupt from the Dcm_DiagTaskTx */
    if(pMsgContext->msgAddInfo.suppressPosResponse != 0u)
    {
      pRepContext->ProgConditions.ResponseRequired = FALSE;                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      /* Stop to avoid inconsistency between P2 timer and the SetProgCond asynchronous API's "ResponseRequired" value */
      Dcm_TmrStopTimerByThread(DCM_TMR_ID_P2, pContext->ThreadId);
    }
    else
    {
      pRepContext->ProgConditions.ResponseRequired = TRUE;                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    Dcm_SplitTaskLeaveCS();/* avoid interrupt from the Dcm_DiagTaskTx */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
# else
    pRepContext->ProgConditions.ResponseRequired = FALSE;/* no response required since DCM sends the final response */                               /* SBSW_DCM_PARAM_PTR_WRITE */
# endif

    Dcm_RepeaterNextStep(pContext, DCM_SVC10_PROGRESS_SET_PRGCOND);                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP;
  }
  return lStdResult;
}
#endif

#if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc10_SetProgConditions()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10_SetProgConditions(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc10RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_SetProgConditions(&pRepContext->ProgConditions);                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
  switch(lStdResult)
  {
  case DCM_E_OK:
# if (DCM_SVC_10_RST2BOOT_HIS_ENABLED == STD_ON)
    lStdResult = Dcm_ModeSwitchEcuReset(RTE_MODE_DcmEcuReset_EXECUTE);
    if(lStdResult == DCM_E_OK)/* fire and forget */                                                                                                  /* PRQA S 2991, 2995 */ /* MD_Dcm_ConstExpr, MD_Dcm_ConstExpr */
    {
      /* just wait for reset */
      lStdResult = DCM_E_STOP_REPEATER;
    }
    else
    {
      /* This code shall not be reached, since the programming conditions are already set! */
      *ErrorCode = DCM_E_PANIC_NRC; /* Use panic NRC since the first mode switch has succeeded, and this one shall too */                            /* SBSW_DCM_PARAM_PTR_WRITE */ /* PRQA S 2880 */ /* MD_MSR_Unreachable */
      lStdResult = DCM_E_NOT_OK;
    }
# endif
    break; /* send final response and if applicable - do reset */
  case DCM_E_PENDING:
    /* already set */
    break;
  case DCM_E_NOT_OK:
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  default:
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  }
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6030, 6050 */ /* MD_MSR_STCYC, MD_MSR_STCAL */
#endif

/**********************************************************************************************************************
 *  Dcm_Svc10Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10Handler(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc10RepeaterProxyContextPtrType pRepContext
  )
{
  Dcm_DiagSubServiceRefOptType  subSvcRef;
  Std_ReturnType                lStdResult;

  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                                    ,Dcm_CfgSvc10SubFuncLookUpTable
                                                    ,Dcm_CfgSvc10SubFuncExecPrecondTable
                                                    ,Dcm_DiagSvcWithOnlySubFuncReqLengthGetter
                                                    ,Dcm_DiagNoSequenceChecker
                                                    ,&subSvcRef
                                                    ,ErrorCode);                                                                                     /* SBSW_DCM_COMB_PTR_FORWARD */
  if(lStdResult == DCM_E_OK)
  {
    /* Compose positive response */
    Dcm_UtiProvideResDataAsU16(pMsgContext, Dcm_CfgSvc10SubFuncInfo[subSvcRef].ResponseTime.P2);                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_UtiProvideResDataAsU16(pMsgContext, Dcm_CfgSvc10SubFuncInfo[subSvcRef].ResponseTime.P2Star);                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */

    pRepContext->SesStateIdx = (uint8)subSvcRef;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */

    Dcm_RepeaterNextStep(pContext, DCM_SVC10_PROGRESS_CHECK_ACCESS);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP; /* start immediately */
  } /* else DCM_E_NOT_OK (ErrorCode is already set) */

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc10CheckAccess()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10CheckAccess(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc10RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  Dcm_UtiEnterCriticalSection();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  if(opStatus == DCM_INITIAL)
  {
    Dcm_NetTransportObjectConstPtrType pTranspObj = Dcm_DiagGetTranspObj(pContext);
    Dcm_StateSetPendingSession(Dcm_UtiGetBitFromIndex(Dcm_CfgStateGroupMemType, pRepContext->SesStateIdx));

    /*
     * Set always a potential tester owner: In case of failed positive response confirmation or negative response,
     * the session will remain in its old state (default) -> the set value does not matter!
     * The situation that the session was a non-default one and another client has requested SID 0x10 is not possible:
     * - Each protocol switch invokes session transition to the default one!
     * - As long as a non-default session is active, no other client with the same priority can access the ECU!
     */
    Dcm_NetSetSessionConnection(pTranspObj->ConnHdl);
    Dcm_NetSetSessionClientSrcAddr(pTranspObj->ClientSrcAddr);
  }

#if (DCM_MULTI_THREAD_ENABLED == STD_ON)
  lStdResult = Dcm_DiagIsSessionChangeAllowed(pContext);                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
#endif
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiLeaveCriticalSection();

#if (DCM_MULTI_THREAD_ENABLED == STD_ON)
  if(lStdResult == DCM_E_NOT_OK)
  {
    lStdResult = DCM_E_PENDING;
  }
  else
#endif
  {
#if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
    pRepContext->ResetMode = RTE_MODE_DcmEcuReset_NONE;                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
    if(Dcm_CfgSvc10SubFuncInfo[pRepContext->SesStateIdx].BootType != DCM_SVC10_BOOT_TYPE_NONE)
    {
      Dcm_RepeaterNextStep(pContext, DCM_SVC10_PROGRESS_TRIGGER_RESET);                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_LOOP;
    }
    else
#endif
    {
      /* Just send the final response */
      lStdResult = DCM_E_OK;
    }
  }

  return lStdResult;
}
#if (DCM_SVC_22_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc22GetDidInfoContext()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_DidMgrDidInfoContextPtrType, DCM_CODE) Dcm_Svc22GetDidInfoContext(
  Dcm_Svc22RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_DidMgrDidInfoContextPtrType lResult;

  if(Dcm_DebugDetectRuntimeError(pRepContext->DidInfoContextIdx >= DCM_SVC_22_MAX_DID_LIST_LEN))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    lResult = &(pRepContext->DidInfoContextList[0]);
  }
  else
  {
    lResult = &(pRepContext->DidInfoContextList[pRepContext->DidInfoContextIdx]);
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc22Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc22RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* If the request length is even (SID is already extracted) and does not exceed the capacity of the ECU: */
  if( (Dcm_UtiIsEven(pMsgContext->reqDataLen))
    &&(pMsgContext->reqDataLen <= (Dcm_MsgLenType)(DCM_SVC_22_MAX_DID_LIST_LEN * 2u)) )
  {
    pRepContext->DidInfoContextIdx = 0u;                                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->NumDids           = 0u;                                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->DidIter           = 0u;                                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->ActualLength      = 0u;                                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->ReservedLength    = 0u;                                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */

    Dcm_RepeaterNextStep(pContext, DCM_SVC22_PROGRESS_DIDLOOKUP);                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP;
  }
  else
  {
    *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc22ReadDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22ReadDid(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext,
  Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  /* Try to read the DID data */
  lStdResult = Dcm_DidMgrReadDid(opStatus
                                ,pDataContext
                                ,pDidInfoContext
                                ,pDidOpTypeContext
                                ,ErrorCode);                                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */

  switch(lStdResult)
  {
  case DCM_E_PENDING:
    /* Try it the next task cycle */
    break;
# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
  case DCM_E_BUFFERTOOLOW:
    /* Notify the page buffer and try it later */
    break;
# endif
# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
  case DCM_E_FORCE_RCRRP:
    break;
# endif
  case DCM_E_OK:
    /* Go on with next DID */
    Dcm_RsrcMgrReleaseDidLock(DCM_RSRCMGR_DIDLOCK_OWNER_SID22);
    break;
  default: /* DCM_E_NOT_OK */
    /* Finish service processing immediately by sending the appropriate NRC */
    Dcm_RsrcMgrReleaseDidLock(DCM_RSRCMGR_DIDLOCK_OWNER_SID22);
    break;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc22UtiReadData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22UtiReadData(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc22RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType                   lStdResult;
  Dcm_DidMgrDidInfoContextPtrType  pDidInfoContext;

  pDidInfoContext = Dcm_Svc22GetDidInfoContext(pRepContext);                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(Dcm_RsrcMgrHasDidLock(DCM_RSRCMGR_DIDLOCK_OWNER_SID22) == FALSE)
  {
# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
    if(pDataContext->AvailLen < 2u)
    {
      lStdResult = DCM_E_BUFFERTOOLOW;
    }
    else
# endif
    {
      lStdResult = Dcm_RsrcMgrGetDidLock(opStatus, pDidInfoContext->Did, DCM_RSRCMGR_DIDLOCK_OWNER_SID22);

      if(lStdResult == DCM_E_OK)
      {
        Dcm_UtiProvideDataAsU16(pDataContext, pDidInfoContext->Did);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
        Dcm_DidMgrInitOpClassInfo(pDidInfoContext, DCM_DIDMGR_OPTYPE_READ);                                                                          /* SBSW_DCM_POINTER_WRITE_DIDINFOCONTEXT */
        lStdResult = DCM_E_LOOP;
      }
    }
  }
  else
  {
    /*
     *  Action/Return value | DCM_E_PENDING | DCM_E_BUFFERTOOLOW | DCM_E_OK
     * ---------------------+---------------+--------------------+----------
     *  call again          |      yes      |        yes         |   no
     *  data committed      |      no       |        yes         |   yes
     *  ready               |      no       |        no          |   yes
     */

    /* Try to read the DID data */
    lStdResult = Dcm_Svc22ReadDid(opStatus
                                 ,pDataContext
                                 ,pDidInfoContext
                                 ,&(pRepContext->DidOpTypeContext)
                                 ,ErrorCode);                                                                                                        /* SBSW_DCM_COMB_PTR_FORWARD */

    if(lStdResult == DCM_E_OK)
    {
      --pRepContext->NumDids;                                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
      if(pRepContext->NumDids != 0u)
      {
        /* Read next Did */
        pRepContext->DidInfoContextIdx++;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */

        lStdResult = DCM_E_LOOP;
      }
    }
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc22DidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22DidLookUp(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc22RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType                   lStdReturn;
  Dcm_DidMgrDidInfoContextPtrType  pDidInfoContext;

  pDidInfoContext = Dcm_Svc22GetDidInfoContext(pRepContext);                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(opStatus == DCM_INITIAL)
  {
    Dcm_UtiConsumeReqDataAsU16(pMsgContext, &(pDidInfoContext->Did));                                                                                /* SBSW_DCM_COMB_PTR_FORWARD */
  }

  lStdReturn = Dcm_DidMgrGetDidInfo(opStatus
                                   ,pDidInfoContext
                                   ,&(pRepContext->DidOpTypeContext)
                                   ,DCM_DIDMGR_OP_READ);                                                                                             /* SBSW_DCM_COMB_PTR_FORWARD */

  switch(lStdReturn)
  {
    case DCM_E_OK:
      ++(pRepContext->NumDids); /* register a supported DID */                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */

      lStdReturn = Dcm_DidMgrDynDidStateCheck(Dcm_NetGetConnHdlOfRxPduId(pMsgContext->rxPduId), pDidInfoContext, ErrorCode);                         /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_COMB_PTR_FORWARD */
      if(lStdReturn == DCM_E_OK)
      {
        ++(pRepContext->DidInfoContextIdx); /* next DID */                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdReturn = DCM_E_LOOP; /* proceed with next DID */
      } /* else DCM_E_NOT_OK (ErrorCode already set) */
      break;
    case DCM_E_PENDING:
      /* Try it the next task cycle */
      break;
    default: /* DCM_E_NOT_OK */
      /* Just skip this DID - request a new look-up loop */
      lStdReturn = DCM_E_LOOP;
      break;
  }

  /* If next DID look-up is requested: */
  if(lStdReturn == DCM_E_LOOP)
  {
    /* If all DIDs are validated: */
    if(pMsgContext->reqDataLen == 0u)
    {
      if(pRepContext->NumDids != 0u) /* any DID to process? */
      {
        pRepContext->DidIter           = pRepContext->NumDids;                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
        pRepContext->DidInfoContextIdx = 0u;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */

        Dcm_RepeaterNextStep(pContext, DCM_SVC22_PROGRESS_CHECKCONDITION); /* delegate job */                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
      else
      {
        *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdReturn = DCM_E_NOT_OK;
      }
    }
  }

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc22CheckCondition()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22CheckCondition(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc22RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType                   lStdResult = DCM_E_OK;
  Dcm_DidMgrDidInfoContextPtrType  pDidInfoContext;

  pDidInfoContext = Dcm_Svc22GetDidInfoContext(pRepContext);                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if(Dcm_DidMgrIsOpTypeSupported(Dcm_CfgDidMgrGetDidOpInfo(pDidInfoContext), DCM_DIDMGR_OPTYPE_READCHKCOND))
  {
    Dcm_DidMgrInitOpClassInfo(pDidInfoContext, DCM_DIDMGR_OPTYPE_READCHKCOND);                                                                       /* SBSW_DCM_POINTER_WRITE_DIDINFOCONTEXT */

    /* check conditions */
    lStdResult = Dcm_DidMgrReadCheckCond(opStatus
                                        ,pDidInfoContext
                                        ,&(pRepContext->DidOpTypeContext)
                                        ,ErrorCode);                                                                                                 /* SBSW_DCM_COMB_PTR_FORWARD */
  }/* else - not supported operation - go on with getLength */

  if(lStdResult == DCM_E_OK)
  {
    /* DCM_E_OK - go on with next DID */
    Dcm_RepeaterNextStep(pContext, DCM_SVC22_PROGRESS_GETLENGTH); /* next job */                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc22GetLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22GetLength(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc22RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType                   lStdReturn = DCM_E_OK;
  Dcm_DidMgrDidInfoContextPtrType  pDidInfoContext;

  pDidInfoContext = Dcm_Svc22GetDidInfoContext(pRepContext);                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */

  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if(Dcm_DidMgrIsOpTypeSupported(Dcm_CfgDidMgrGetDidOpInfo(pDidInfoContext), DCM_DIDMGR_OPTYPE_READLENGTH))
  {
    Dcm_DidMgrInitOpClassInfo(pDidInfoContext, DCM_DIDMGR_OPTYPE_READLENGTH);                                                                        /* SBSW_DCM_POINTER_WRITE_DIDINFOCONTEXT */

    lStdReturn = Dcm_DidMgrReadLength(opStatus
                                     ,pDidInfoContext
                                     ,&(pRepContext->DidOpTypeContext)
                                     ,ErrorCode);                                                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
  }

  if(lStdReturn == DCM_E_OK)
  {
    Dcm_MsgLenType lMaxLength;

    pRepContext->ActualLength   += 2u; /* cumulate DID length + DID itself */                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->ActualLength   += pDidInfoContext->DidLength;                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */

    pRepContext->ReservedLength += 2u;                                                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->ReservedLength += pDidInfoContext->ReservedLength;                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */

# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
    /* Note: Protocol->MaxLength includes the SID, so subtract it */
    lMaxLength = (Dcm_MsgLenType)(Dcm_NetGetProtObjOfTranspObj(Dcm_DiagGetTranspObj(pContext))->MaxLength) - 1u;                                     /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */
# else
    /* Note: pMsgContext->resMaxDataLen excludes the SID already */
    lMaxLength = pMsgContext->resMaxDataLen;
# endif

    /* Check for buffer overrun */
    if(pRepContext->ReservedLength <= lMaxLength)
    {
      pRepContext->DidIter--;                                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
      if(pRepContext->DidIter == 0u)
      {
        /* All DIDs processed without any errors. Prepare for reading
         * Now pRepContext->NumDids will be used as counter -> didIter not needed anymore!
         * pRepContext->DidIter = pRepContext->NumDids;
         */
        pRepContext->DidInfoContextIdx = 0u;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */

        Dcm_RepeaterNextStep(pContext, DCM_SVC22_PROGRESS_READDATA); /* delegate job */                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
      else
      {
        pRepContext->DidInfoContextIdx++; /* next DID */                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */

        Dcm_RepeaterNextStep(pContext, DCM_SVC22_PROGRESS_CHECKCONDITION); /* start again with next DID  */                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
      lStdReturn = DCM_E_LOOP; /* speed up processing */
    }
    else
    {
      /* the configured buffer will not be able to hold all of the data -> notify the client */
      *ErrorCode = DCM_E_RESPONSETOOLONG;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK; /* finish service processing immediately */
    }
  }/* else - DCM_E_PENDING, DCM_E_NOT_OK (ErrorCode already set) */

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc22ReadData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22ReadData(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc22RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  Dcm_DebugAssert((pMsgContext->resDataLen == 0u), DCM_SID_INTERNAL, DCM_E_PARAM);                                                                   /* COV_DCM_RTM_DEV_DEBUG XF */

  /* Start the paged-buffer to copy the DID data */
  Dcm_PagedBufferStart(pMsgContext, pRepContext->ActualLength);                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
  return DCM_E_STOP_REPEATER;
# else
  Std_ReturnType           lStdResult;
  Dcm_DiagDataContextType  lDataContext;

  Dcm_UtiInitDataContext(&lDataContext, Dcm_UtiGetResData(pMsgContext), pMsgContext->resMaxDataLen);                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_POINTER_INIT_DATA_CONTEXT */

  lStdResult = Dcm_Svc22UtiReadData(opStatus, &lDataContext, ErrorCode, pRepContext);                                                                /* SBSW_DCM_COMB_PTR_FORWARD */

  /* Commit copied data */
  Dcm_UtiProvideResData(pMsgContext, lDataContext.Usage);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */

  return lStdResult;
# endif
}
#endif /* (DCM_SVC_22_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_24_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc24Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc24Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc24RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType                lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* If valid service request length: */
  if(pMsgContext->reqDataLen == 2u)
  {
    /* Prepare for DID look up */
    Dcm_UtiConsumeReqDataAsU16(pMsgContext, &(pRepContext->DidInfoContext.Did));                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Initialize DID look up */
    Dcm_RepeaterNextStep(pContext, DCM_SVC24_PROGRESS_DIDLOOKUP);                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP;
  }
  else
  {
    /* Invalid length detected -> send NRC 0x13 */
    *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  /* Return control to DCM core */
  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc24ExecuteOp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc24ExecuteOp(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc24RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;

  lStdResult = Dcm_DidMgrGetScalingInfo(opStatus
                                       ,pMsgContext
                                       ,&(pRepContext->DidInfoContext)
                                       ,&(pRepContext->DidOpTypeContext)
                                       ,ErrorCode);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc24DidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc24DidLookUp(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc24RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdReturn;

  lStdReturn = Dcm_DidMgrGetDidInfo(opStatus
                                   ,&(pRepContext->DidInfoContext)
                                   ,&(pRepContext->DidOpTypeContext)
                                   ,DCM_DIDMGR_OP_SCALINGINFO);                                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */
  if(lStdReturn == DCM_E_OK)
  {
    /*
     * Currently no state checks are possible on scaling DIDs in AR 4.x:
     * lStdReturn = Dcm_DidMgrStaticDidStateCheck(Dcm_NetGetConnHdlOfRxPduId(pMsgContext->rxPduId), Dcm_CfgDidMgrGetDidOpInfo(pDidInfoContext)->ExecCondRef, ErrorCode);
     * if(lStdReturn == DCM_E_OK)
     */
    {
      Dcm_UtiProvideResData(pMsgContext, 2);    /* commit the DID only. The scaling record size will be calculated on the fly */                     /* SBSW_DCM_PARAM_PTR_FORWARD */

      Dcm_DidMgrInitOpClassInfo(&(pRepContext->DidInfoContext), DCM_DIDMGR_OPTYPE_GETSCALING);                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_RepeaterNextStep(pContext, DCM_SVC24_PROGRESS_EXECUTEOP); /* delegate job */                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdReturn = DCM_E_LOOP;/* speed up processing */
    }/* else - ErrorCode already assigned */
  }
  else if(lStdReturn == DCM_E_PENDING)
  {
    /* DID verification takes longer -> retry later */
  }
  else
  {
    /* DID is not supported -> send NRC 0x31 */
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }

  return lStdReturn; /* finish service processing immediately */
}
#endif /* (DCM_SVC_24_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc27SecLevelInfoGetEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgSvc27SecLevelInfoGetEntry(
  uint8_least secLev,
  CONSTP2VAR(Dcm_CfgSvc27SecLevelInfoPtrType, AUTOMATIC, AUTOMATIC) pSecLevelInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lResult;

  if (Dcm_DebugDetectRuntimeError(secLev >= DCM_CFGSVC27SECLEVELINFO_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);

    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_NOT_OK;
  }
  else
  {
    *pSecLevelInfo = &Dcm_CfgSvc27SecLevelInfo[secLev];                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_OK;
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc27CounterSet()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27CounterSet(
  uint8_least secLev,
  uint8 value
  )
{
  uint8_least lCounterIdx = Dcm_Svc27GetCounterIdx(secLev);

  DCM_IGNORE_UNREF_PARAM(secLev);                                                                                                                    /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

# if (DCM_SVC_27_MULTI_ATTEMPT_COUNTER_ENABLED == STD_ON)
  if (Dcm_DebugDetectRuntimeError(lCounterIdx >= DCM_SVC_27_NUM_ATTEMPT_COUNTERS))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
# endif
  {
    Dcm_SingletonContext.Diag.Services.Svc27.AttemptCount[lCounterIdx] = value;                                                                      /* SBSW_DCM_POINTER_WRITE_ATTEMPTCOUNT */
  }
}

/**********************************************************************************************************************
 *  Dcm_Svc27CounterInc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27CounterInc(
  uint8_least secLev
  )
{
  uint8 lValue = Dcm_Svc27CounterGet(secLev);

  if(lValue < Dcm_UtiMaxValueOfUintType(uint8))
  {
    Dcm_Svc27CounterSet(secLev, (uint8)(lValue + 1u));
  }
}

/**********************************************************************************************************************
 *  Dcm_Svc27TimerSet()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27TimerSet(
  uint8_least secLev,
  Dcm_TmrTimerCntrMemType value
  )
{
  uint8_least lTimerIdx = Dcm_Svc27GetTimerIdx(secLev);

  DCM_IGNORE_UNREF_PARAM(secLev);                                                                                                                    /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

# if (DCM_SVC_27_MULTI_DELAY_TIMER_ENABLED == STD_ON)
  if(Dcm_DebugDetectRuntimeError(lTimerIdx >= DCM_SVC_27_NUM_DELAY_TIMERS))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
# endif
  {
    /* Enter critical section (Reason: Avoid interrupt from Dcm_OnTimeoutSecurityAccess) */
    Dcm_SplitTaskEnterCS();
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/

    Dcm_SingletonContext.Diag.Services.Svc27.DelayTime[lTimerIdx] = value;                                                                           /* SBSW_DCM_POINTER_WRITE_DELAYTIME_SEC */

    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_SplitTaskLeaveCS();
  }
}

/**********************************************************************************************************************
 *  Dcm_Svc27TimerStart()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27TimerStart(
  uint8_least secLev,
  Dcm_TmrTimerCntrMemType value
  )
{
  /* Start the appropriate security timer */
  Dcm_Svc27TimerSet(secLev, value);

  if(!Dcm_TmrIsTimerRunning(DCM_TMR_CONTEXT_ID_SECURITY))
  {
    /* Start the base security timer */
    Dcm_TmrStartTimer(DCM_TMR_ID_SECURITY, 1u);
  }
}

/**********************************************************************************************************************
 *  Dcm_Service27Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc27RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType                lStdResult;
  Dcm_DiagSubServiceRefOptType  lSubSvcRef;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                                   ,Dcm_CfgSvc27SubFuncLookUpTable
                                                   ,Dcm_CfgSvc27SubFuncExecPrecondTable
                                                   ,Dcm_Svc27ReqLengthGetter
                                                   ,Dcm_Svc27SubFuncSequenceChecker
                                                   ,&lSubSvcRef
                                                   ,ErrorCode);                                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */

  /* Initialize service processor context for further processing */
  pRepContext->ErrorCode = DCM_E_POSITIVERESPONSE;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
  pRepContext->SubSvcRef = (Dcm_DiagSubServiceRefMemType)lSubSvcRef;/* Store working sub-function reference (also in negative response cases) */     /* SBSW_DCM_PARAM_PTR_WRITE */
  pRepContext->SecLvlRef = Dcm_Svc27GetSecLvlRef(lSubSvcRef);                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */

  if(lStdResult == DCM_E_OK)
  {
    if(Dcm_Svc27IsSeedRequest(pRepContext->SubSvcRef) == TRUE)                                                                                       /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
    {
      Dcm_RepeaterNextStep(pContext, DCM_SVC27_PROGRESS_SEEDPROCESSOR);                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      Dcm_RepeaterNextStep(pContext, DCM_SVC27_PROGRESS_KEYPROCESSOR);                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
    }

    lStdResult = DCM_E_LOOP; /* Speed up processing */
  }
  /* If the requested key has wrong length or the sub-function sequence was not correct: */
  else if( (*ErrorCode == DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT)
    ||(*ErrorCode == DCM_E_REQUESTSEQUENCEERROR))
  {
    if( (Dcm_Svc27IsKeyRequest(pRepContext->SubSvcRef) == TRUE) /* wrong key length is an invalid key! */                                            /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
      &&(Dcm_Svc27IsKeyRequestExpected() == TRUE) )                                                                                                  /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
    {
# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
      /* Prevent multiple calls to application due to overflow */
      if(Dcm_Svc27CounterGet(pRepContext->SecLvlRef) < Dcm_UtiMaxValueOfUintType(uint8))
      {
        Dcm_RepeaterNextStep(pContext, DCM_SVC27_PROGRESS_SETATTEMPTCNTR);                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
        pRepContext->ErrorCode = *ErrorCode; /* used in next step */                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_LOOP;/* Speed up processing */
      }
# endif
      /* Increment counter after notification check */
      Dcm_Svc27CounterInc(pRepContext->SecLvlRef);
    }
    /* Send prepared NRC immediately */
  }
  else
  {
    /* Send prepared NRC immediately */
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service27SeedProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service27SeedProcessor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc27RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* If the attempt counters are currently read or written by the application: */
# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  if(Dcm_TskGetEvent(DCM_TSK_ID_SVC27) != 0u)
  {
    lStdResult = DCM_E_PENDING;
  }
  else
# endif
  {
    pRepContext->IsZeroSeed = FALSE;                                                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */

    /* If the security timer is active: */
    if(Dcm_Svc27TimerActive(pRepContext->SecLvlRef) == TRUE)                                                                                         /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
    {
      /* Send the NRC 0x37 */
      *ErrorCode = DCM_E_REQUIREDTIMEDELAYNOTEXPIRED;                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
    else
    {
      /* If seed level not yet unlocked: */
      if (0u == (Dcm_StateGetSecurity() & Dcm_UtiGetBitFromIndex(Dcm_CfgStateGroupMemType, (pRepContext->SecLvlRef + 1u))))
      {
        /* New seed request / repetition of the same seed request. Get application generated seed */
        Dcm_RepeaterNextStep(pContext, DCM_SVC27_PROGRESS_SEEDREPEATER);                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
        lStdResult = DCM_E_LOOP;/* Speed up processing */
      }
      else
      {
        Dcm_CfgNetBufferSizeMemType lSeedSize = Dcm_CfgSvc27SecLevelInfo[pRepContext->SecLvlRef].SeedResLength;

        lStdResult = Dcm_UtiMsgContextVerifySize(pMsgContext, lSeedSize, ErrorCode);                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */

        if(lStdResult == DCM_E_OK)                                                                                                                   /* COV_DCM_RTM_RUNTIME_CHECK TX */
        {
          /* return zero seed */
          pRepContext->IsZeroSeed = TRUE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
          Dcm_UtiMemSetUintX(Dcm_UtiGetResData(pMsgContext), Dcm_MsgItemType, 0x00u, lSeedSize);                                                     /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */ /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_POINTER_WRITE_MESSAGE_CONTEXT_RESBUFFER */
          Dcm_UtiProvideResData(pMsgContext, lSeedSize);                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
        }
      }
    }
  }
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_Service27KeyProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service27KeyProcessor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc27RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* If the attempt counters are currently read or written by the application: */
# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  if(Dcm_TskGetEvent(DCM_TSK_ID_SVC27) != 0u)
  {
    lStdResult = DCM_E_PENDING;
  }
  else
# endif
  {
    /* Get application key comparator */
    Dcm_RepeaterNextStep(pContext, DCM_SVC27_PROGRESS_KEYREPEATER);                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP; /* Speed up processing */
  }
  return lStdResult;
}

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27UtiGetAttemptCntr()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27UtiGetAttemptCntr(
  Dcm_OpStatusType opStatus,
  P2VAR(uint32, AUTOMATIC, DCM_VAR_NOINIT) levelMask
  )
{
  Std_ReturnType  lResult;
  uint8           lAttemptCount;
  uint8_least     lSecLvlIter;

  /* For each security level: */
  for (lSecLvlIter = 0u; lSecLvlIter < DCM_CFGSVC27SECLEVELINFO_SIZE; ++lSecLvlIter)
  {
    /* If the attempt counter for that specific security level is not already read: */
    if(Dcm_UtiBitOpTest(uint32, *levelMask, Dcm_UtiGetBitFromIndex(uint32, lSecLvlIter)))
    {
      Dcm_CfgSvc27SecLevelInfoPtrType pSecLevelInfo;
      Dcm_NegativeResponseCodeType    lNrc;

      lResult = Dcm_CfgSvc27SecLevelInfoGetEntry(lSecLvlIter, &pSecLevelInfo, &lNrc);                                                                /* SBSW_DCM_COMB_PTR_FORWARD */

      if(lResult == DCM_E_OK)                                                                                                                        /* COV_DCM_RTM_RUNTIME_CHECK TX */
      {
        /* Try to read the attempt counter from the application */
        lResult = pSecLevelInfo->GetAttemptCntrFunc(opStatus, &lAttemptCount);                                                                       /* SBSW_DCM_CALL_FUNCPTR_SVC27SECLEVEL */

        if(lResult == DCM_E_OK)
        {
          /*
           * Note: Using critical sections is not necessary here because the features "power on delay" and
           *       "external attempt counter storage" are used mutually exclusive per security level.
           */

          /* Mark the security level to prevent that this API is called again */
          Dcm_UtiBitOpClr(uint32, *levelMask, Dcm_UtiGetBitFromIndex(uint32, lSecLvlIter));                                                          /* SBSW_DCM_PARAM_PTR_WRITE */

          /* If the already initialized attempt counter has to be updated: */
          if(lAttemptCount != 0u)
          {
            /* Store the attempt counter */
            Dcm_Svc27CounterSet(lSecLvlIter, lAttemptCount);

            /* If the current attempt counter value exceeded the maximum number of allowed attempts: */
            if(lAttemptCount >= Dcm_CfgStateSecurityInfo[lSecLvlIter].NumAttempts)
            {
              /* Set the delay timer value. The timer will be started later with that value */
              Dcm_Svc27TimerSet(lSecLvlIter, Dcm_CfgStateSecurityInfo[lSecLvlIter].DelayTimeInvKey);
            }
          }
        }/* If more time needed: */
        else if (lResult == DCM_E_PENDING)
        {
          /* Try it later */
        }
        else /* If something went wrong: */
        {
          Dcm_DebugAssert((lResult == DCM_E_NOT_OK), DCM_SID_GETSECURITYATTEMPTCOUNTER, DCM_E_INTERFACE_RETURN_VALUE);

          /* Mark the security level to prevent that this API is called again */
          Dcm_UtiBitOpClr(uint32, *levelMask, Dcm_UtiGetBitFromIndex(uint32, lSecLvlIter));                                                          /* SBSW_DCM_PARAM_PTR_WRITE */

          /* Set the attempt counter to uninitialized value */
          Dcm_Svc27CounterSet(lSecLvlIter, 0xFF);

          /* If delay time on failed read of attempt counter is enabled: */
          if(Dcm_CfgStateSecurityInfo[lSecLvlIter].ReloadOnZeroDelay == TRUE)
          {
            /* If the configured delay time is zero: */
            if(Dcm_CfgStateSecurityInfo[lSecLvlIter].ReloadTime == 0u)
            {
              /* Set the delay timer value to infinity */
              Dcm_Svc27ReloadReadFailedSet(lSecLvlIter);
              Dcm_Svc27TimerSet(lSecLvlIter, 1u);
            }
            else
            {
              /* Otherwise set the configured delay timer value */
              Dcm_Svc27TimerSet(lSecLvlIter, Dcm_CfgStateSecurityInfo[lSecLvlIter].ReloadTime);
            }
          }
        }
      }
    }
  }
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27ReadAttemptCounter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27ReadAttemptCounter(
  Dcm_TskEventContextPtrType pEventContext
  )
{
  /* Restore the attempt counter values from the application */
  Dcm_Svc27UtiGetAttemptCntr(Dcm_SingletonContext.Diag.Services.Svc27.GetAttOpStatus
                            ,&Dcm_SingletonContext.Diag.Services.Svc27.GetAttCntrEventMask);                                                         /* SBSW_DCM_POINTER_FORWARD_GLOBAL */

  /* If all attempt counters were read */
  if(Dcm_SingletonContext.Diag.Services.Svc27.GetAttCntrEventMask == 0u)
  {
    uint8_least lTmrIter;

    for(lTmrIter = 0; lTmrIter < DCM_SVC_27_NUM_DELAY_TIMERS; ++lTmrIter)
    {
      /* If the corresponding security timer value is not zero: */
      if(Dcm_Svc27TimerGet(lTmrIter) != 0u)
      {
        /* Start the base timer which starts the appropriate security timers */
        Dcm_TmrStartTimer(DCM_TMR_ID_SECURITY, 1u);
        break;
      }
    }
    /* Reset operation status */
    Dcm_SingletonContext.Diag.Services.Svc27.GetAttOpStatus = DCM_INITIAL;
  }
  else
  {
    /* Otherwise resume the job next task cycle */
    Dcm_TskSetLocalEvent(pEventContext->PostEv, pEventContext->Ev);                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_SingletonContext.Diag.Services.Svc27.GetAttOpStatus = DCM_PENDING;
  }
}
# endif

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27WriteAttemptCounter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27WriteAttemptCounter(
  Dcm_TskEventContextPtrType pEventContext
  )
{
  /* Notify the application about changed attempt counters */
  Dcm_Svc27UtiSetAttemptCntr(Dcm_SingletonContext.Diag.Services.Svc27.SetAttOpStatus
                            ,&Dcm_SingletonContext.Diag.Services.Svc27.SetAttCntrEventMask);                                                         /* SBSW_DCM_POINTER_FORWARD_GLOBAL */

  /* If all attempt counters were written: */
  if(Dcm_SingletonContext.Diag.Services.Svc27.SetAttCntrEventMask == 0u)
  {
    /* Finish the job and reset the opStatus for next write cycle */
    Dcm_SingletonContext.Diag.Services.Svc27.SetAttOpStatus = DCM_INITIAL;
  }
  else
  {
    /* Otherwise resume the job next task cycle and notify application for the subsequent call via opStatus parameter */
    Dcm_TskSetLocalEvent(pEventContext->PostEv, pEventContext->Ev);                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_SingletonContext.Diag.Services.Svc27.SetAttOpStatus = DCM_PENDING;
  }
}
# endif

/**********************************************************************************************************************
 *  Dcm_Service27SeedRepeater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27SeedRepeater(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc27RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType                  lResult;
  Dcm_CfgSvc27SecLevelInfoPtrType pSecLevelInfo;

  lResult = Dcm_CfgSvc27SecLevelInfoGetEntry(pRepContext->SecLvlRef, &pSecLevelInfo, ErrorCode);                                                     /* SBSW_DCM_COMB_PTR_FORWARD */

  if (lResult == DCM_E_OK)                                                                                                                           /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    lResult = Dcm_UtiMsgContextVerifySize(pMsgContext, pSecLevelInfo->SeedResLength, ErrorCode);                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */

    if (lResult == DCM_E_OK)                                                                                                                         /* COV_DCM_RTM_RUNTIME_CHECK TX */
    {
      /* Read the seed of the appropriate security level */
      switch (pSecLevelInfo->GetSeedFuncClass)
      {
      case DCM_SVC27_OPCLS_SEED_WITHOUT_ADR:
        lResult = ((Dcm_Svc27OpFuncSeedWoAdr)pSecLevelInfo->GetSeedFunc)(opStatus                                                                    /* PRQA S 0313 */ /* MD_Dcm_0313 */
          , Dcm_UtiGetResData(pMsgContext)                                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
          , ErrorCode);                                                                                                                              /* SBSW_DCM_CALL_FUNCPTR_SVC27GETSEED */
        break;
      case DCM_SVC27_OPCLS_SEED_WITH_ADR:
        lResult = ((Dcm_Svc27OpFuncSeedWAdr)pSecLevelInfo->GetSeedFunc)(Dcm_UtiGetReqData(pMsgContext)                                               /* PRQA S 0313 */ /* MD_Dcm_0313 */
          , opStatus
          , Dcm_UtiGetResData(pMsgContext)                                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
          , ErrorCode);                                                                                                                              /* SBSW_DCM_CALL_FUNCPTR_SVC27GETSEED */
        break;
      default:                                                                                                                                       /* COV_DCM_RTM_UNREACHABLE X */
        DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                            /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

        *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
        lResult = DCM_E_NOT_OK;
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG);
        break;
      }

      switch (lResult)
      {
      case DCM_E_OK:
        /* Send response */
        Dcm_UtiProvideResData(pMsgContext, pSecLevelInfo->SeedResLength);                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
        break;
      case DCM_E_PENDING:
        /* Retry later */
        break;
      case DCM_E_NOT_OK:
        Dcm_UtiHandleApplNrc(lResult, ErrorCode, DCM_E_CONDITIONSNOTCORRECT);                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
        break;
      default:
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
        *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
        lResult = DCM_E_NOT_OK;
        break;
      }
    }
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_Service27KeyRepeater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27KeyRepeater(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_OpStatusType opStatus,
  Dcm_ReadOnlyMsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc27RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType                  lResult;
  Dcm_NegativeResponseCodeType    lNrc;
  Dcm_CfgSvc27SecLevelInfoPtrType pSecLevelInfo;

  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lResult = Dcm_CfgSvc27SecLevelInfoGetEntry(pRepContext->SecLvlRef, &pSecLevelInfo, ErrorCode);                                                     /* SBSW_DCM_COMB_PTR_FORWARD */

  if (lResult == DCM_E_OK)                                                                                                                           /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    lNrc = DCM_E_POSITIVERESPONSE;

    /* Let the application compare the given key data */
    lResult = pSecLevelInfo->CompareKeyFunc(Dcm_UtiGetReqData(pMsgContext)                                                                           /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                           ,opStatus
                                           ,&lNrc
                                           );                                                                                                        /* SBSW_DCM_CALL_FUNCPTR_SVC27SECLEVEL */

    switch(lResult)
    {
      /*---------------------------*/
      case DCM_E_OK:
      /*---------------------------*/
# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
        if(Dcm_Svc27CounterGet(pRepContext->SecLvlRef) != 0u)
        {
          /* Notify the application about new attempt counter */
          Dcm_RepeaterNextStep(pContext, DCM_SVC27_PROGRESS_SETATTEMPTCNTR);                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
          lResult = DCM_E_LOOP;
        }
# endif
        /* Reset the attempt counter of this security level after notification check */
        Dcm_Svc27CounterReset(pRepContext->SecLvlRef);

        break;
      /*---------------------------*/
      case DCM_E_PENDING:
      /*---------------------------*/
        /* Try later */
        break;
      /*---------------------------*/
      case DCM_E_NOT_OK:
      /*---------------------------*/
        /* If an error occurred set the NRC given by the application */
        Dcm_UtiHandleApplNrc(lResult, &lNrc, DCM_E_CONDITIONSNOTCORRECT);                                                                            /* SBSW_DCM_POINTER_FORWARD_STACK */
        pRepContext->ErrorCode = lNrc; /* will be used in next step */                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
        /* fall through */
      case DCM_E_COMPARE_KEY_FAILED:                                                                                                                 /* PRQA S 2003 */ /* MD_Dcm_Optimize_2003 */
        /* Increment the attempt counter */
        Dcm_Svc27CounterInc(pRepContext->SecLvlRef);

        /* Notify application about new attempt counter */
        /* No prevention needed, since calling with the same counter is rare */
        Dcm_RepeaterNextStep(pContext, DCM_SVC27_PROGRESS_CHECKATTEMPTSEXCEEDED);                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
        lResult = DCM_E_LOOP;
        break;
      /*---------------------------*/
      default:
      /*---------------------------*/
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);

        *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
        lResult = DCM_E_NOT_OK;
        break;
    }
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_Service27CheckAttemptsExceededRepeater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27CheckAttemptsExceededRepeater(
  Dcm_OpStatusType opStatus,
  Dcm_ReadOnlyMsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc27RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType  lResult;
# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  uint32          lMask = Dcm_UtiGetBitFromIndex(uint32, pRepContext->SecLvlRef);
# endif

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  /* Notify the application about the new attempt counter value */
  Dcm_Svc27UtiSetAttemptCntr(opStatus, &lMask);                                                                                                      /* SBSW_DCM_POINTER_FORWARD_STACK */

  /* If the setting of the attempt counter was not successful: */
  if(lMask != 0u)
  {
    /* Try it later */
    lResult = DCM_E_PENDING;
  }
  else
# endif
  {
    /* If the number of allowed attempt were exceeded: */
    if( (Dcm_CfgStateSecurityInfo[pRepContext->SecLvlRef].NumAttempts != 0u) /* Consider only levels with attempt monitoring */
      && (Dcm_Svc27CounterGet(pRepContext->SecLvlRef) >= Dcm_CfgStateSecurityInfo[pRepContext->SecLvlRef].NumAttempts))
    {
      /* Set NRC 0x36 if not already set and start the timer */
      /* This NRC will be ignored if ErrorCode is already set due to failed compare key function */
      *ErrorCode = DCM_E_EXCEEDNUMBEROFATTEMPTS;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */

      Dcm_Svc27TimerStart(pRepContext->SecLvlRef, Dcm_CfgStateSecurityInfo[pRepContext->SecLvlRef].DelayTimeInvKey);
    }
    else
    {
      /* Otherwise set NRC 0x35 if not already set */
      /* This NRC will be ignored if ErrorCode is already set due to failed compare key function */
      *ErrorCode = DCM_E_INVALIDKEY;                                                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
    }

    if (pRepContext->ErrorCode != DCM_E_POSITIVERESPONSE)
    {
      /* Use previously set ErrorCode if available */
      *ErrorCode = pRepContext->ErrorCode;                                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
    }

    lResult = DCM_E_NOT_OK;
  }

  return lResult;
}

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27SetAttemptCntrRepeater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27SetAttemptCntrRepeater(
  Dcm_OpStatusType opStatus,
  Dcm_ReadOnlyMsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc27RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType  lResult;
  uint32          lMask = Dcm_UtiGetBitFromIndex(uint32, pRepContext->SecLvlRef);

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Notify the application about the new attempt counter value */
  Dcm_Svc27UtiSetAttemptCntr(opStatus, &lMask);                                                                                                      /* SBSW_DCM_POINTER_FORWARD_STACK */

  /* If the setting of the attempt counter was successful: */
  if(lMask == 0u)
  {
    /* Finish the job */
    if (pRepContext->ErrorCode == DCM_E_POSITIVERESPONSE)
    {
      lResult = DCM_E_OK;
    }
    else
    {
      *ErrorCode = pRepContext->ErrorCode;                                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
      lResult = DCM_E_NOT_OK;
    }
  }
  else
  {
    /* Otherwise try it later */
    lResult = DCM_E_PENDING;
  }

  return lResult;
}
# endif
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_29_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc29SubFuncInfoGetEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgSvc29SubFuncInfoGetEntry(
  Dcm_DiagSubServiceRefOptType subSvcRef,
  CONSTP2VAR(Dcm_CfgSvc29SubFuncInfoPtrType, AUTOMATIC, AUTOMATIC) pSubFuncInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lResult;

  if (Dcm_DebugDetectRuntimeError(subSvcRef >= DCM_CFGSVC29SUBFUNCINFO_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);

    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_NOT_OK;
  }
  else
  {
    *pSubFuncInfo = &Dcm_CfgSvc29SubFuncInfo[subSvcRef];                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_OK;
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc29Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType                lStdResult;
  Dcm_DiagSubServiceRefOptType  lSubSvcRef;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
  /* Check if callback processing state is idle */
  if(Dcm_Svc29GetCbkProcessingState() != DCM_SVC29_CBK_PROC_STATE_IDLE)
  {
    /* The asynchronous callback processing is still active for another tester */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
# endif
  {
    /* Get subfunction id before it gets consumed */
    pRepContext->SubSvcId = Dcm_UtiGetReqDataAsU8(pMsgContext);                                                                                      /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */ /* SBSW_DCM_PARAM_PTR_WRITE */

    lStdResult = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                                     ,Dcm_CfgSvc29SubFuncLookUpTable
                                                     ,Dcm_CfgSvc29SubFuncExecPrecondTable
                                                     ,Dcm_Svc29ReqLengthGetter
                                                     ,Dcm_Svc29SubFuncSequenceChecker
                                                     ,&lSubSvcRef
                                                     ,ErrorCode);                                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */

    /* Initialize service processor context for further processing */
    pRepContext->SubSvcRef = (Dcm_DiagSubServiceRefMemType)lSubSvcRef; /* Store working sub-function reference (also in negative response cases) */  /* SBSW_DCM_PARAM_PTR_WRITE */
# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
    pRepContext->AuthInfoHdl = Dcm_NetGetAuthInfoRef(Dcm_DiagGetTranspObj(pContext)->ConnHdl);                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
# endif

    Dcm_Svc29SetRxPduId(pMsgContext->rxPduId);

    if (lStdResult == DCM_E_OK)
    {
      Dcm_RepeaterNextStep(pContext, DCM_SVC29_PROGRESS_SUBFUNCTION); /* delegate job */                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_LOOP; /* speed up processing */
    }
  }
  return lStdResult;
}

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON) || (DCM_SVC_29_04_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29CbkResultDispatcher()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29CbkResultDispatcher(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult = DCM_E_LOOP;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  switch(Dcm_Svc29GetCbkProcessingState())
  {
  case DCM_SVC29_CBK_PROC_STATE_VERIFY_CERT_DONE:
    Dcm_RepeaterNextStep(pContext, DCM_SVC29_PROGRESS_CERTVERIFIED);                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_SVC29_CBK_PROC_STATE_GENERATE_CHALLENGE_DONE:
      Dcm_RepeaterNextStep(pContext, DCM_SVC29_PROGRESS_CHALLENGEGEN);                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
#  if (DCM_SVC_29_02_SUPPORT_ENABLED == STD_ON)
  case DCM_SVC29_CBK_PROC_STATE_SIGN_CHALLENGE_DONE:
    Dcm_RepeaterNextStep(pContext, DCM_SVC29_PROGRESS_SUBFUNC02_CHALLENGESIGNED);                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
#  endif
  case DCM_SVC29_CBK_PROC_STATE_VERIFY_POOW_DONE:
    Dcm_RepeaterNextStep(pContext, DCM_SVC29_PROGRESS_SUBFUNC03_ROLEREAD);                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  default:
    /* Callback not triggered yet, retry later */
    lStdResult = DCM_E_PENDING;
    break;
  }
  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc29SubFuncHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29SubFuncHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType                 lStdResult;
  Dcm_CfgSvc29SubFuncInfoPtrType pSubFuncInfo;

  lStdResult = Dcm_CfgSvc29SubFuncInfoGetEntry(pRepContext->SubSvcRef, &pSubFuncInfo, ErrorCode);                                                    /* SBSW_DCM_COMB_PTR_FORWARD */

  if (lStdResult == DCM_E_OK)                                                                                                                        /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    lStdResult = pSubFuncInfo->SubSvcFunc(pContext, opStatus, pMsgContext, ErrorCode);                                                               /* SBSW_DCM_CALL_FUNCPTR_SVC29SUBFUNC */
  }

  return lStdResult;
}

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchAuthentication()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_ModeSwitchAuthentication(
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  uint8 mode
  )
{
  if (Dcm_DebugDetectRuntimeError(authInfoRef >= DCM_CFGAUTHMGRNETCONNINFO_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
  {
    (void)Dcm_CfgAuthMgrNetConnInfo[authInfoRef].AuthStateModeSwitchOpFunc(mode);                                                                    /* SBSW_DCM_CALL_FUNCPTR_AUTHMODESWITCH */
  }
}
# endif

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON) || (DCM_SVC_29_04_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29KeyMSetCertificate()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29KeyMSetCertificate(
  KeyM_CertificateIdType certId,
  P2CONST(KeyM_CertDataType, AUTOMATIC, DCM_APPL_DATA) pCertificateData,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;
  /* Attempt to store cerificate */
  Std_ReturnType lKeyMResult = KeyM_SetCertificate(certId, pCertificateData);                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* Evalute result and respond accordingly */
  switch(lKeyMResult)
  {
  case E_OK:
    lStdResult = DCM_E_OK;
    break;
  case KEYM_E_KEY_CERT_SIZE_MISMATCH:
    *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  default:
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    break;
  }

  return lStdResult;
}
# endif

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON) || (DCM_SVC_29_04_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29KeyMVerifyCertificate()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29KeyMVerifyCertificate(
  Dcm_ContextPtrType pContext,
  KeyM_CertificateIdType certId,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;
  Std_ReturnType lKeyMResult;

  /* Set callback processing state to verify certificate */
  Dcm_Svc29SetCbkProcessingState(DCM_SVC29_CBK_PROC_STATE_VERIFY_CERT);

  /* Attempt to start async job to verify the certificate */
  lKeyMResult = KeyM_VerifyCertificate(certId);

  /* Evaluate result and respond accordingly */
  switch(lKeyMResult)
  {
  case E_OK:
    /* If async job was accepted change progress state */
    Dcm_RepeaterNextStep(pContext, DCM_SVC29_PROGRESS_WAITCERTVERIFY);                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_PENDING;
    break;
  case KEYM_E_BUSY:
    *ErrorCode = DCM_E_BUSYREPEATREQUEST;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  default:
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    break;
  }

  return lStdResult;
}
# endif

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29GeneralNrcCheck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc29GeneralNrcCheck(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode                                                                                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
#  if (DCM_MODE_AUTH_GENERAL_NRC_ENABLED == STD_ON)
  Dcm_NegativeResponseCodeType lNrcIgnore;
#  endif

  /* Check if the error pertains to Certificate Verification Failed */
  switch(*ErrorCode)
  {
    case DCM_E_CVF_INVALIDTIMEPERIOD:
    case DCM_E_CVF_INVALIDSIGNATURE:
    case DCM_E_CVF_INVALIDCHAINOFTRUST:
    case DCM_E_CVF_INVALIDTYPE:
    case DCM_E_CVF_INVALIDFORMAT:
    case DCM_E_CVF_INVALIDCONTENT:
    case DCM_E_CVF_INVALIDSCOPE:
    case DCM_E_CVF_INVALIDCERTIFICATEREVOKED:
#  if (DCM_MODE_AUTH_GENERAL_NRC_ENABLED == STD_ON)
      /* If mode rule enables General NRC, override Error Code to General NRC */
      if(Dcm_ModeCheck(DCM_MODE_AUTH_SEND_GENERAL_NRC_MODERULE_REF, &lNrcIgnore) == DCM_E_OK)                                                        /* SBSW_DCM_POINTER_FORWARD_STACK */
      {
        *ErrorCode = DCM_AUTHMGR_GENERAL_NRC;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
      }
#  endif
     /* fall through */
    case DCM_E_OWNERSHIPVERIFICATIONFAILED:                                                                                                          /* PRQA S 2003 */ /* MD_Dcm_Optimize_2003 */
      /* Set IdsM security event */
      Dcm_DebugReportSecurityEvent(pContext->ThreadId, DCM_DEBUG_SEV_CERTIFICATE_FAILURE);
      break;

    default:
      /* Otherwise - proceed with negative response code */
    break;
  }
}
# endif

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29FinalizeSequenceStartReq()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29FinalizeSequenceStartReq(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;

  /* If response buffer can hold the EPK length field */
  if(pMsgContext->resMaxDataLen >= DCM_SVC29_REQ_LENGTH_FIELD_BYTELEN)
  {
    /* Append lengthOfEphemeralPublicKeyServer bytes(uint16) on response */
    Dcm_UtiProvideResDataAsU16(pMsgContext, 0x00u);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Get challenge length from request */
    Dcm_Svc29SetLengthChallengeSwapBuffer(Dcm_UtiGetResDataAsU16At(pMsgContext, DCM_SVC29_CHALLENGE_LEN_INDEX));

    /* Copy challenge data from response buffer to special challenge buffer (needed for subfunction 0x03) */
    Dcm_UtiMemCopySafe(Dcm_UtiGetResDataAt(pMsgContext, DCM_SVC29_CHALLENGE_DATA_START_INDEX)
                      ,Dcm_SingletonContext.Diag.Services.Svc29.ChallengeSwapBuffer
                      ,0u
                      ,DCM_AUTHMGR_CHALLENGE_MAX_SIZE
                      ,Dcm_Svc29GetLengthChallengeSwapBuffer());                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_POINTER_WRITE_CHALLENGE_SWAP_BUFFER */
  }
  else
  {
    /* Otherwise, send NRC 0x14 (DCM_E_RESPONSETOOLONG) */
    *ErrorCode = DCM_E_RESPONSETOOLONG;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}
# endif

# if (DCM_SVC_29_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29GetServerCertificate()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29GetServerCertificate(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;
  KeyM_CertDataType lEcuCertificate;
  Std_ReturnType lKeyMResult;

  /* Set location to write certificate data */
  lEcuCertificate.certData = Dcm_UtiGetResDataRel(pMsgContext, DCM_SVC29_REQ_LENGTH_FIELD_BYTELEN);                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
  /* Provide KeyM_GetCertificate with all available buffer length (without 2Bytes for the lengthField) */
  lEcuCertificate.certDataLength = pMsgContext->resMaxDataLen - DCM_SVC29_REQ_LENGTH_FIELD_BYTELEN;

  lKeyMResult = KeyM_GetCertificate(Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].EcuCertificateId
                                   ,&lEcuCertificate);                                                                                               /* SBSW_DCM_POINTER_WRITE_CERTIFICATE_DATA */


  /* If result is successful continue processing */
  if(lKeyMResult == DCM_E_OK)
  {
    /* Provide size of server certificate in response */
    Dcm_UtiProvideResDataAsU16(pMsgContext, (uint16)lEcuCertificate.certDataLength);                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    /* Notify message context about server certificate data written from KeyM_GetCertificate */
    Dcm_UtiProvideResData(pMsgContext, lEcuCertificate.certDataLength);                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else if(lKeyMResult == KEYM_E_KEY_CERT_SIZE_MISMATCH)
  {
    *ErrorCode = DCM_E_RESPONSETOOLONG;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  else
  {
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
  }

  return lStdResult;
}
# endif

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29ValidateCsmCbkResult()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29ValidateCsmCbkResult(
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;

  /* Switch according to Csm callback result and set NRC */
  switch(Dcm_SingletonContext.Diag.Services.Svc29.CsmCbkResult)
  {
  case E_OK:
    lStdResult = DCM_E_OK;
    break;
  case E_SMALL_BUFFER:
    *ErrorCode = DCM_E_RESPONSETOOLONG;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  default:
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    break;
  }

  return lStdResult;
}
# endif

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON) || (DCM_SVC_29_04_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29ValidateKeyMCbkResult()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29ValidateKeyMCbkResult(
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;

  /* Switch according to Key Manager callback result and set NRC if required */
  switch(Dcm_SingletonContext.Diag.Services.Svc29.KeyMCbkResult)
  {
  case KEYM_CERTIFICATE_VALID:
    lStdResult = DCM_E_OK;
    break;
  case KEYM_E_CERTIFICATE_SIGNATURE_FAIL:
    *ErrorCode = DCM_E_CVF_INVALIDSIGNATURE;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  case KEYM_E_CERTIFICATE_INVALID_CHAIN_OF_TRUST:
    *ErrorCode = DCM_E_CVF_INVALIDCHAINOFTRUST;                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  case KEYM_E_CERTIFICATE_INVALID_TYPE:
    *ErrorCode = DCM_E_CVF_INVALIDTYPE;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  case KEYM_E_CERTIFICATE_INVALID_FORMAT:
    *ErrorCode = DCM_E_CVF_INVALIDFORMAT;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  case KEYM_E_CERTIFICATE_INVALID_CONTENT:
    *ErrorCode = DCM_E_CVF_INVALIDSCOPE;                                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  case KEYM_E_CERTIFICATE_REVOKED:
    *ErrorCode = DCM_E_CVF_INVALIDCERTIFICATEREVOKED;                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  case KEYM_E_CERTIFICATE_VALIDITY_PERIOD_FAIL:
    *ErrorCode = DCM_E_CVF_INVALIDTIMEPERIOD;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  default:
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    break;
  }

  return lStdResult;
}
# endif
#endif /* (DCM_SVC_29_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdNextEntryIdxInc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdNextEntryIdxInc(
  void
  )
{
  ++Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.CurrentEntryIndex;
  if(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.CurrentEntryIndex >= DCM_SVC_2A_SCHEDULER_SIZE)
  {
    /* Write always zero (also when only one scheduler element exists, to keep the safe aspect when the wrap-around is
     * detected */
    Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.CurrentEntryIndex = 0u;
  }
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdGetEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_Svc2ASchdEntryPtrType, DCM_CODE) Dcm_Svc2ASchdGetEntry(
  Dcm_Svc2ASchdItemHandleOptType schdHandle
  )
{
  Dcm_Svc2ASchdEntryPtrType pSchdEntry;

  if (Dcm_DebugDetectRuntimeError(schdHandle >= DCM_SVC_2A_SCHEDULER_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    pSchdEntry = &Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.Table[0];
  }
  else
  {
    pSchdEntry = &Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.Table[schdHandle];
  }
  return pSchdEntry;
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdUpdateTimers()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_Svc2ASchdUpdateTimers(
  void
  )
{
  boolean doActivateProcessorTask = FALSE;
  Dcm_Svc2ASchdItemHandleOptType lSchdIter;
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
  Dcm_Svc2ASchedRateOptType lFastestRate = DCM_SVC2A_RATE_TYPE_SLOW;
# endif

  for(lSchdIter = 0; lSchdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++lSchdIter)
  {
    Dcm_Svc2ASchdEntryPtrType pSchdEntry = Dcm_Svc2ASchdGetEntry(lSchdIter);

    if(pSchdEntry->Timer != 0u)
    {
      --(pSchdEntry->Timer);                                                                                                                         /* PRQA S 3387 */ /* MD_Dcm_OptimizedInlineCode_3387 */ /* SBSW_DCM_POINTER_WRITE_2ASCHEDULERENTRY */
      if(pSchdEntry->Timer == 0u)
      {
        if(pSchdEntry->Rate < DCM_SVC2A_RATE_TYPE_STOPPED) /* is it scheduled ? */
        {
          doActivateProcessorTask = TRUE;
        }
      }
    }
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
    if(pSchdEntry->Rate < DCM_SVC2A_RATE_TYPE_STOPPED) /* is it scheduled ? */
    {
      if (pSchdEntry->Rate > lFastestRate)
      {
        lFastestRate = pSchdEntry->Rate;
      }
    }
# endif
  }
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
  Dcm_NetPeriodicMsgSetFastestRate(lFastestRate);
# endif
  return doActivateProcessorTask;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdFindFreeOrInUseItemByDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_Svc2ASchdFindFreeOrInUseItemByDid(
  uint16 did,
  P2VAR(Dcm_Svc2ASchdItemHandleOptType, AUTOMATIC, AUTOMATIC) schdHandle
  )
{
  Dcm_Svc2ASchdItemHandleOptType lSchdIter;
  boolean lSlotFound = FALSE;

  for(lSchdIter = 0; lSchdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++lSchdIter)
  {
    Dcm_Svc2ASchdEntryConstPtrType pSchdEntry = Dcm_Svc2ASchdGetEntry(lSchdIter);

    if(pSchdEntry->Rate == DCM_SVC2A_RATE_TYPE_STOPPED)
    {
      if(lSlotFound == FALSE)
      {
        *schdHandle = lSchdIter; /* reserve first found free slot */                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
        lSlotFound = TRUE;
      }/* else - already set */
    }
    else if(did == pSchdEntry->DidContext.Did)
    {
      *schdHandle = lSchdIter; /* found already in used or just reserved DID -> use the same slot */                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
      lSlotFound = TRUE;
      break;
    }
    else
    {
      /* do nothing */
    }
  }
  return lSlotFound;
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdInitDidMgrResources()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ASchdInitDidMgrResources(
  Dcm_DiagDataContextPtrType pDataContext,
  uint16 did
  )
{
  Std_ReturnType lStdResult;

  lStdResult = Dcm_RsrcMgrGetDidLock(DCM_INITIAL, did, DCM_RSRCMGR_DIDLOCK_OWNER_SID2A);

  if(lStdResult == DCM_E_OK)
  {
    /* prepare first time reading */
    Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.OpStatus = DCM_INITIAL;
    Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.WriteIndex = 0u;
    Dcm_UtiProvideDataAsU8(pDataContext, Dcm_UtiGetLoByte(did));                                                                                     /* SBSW_DCM_POINTER_WRITE_DATA_CONTEXT */
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdProcessEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ASchdProcessEntry(
  Dcm_Svc2ASchdEntryPtrType pSchedTableEntry
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;
  boolean doSendData = FALSE;

  /* allocate buffer for response data */
  /* still nothing reserved for this DID? */
  if(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle == DCM_NET_INVALID_PTXOBJ_HANDLE)
  {
    Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle = Dcm_NetPeriodicMsgAllocate(pSchedTableEntry->DidContext.Did);
    if(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle == DCM_NET_INVALID_PTXOBJ_HANDLE)
    {
      /* no free message buffer try again later */
      lStdResult = DCM_E_PENDING; /* exit loop and task */
    }
  }

  if(lStdResult == DCM_E_OK)
  {
    Dcm_DiagDataContextType lDataContext;

    /* Init data context */
    Dcm_UtiInitDataContext(&lDataContext
                           ,Dcm_NetPeriodicMsgGetTxBuffer(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle)
                           ,(Dcm_MsgLenType)DCM_NET_PERIODIC_BUFFER_SIZE);                                                                           /* SBSW_DCM_POINTER_INIT_DATA_CONTEXT */

    /* Allocate DID manager resource */
    if(Dcm_RsrcMgrHasDidLock(DCM_RSRCMGR_DIDLOCK_OWNER_SID2A) == FALSE)
    {
      lStdResult = Dcm_Svc2ASchdInitDidMgrResources(&lDataContext, pSchedTableEntry->DidContext.Did);                                                /* SBSW_DCM_POINTER_WRITE_DATA_CONTEXT */
    }

    if(lStdResult == DCM_E_OK)
    {
      Dcm_NegativeResponseCodeType lNrc; /* unused since no NR possible */

      /* Write index is initialized in Dcm_Svc2ASchdInitDidMgrResources and thus always valid */
      Dcm_UtiCommitData(&lDataContext, Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.WriteIndex);                                               /* SBSW_DCM_POINTER_WRITE_DATA_CONTEXT */

      /* read the response data */
      lStdResult = Dcm_DidMgrReadDid(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.OpStatus
                                    ,&lDataContext
                                    ,&(pSchedTableEntry->DidContext)
                                    ,&(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.DidOpTypeContext)
                                    ,&lNrc);                                                                                                         /* SBSW_DCM_COMB_PTR_FORWARD */

      Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.WriteIndex = (Dcm_CfgNetBufferSizeMemType)lDataContext.Usage;

      switch(lStdResult)
      {
      case DCM_E_OK:
        doSendData = TRUE; /* now the response can be sent */
        break;
      case DCM_E_PENDING:
        Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.OpStatus = DCM_PENDING; /* prepare for next call */
        break;
      case DCM_E_NOT_OK:
        /* something went wrong - skip this DID */
        break;
      default:                                                                                                                                       /* COV_DCM_RTM_UNREACHABLE X */
        lStdResult = DCM_E_NOT_OK;
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);
        break;
      }

      if(lStdResult != DCM_E_PENDING)
      {
        /* reload the period timer from now on (see ISO14229-1 SID 0x2A scheduler example) */
        /*
         * No critical section for split tasks needed since:
         * - The timer that just has been processed is already stopped and will not be decrement in the
         *   Dcm_Svc2ASchdUpdateTimers utility.
         * - This tasks is a low-priority one and cannot interrupt the timer task (Dcm_OnTimeoutSvc2AScheduler). So
         *   setting a non-zero value will not be an issue.
         */
        pSchedTableEntry->Timer = Dcm_Svc2AGetSchedulingTimeOfEntry(pSchedTableEntry);                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */

        /* Finish scheduled job */
        Dcm_Svc2ASchdFinishEntryProcessing(doSendData);
      }
    }
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */
/**********************************************************************************************************************
 *  Dcm_Service2ASchedulerInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Service2ASchedulerInit(
  void
  )
{
  Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries = 0u;
  Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.CurrentEntryIndex = 0u;
  Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle = DCM_NET_INVALID_PTXOBJ_HANDLE;

  {
    Dcm_Svc2ASchdItemHandleOptType lSchdIter;

    for(lSchdIter = 0; lSchdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++lSchdIter)
    {
      Dcm_Svc2ASchdEntryPtrType pSchdEntry = Dcm_Svc2ASchdGetEntry(lSchdIter);
      pSchdEntry->Timer = 0u;                                                                                                                        /* SBSW_DCM_POINTER_WRITE_2ASCHEDULERENTRY */
      pSchdEntry->Rate = DCM_SVC2A_RATE_TYPE_STOPPED;                                                                                                /* SBSW_DCM_POINTER_WRITE_2ASCHEDULERENTRY */
    }
  }
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdAddItemByDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdAddItemByDid(
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext                                                                                                    /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_Svc2ASchdItemHandleOptType lSchdHandle = DCM_SVC_2A_SCHEDULER_SIZE;
  Dcm_Svc2ASchdEntryPtrType pSchdEntry;

  if (Dcm_Svc2ASchdFindFreeOrInUseItemByDid(pDidInfoContext->Did, &lSchdHandle) == TRUE)                                                             /* SBSW_DCM_POINTER_FORWARD_STACK */
  {
    pSchdEntry = Dcm_Svc2ASchdGetEntry((Dcm_Svc2ASchdItemHandleOptType)lSchdHandle);

    pSchdEntry->DidContext  = *pDidInfoContext;                                                                                                      /* SBSW_DCM_POINTER_WRITE_2ASCHEDULERENTRY */
    pSchdEntry->Rate |= DCM_SVC2A_RATE_TYPE_RESERVED;                                                                                                /* SBSW_DCM_POINTER_WRITE_2ASCHEDULERENTRY */
  }
  else
  {
    /* there shall always be free space when this function is called, otherwise check the SID 0x2A processor */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);
  }
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdCommit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdCommit(
  Dcm_Svc2ASchedRateMemType rate
  )
{
  Dcm_Svc2ASchdItemHandleOptType lSchdIter;

  Dcm_SplitTaskEnterCS();/* protect against timer task update */

  for(lSchdIter = 0; lSchdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++lSchdIter)
  {
    Dcm_Svc2ASchdEntryPtrType pSchdEntry = Dcm_Svc2ASchdGetEntry(lSchdIter);
    if((pSchdEntry->Rate & DCM_SVC2A_RATE_TYPE_RESERVED) != 0u)
    {
      if((pSchdEntry->Rate & DCM_SVC2A_RATE_TYPE_STOPPED) != 0u)
      {
        /* update statistic of first activation of this DID */
        ++Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries;
      }
      /* must not exceed the scheduler size */
      Dcm_DebugAssert((Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries <= DCM_SVC_2A_SCHEDULER_SIZE)
                     ,DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                        /* COV_DCM_RTM_DEV_DEBUG XF */

      pSchdEntry->Rate = rate; /* set the new rate */                                                                                                /* SBSW_DCM_POINTER_WRITE_2ASCHEDULERENTRY */
      pSchdEntry->Timer = 0u; /* enforce immediate timeout */                                                                                        /* SBSW_DCM_POINTER_WRITE_2ASCHEDULERENTRY */
    }
  }
  Dcm_SplitTaskLeaveCS();

  if(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries != 0u)
  {
# if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
    Dcm_TmrStartTimer(DCM_TMR_ID_SVC2A_SCHEDULER, 1u);/* start timer updater */
# endif
    /* start updating the timers/processing new DIDs */
    Dcm_TskSetEvent(DCM_TSK_ID_SVC2A_SCHEDULER
                       ,(Dcm_TskTaskEvMemType)(DCM_TSK_EV_SVC2A_SCHEDULER_TMR_UPD|DCM_TSK_EV_SVC2A_SCHEDULER_PROCESS));
  }
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdDiscard()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdDiscard(
  void
  )
{
  Dcm_Svc2ASchdItemHandleOptType lSchdIter;

  for(lSchdIter = 0; lSchdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++lSchdIter)
  {
    Dcm_Svc2ASchdEntryPtrType pSchdEntry = Dcm_Svc2ASchdGetEntry(lSchdIter);
    Dcm_UtiBitOpClr(Dcm_Svc2ASchedRateMemType, pSchdEntry->Rate, DCM_SVC2A_RATE_TYPE_RESERVED);                                                      /* SBSW_DCM_POINTER_WRITE_2ASCHEDULERENTRY */
  }
}
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2AStoppedDidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AStoppedDidLookUp(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ARepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdReturn;

  lStdReturn = Dcm_Svc2ADidLookUp(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lStdReturn == DCM_E_OK)
  {
    Dcm_Svc2ASchdStopItemByDid(pRepContext->DidInfoContext.Did);
    lStdReturn = DCM_E_LOOP;/* go on with the next DID  */
  }
  else if (lStdReturn == DCM_E_PROCESSINGDONE)
  {
    lStdReturn = DCM_E_OK;
  }
  else
  {
    /* DCM_E_PENDING, DCM_E_NOT_OK (ErrorCode already set), DCM_E_LOOP */
  }

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc2AScheduledDidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AScheduledDidLookUp(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ARepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdReturn;
  Dcm_DidMgrDidInfoContextPtrType pDidInfoContext = &(pRepContext->DidInfoContext);                                                                  /* PRQA S 3679 */ /* MD_Dcm_Design_3679 */

  lStdReturn = Dcm_Svc2ADidLookUp(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lStdReturn == DCM_E_OK)
  {
    lStdReturn = Dcm_DidMgrDynDidStateCheck(Dcm_NetGetConnHdlOfRxPduId(pMsgContext->rxPduId), pDidInfoContext, ErrorCode);                           /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_PARAM_PTR_FORWARD */
    if (lStdReturn == DCM_E_OK)
    {
      /* Proceed with next validation step */
      Dcm_RepeaterNextStep(pContext, DCM_SVC2A_PROGRESS_DID_CHECKCONDITION); /* next job */                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdReturn = DCM_E_LOOP;/* speed up processing */
    } /* else DCM_E_NOT_OK (ErrorCode already set) */
  }
  else if (lStdReturn == DCM_E_PROCESSINGDONE)
  {
    lStdReturn = DCM_E_OK;
  }
  else
  {
    /* DCM_E_PENDING, DCM_E_NOT_OK (ErrorCode already set), DCM_E_LOOP */
  }

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc2ADidCheckCondition()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADidCheckCondition(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ARepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult = DCM_E_LOOP;

  if(Dcm_DidMgrIsOpTypeSupported(Dcm_CfgDidMgrGetDidOpInfo(&(pRepContext->DidInfoContext))
                                ,DCM_DIDMGR_OPTYPE_READCHKCOND))
  {
    DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                             /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

    /* check condition on this DID */
    Dcm_DidMgrInitOpClassInfo(&(pRepContext->DidInfoContext), DCM_DIDMGR_OPTYPE_READCHKCOND);                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = Dcm_DidMgrReadCheckCond(opStatus
                                        ,&(pRepContext->DidInfoContext)
                                        ,&(pRepContext->DidOpTypeContext)
                                        ,ErrorCode);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */

    switch(lStdResult)
    {
    case DCM_E_OK:
      lStdResult = DCM_E_LOOP;
      break; /* go on with next DID */
    case DCM_E_PENDING:
      break;
    default: /* DCM_E_NOT_OK */
      break; /* finish service processing immediately */
    }
  }/* else - not supported operation - go on with getLength */

  if(lStdResult == DCM_E_LOOP)
  {
    Dcm_RepeaterNextStep(pContext, DCM_SVC2A_PROGRESS_DID_GETLENGTH);                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  return lStdResult; /* speed up processing */
}

/**********************************************************************************************************************
 *  Dcm_Svc2ADidGetLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADidGetLength(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ARepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdReturn = DCM_E_OK;

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if(Dcm_DidMgrIsOpTypeSupported(Dcm_CfgDidMgrGetDidOpInfo(&(pRepContext->DidInfoContext))
                                ,DCM_DIDMGR_OPTYPE_READLENGTH))
  {
    Dcm_DidMgrInitOpClassInfo(&(pRepContext->DidInfoContext), DCM_DIDMGR_OPTYPE_READLENGTH);                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Calculate DID data length if applicable */
    lStdReturn = Dcm_DidMgrReadLength(opStatus
                                     ,&(pRepContext->DidInfoContext)
                                     ,&(pRepContext->DidOpTypeContext)
                                     ,ErrorCode);                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  if(lStdReturn == DCM_E_OK)
  {
    /* check for buffer overrun - uudt frame needs to be large enough for the periodic message (1 Byte DID + data) */
    if (pRepContext->DidInfoContext.DidLength >= Dcm_PbCfgNetConnectionInfo[pRepContext->ConnHdl].UudtFrameSize)
    {
      /* the configured buffer will not be able to hold all of the data -> notify the client */
      *ErrorCode = DCM_E_RESPONSETOOLONG;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK; /* finish service processing immediately */
    }
    else
    {
      /* Add scheduler job - set the operation now since not changed later */
      Dcm_DidMgrInitOpClassInfo(&(pRepContext->DidInfoContext), DCM_DIDMGR_OPTYPE_READ);                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */

      Dcm_Svc2ASchdAddItemByDid(&pRepContext->DidInfoContext);                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */

      Dcm_RepeaterNextStep(pContext, DCM_SVC2A_PROGRESS_SCHEDULEDDID_LOOKUP);                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdReturn = DCM_E_LOOP;/* speed up processing */
    }
  }/* else - DCM_E_PENDING, DCM_E_NOT_OK */

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc2AIsUdsRateSupported()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_Svc2AIsUdsRateSupported(
  Dcm_Svc2ATransmissionModeType udsRate
  )
{
  sint16_least lLookUpResult;
  boolean      lResult = TRUE;

  lLookUpResult = Dcm_UtiLookUpUint8(Dcm_CfgSvc2ASupportedRatesLookUpTable, udsRate);                                                                /* SBSW_DCM_POINTER_FORWARD_GLOBAL */

  if (lLookUpResult < 0)
  {
    lResult = FALSE;
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc2AStopScheduledDids()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AStopScheduledDids(
  Dcm_ContextPtrType pContext,
  Dcm_MsgContextPtrType pMsgContext                                                                                                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdReturn = DCM_E_OK;
  if(pMsgContext->reqDataLen == 0u)
  {
    Dcm_Svc2ASchdStopAll();
  }
  else
  {
    Dcm_RepeaterNextStep(pContext, DCM_SVC2A_PROGRESS_STOPPED_DID_LOOKUP); /* delegate job */                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdReturn = DCM_E_LOOP;/* speed up processing */
  }

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc2ADoScheduleDids()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADoScheduleDids(
  Dcm_ContextPtrType pContext,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode                                                                                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdReturn = DCM_E_NOT_OK;

  if(pMsgContext->reqDataLen > Dcm_Svc2ASchdGetFreeSpace())
  {
  /*
   * not enough space in the scheduler table
   * (don't consider duplicates and unsupported DIDs in the request -> apply KISS) */
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
  {
    Dcm_RepeaterNextStep(pContext, DCM_SVC2A_PROGRESS_SCHEDULEDDID_LOOKUP); /* delegate job */                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdReturn = DCM_E_LOOP;/* speed up processing */
  }

  /* Reaching this point means diagnostic error was found */
  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc2AHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ARepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType                     lStdReturn;
  Dcm_NetTransportObjectConstPtrType pTranspObj = Dcm_DiagGetTranspObj(pContext);

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  pRepContext->ConnHdl = pTranspObj->ConnHdl;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */

# if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
  /* protected by the session connection ownership */
# else
  /* In case of generic connections, a connection can be used by a pool of testers. Tester address has to be checked as well. */
  if ( (Dcm_NetPeriodicMsgGetConnection() != DCM_NET_INVALID_CONNHDL)
     &&( (Dcm_NetPeriodicMsgGetConnection() != pRepContext->ConnHdl)
#  if (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
       ||( (Dcm_NetIsGenericConnection(Dcm_NetPeriodicMsgGetConnection()))
         &&(pTranspObj->ClientSrcAddr != Dcm_NetPeriodicMsgGetClientSrcAddr()) )
#  endif
       ) )
  {
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT; /* the 2A service is currently in use by another client */                                              /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
# endif
  if (!Dcm_NetPeriodicMsgSupportedFor(Dcm_DiagGetTranspObj(pContext)->ConnHdl))
  {
    *ErrorCode = DCM_E_PANIC_NRC; /* current client does not support periodic messages */                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
  {
    pRepContext->HasAnySupportedDids = FALSE;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_UtiConsumeReqDataAsU8(pMsgContext, &(pRepContext->UdsRate));                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Maximum number of DIDs per single request service shall not be exceeded.
      * Check minimum length for rates excluding stopSending */
    if( (pMsgContext->reqDataLen > DCM_SVC_2A_MAX_DID_LIST_LEN)
      ||((pMsgContext->reqDataLen == 0u) && (pRepContext->UdsRate != DCM_SVC_2A_STOP_SENDING)) )
    {
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK;
    }
    else
    {
      if(!Dcm_Svc2AIsUdsRateSupported(pRepContext->UdsRate))
      {
        *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdReturn = DCM_E_NOT_OK;
      }
      else
      {
        if (pRepContext->UdsRate == DCM_SVC_2A_STOP_SENDING)
        {
          lStdReturn = Dcm_Svc2AStopScheduledDids(pContext, pMsgContext);                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
        }
        else
        {
          lStdReturn = Dcm_Svc2ADoScheduleDids(pContext, pMsgContext, ErrorCode);                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
        }
      }
    }
  }

  return lStdReturn;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2CDefMgrInit(
  void
  )
{
  Dcm_CfgDidMgrDynDidHandleOptType dynDidIter;

  /* If DynDIDs were restored from non-volatile memory: */
# if (DCM_SVC_2C_NVRAM_SUPPORT_ENABLED == STD_ON)
  if((Dcm_Svc2CNvMData.MagicNumber == DCM_CFG_FINAL_MAGIC_NUMBER)
#  if (DCM_VARMGR_MULTI_SVC_EXCLUSIVE_ENABLED == STD_ON)
   &&(Dcm_Svc2CNvMData.CfgVariantId == Dcm_VarMgrGetActiveCfgVariantId())                                                                            /* PRQA S 3415 */ /* MD_Dcm_Rule13.5 */
#  endif
    )
  {
    /* Check if preconditions are still fulfilled */
#  if (DCM_DIDMGR_DYNDID_CLR_ON_STATE_CHG_ENABLED == STD_ON) && \
      (DCM_DIAG_STATE_RECOVERY_ENABLED            == STD_OFF)
    /*
     * In case that state recovery feature is enabled, the DynDID preconditions shall be checked after
     * state recovery.
     * In case of jump from FBL (warm start) just clear all DynDIDs which are not supported
     * in default session (KISS principle).
     * After TX confirmation of the unsolicited response, Dcm_Svc2COnStateChanged() will be
     * called again by Dcm_StateSetSession().
     * Please note, that it was always not allowed to use state recovery and warm start at the same time.
     */
    Dcm_Svc2COnStateChanged();
#  endif
  }
  else
# endif
  {
    for(dynDidIter = 0; dynDidIter < DCM_NUM_DYNDIDS; ++dynDidIter)
    {
      Dcm_Svc2CDynDidItemPtrType pItem;

      pItem = Dcm_Svc2CGetItem(dynDidIter);
      pItem->Length = 0u;                                                                                                                            /* SBSW_DCM_POINTER_WRITE_2CITEM */
      pItem->Count  = 0u;                                                                                                                            /* SBSW_DCM_POINTER_WRITE_2CITEM */
    }

# if (DCM_SVC_2C_NVRAM_SUPPORT_ENABLED == STD_ON)
    Dcm_Svc2CNvMData.MagicNumber = DCM_CFG_FINAL_MAGIC_NUMBER;
#  if (DCM_VARMGR_MULTI_SVC_EXCLUSIVE_ENABLED == STD_ON)
    Dcm_Svc2CNvMData.CfgVariantId = Dcm_VarMgrGetActiveCfgVariantId();
#  endif
# endif
  }

  Dcm_SingletonContext.Diag.Services.Svc2C.DynDidAccessContext.DynDidHandleInUse = DCM_SVC2C_INVALID_DYNDID_HDL;
}

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C01DefMgrRead()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C01DefMgrRead(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_Svc2CDynDidProcessContextPtrType pProcessContext
  )
{
  Dcm_OpStatusType lOpStatus = opStatus;
  Std_ReturnType lStdResult = DCM_E_OK;

  Dcm_Svc2CDynDidSrcItemConstPtrType pDidInfo = Dcm_Svc2CGetSrcItem(pProcessContext->ItemInProgress);

  if(lOpStatus == DCM_INITIAL)
  {
    Dcm_Svc2CInitDidInfoFromDidInfoIdx(pDidInfo->DidDescriptor.DidInfoIdx, &(pProcessContext->SrcDidContext));                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  if(Dcm_RsrcMgrHasDidLock(DCM_RSRCMGR_DIDLOCK_OWNER_SID2C) == FALSE)
  {
    /* Check for access rights (avoids race conditions) */
    lStdResult = Dcm_RsrcMgrGetDidLock(lOpStatus, pProcessContext->SrcDidContext.Did, DCM_RSRCMGR_DIDLOCK_OWNER_SID2C);

    if(lStdResult == DCM_E_OK)
    {
      lOpStatus = DCM_INITIAL;
      Dcm_SingletonContext.Diag.Services.Svc2C.ReadIndex = 0;
    }
  }

  if(lStdResult == DCM_E_OK)
  {
    Dcm_NegativeResponseCodeType lNrc;
    Dcm_DiagDataContextType lDataContext;

    Dcm_DidMgrInitOpClassInfo(&(pProcessContext->SrcDidContext)
                             ,DCM_DIDMGR_OPTYPE_READ);                                                                                               /* SBSW_DCM_POINTER_WRITE_2CPROCESSCONTEXT */

    /* Init data context for asynchronous DIDs only initialy (not in pending status) */
    Dcm_UtiInitDataContext(&lDataContext                                                                                                             /* SBSW_DCM_POINTER_WRITE_DATA_CONTEXT */
                           ,Dcm_SingletonContext.Diag.Services.Svc2C.DynDidAccessContext.Buffer
                           ,DCM_SVC_2C_READ_BUFFER_SIZE);

    Dcm_UtiCommitData(&lDataContext, Dcm_SingletonContext.Diag.Services.Svc2C.ReadIndex);                                                            /* SBSW_DCM_POINTER_WRITE_DATA_CONTEXT */

    lStdResult = Dcm_DidMgrReadDid(lOpStatus
                                  ,&lDataContext                                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
                                  ,&(pProcessContext->SrcDidContext)                                                                                 /* SBSW_DCM_POINTER_WRITE_2CPROCESSCONTEXT */
                                  ,&(pProcessContext->DidOpTypeContext)                                                                              /* SBSW_DCM_POINTER_WRITE_2CPROCESSCONTEXT */
                                  ,&lNrc);                                                                                                           /* SBSW_DCM_POINTER_FORWARD_STACK */

    Dcm_SingletonContext.Diag.Services.Svc2C.ReadIndex = lDataContext.Usage;

    /* Finished processing a DIDSrcItem */
    if(lStdResult != DCM_E_PENDING)
    {
      if(lStdResult == DCM_E_OK)
      {
        Dcm_UtiProvideDataAsUN(pDataContext, &lDataContext.Buffer[pDidInfo->DidDescriptor.Offset], pDidInfo->DidDescriptor.Size);                    /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
      Dcm_RsrcMgrReleaseDidLock(DCM_RSRCMGR_DIDLOCK_OWNER_SID2C);
    }
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */
# endif

# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C02DefMgrRead()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C02DefMgrRead(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext
  )
{
  Std_ReturnType lStdResult;
  Dcm_OpStatusType lOpStatus = opStatus;

  lStdResult = DCM_E_OK;

  if(Dcm_RsrcMgrHasMemLock(DCM_RSRCMGR_MEM_ACCESS_REQ_INT) == TRUE)
  {
    /* Proceed with reading */
  }
  else
  {
    /* Still in process getting access! */
    lStdResult = Dcm_RsrcMgrGetMemLock(lOpStatus, DCM_RSRCMGR_MEM_ACCESS_REQ_INT);

    if (lStdResult == DCM_E_OK)
    {
      lOpStatus = DCM_INITIAL; /* prepare for first reading */
    }
  }

  if(lStdResult == DCM_E_OK)
  {
    Dcm_NegativeResponseCodeType lNrc;
    Dcm_CfgDidMgrDynDidSrcItemIdxMemType lItemInProgress;

    lItemInProgress = Dcm_Svc2CGetDDDidProcessContext(DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED)->ItemInProgress;
    lStdResult = Dcm_MemMgrReadMemory(lOpStatus
                                    ,&(Dcm_Svc2CGetSrcItem(lItemInProgress)->MemDescriptor.MemBlock)
                                    ,pDataContext
                                    ,&lNrc);                                                                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
  }

  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrReadSrcItems()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrReadSrcItems(
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_Svc2CDynDidProcessContextPtrType pProcessContext
  )
{
  Std_ReturnType lStdReturn = DCM_E_OK;
  Dcm_OpStatusType lOpStatus = opStatus;

  for(; pProcessContext->ItemInProgress < pProcessContext->ItemToStop; pProcessContext->ItemInProgress++)                                            /* SBSW_DCM_PARAM_PTR_WRITE */
  {
    if(Dcm_Svc2CIsDidSrcItem(pProcessContext->ItemInProgress))
    {
# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
      lStdReturn = Dcm_Svc2C01DefMgrRead(lOpStatus, pDataContext, pProcessContext);                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
# endif
    }
    else
    {
# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
      lStdReturn = Dcm_Svc2C02DefMgrRead(lOpStatus, pDataContext);                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
# endif
    }

    if(lStdReturn == DCM_E_OK)
    {
      /* prepare for next item */
      lOpStatus = DCM_INITIAL;
    }
    else
    {
      break;
    }
  }

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrReadCheckAccessAndInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrReadCheckAccessAndInit(
  Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle,
  P2VAR(Dcm_OpStatusType, AUTOMATIC, AUTOMATIC) pOpStatus                                                                                            /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;

  DCM_IGNORE_UNREF_PARAM(dynDidHandle);                                                                                                              /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /*-----------------------------------------------*
   * DynDID usage check and initialization
   *-----------------------------------------------*/
  if(Dcm_SingletonContext.Diag.Services.Svc2C.DynDidAccessContext.DynDidHandleInUse == DCM_SVC2C_INVALID_DYNDID_HDL)
  {
    if(*pOpStatus == DCM_CANCEL)
    {
      lStdResult = DCM_E_NOT_OK; /* we have waited for too long to get access to the DynDID reader, but it was canceled -> Stop here since no reading has been started yet */
    }
    else
    {
      /*
       * Reset opStatus in case some DCM_E_PENDING had to be returned due to concurrent access (i.e. 0x22 and 0x2A for
       * different DDDIDs)
       */
      *pOpStatus = DCM_INITIAL;                                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }
# if (DCM_SVC_2C_RACE_CONDITION_READ_ENABLED == STD_ON)
  else
  {
    if(dynDidHandle != Dcm_SingletonContext.Diag.Services.Svc2C.DynDidAccessContext.DynDidHandleInUse)
    {
      lStdResult = DCM_E_PENDING;
    } /* else - same handle -> process it */
  }
# endif
  return lStdResult;
}
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc2CSubFuncInfoGetEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgSvc2CSubFuncInfoGetEntry(
  Dcm_DiagSubServiceRefOptType SubSvcRef,
  CONSTP2VAR(Dcm_CfgSvc2CSubFuncInfoPtrType, AUTOMATIC, AUTOMATIC) pSubFuncInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lResult;

  if (Dcm_DebugDetectRuntimeError(SubSvcRef >= DCM_CFGSVC2CSUBFUNCINFO_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);

    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_NOT_OK;
  }
  else
  {
    *pSubFuncInfo = &Dcm_CfgSvc2CSubFuncInfo[SubSvcRef];                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_OK;
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc2CHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;
  Dcm_DiagSubServiceRefOptType lSubSvcRef;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                                   ,Dcm_CfgSvc2CSubFuncLookUpTable
                                                   ,Dcm_CfgSvc2CSubFuncExecPrecondTable
                                                   ,Dcm_Svc2CReqLengthGetter
                                                   ,Dcm_DiagNoSequenceChecker
                                                   ,&lSubSvcRef
                                                   ,ErrorCode);                                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)
  {
    pRepContext->SubSvcRef = (Dcm_DiagSubServiceRefMemType)lSubSvcRef;                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */

    /* Perform SID specific checks */
    if (Dcm_CfgSvc2CSubFuncInfo[(pRepContext->SubSvcRef)].MinReqLength <= pMsgContext->reqDataLen) /* min length = (DDID, (MEMdef|DIDdef))? */
    {
      Dcm_RepeaterNextStep(pContext, DCM_SVC2C_PROGRESS_SUBFUNCTION); /* delegate job */                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_LOOP; /* speed up processing */
    }
    else
    {
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  } /* else DCM_E_NOT_OK (ErrorCode is already set) */

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc2CSubFuncHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CSubFuncHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType                 lStdResult;
  Dcm_CfgSvc2CSubFuncInfoPtrType pSubFuncInfo;

  lStdResult = Dcm_CfgSvc2CSubFuncInfoGetEntry(pRepContext->SubSvcRef, &pSubFuncInfo, ErrorCode);                                                    /* SBSW_DCM_COMB_PTR_FORWARD */

  if (lStdResult == DCM_E_OK)                                                                                                                        /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    lStdResult = pSubFuncInfo->SubSvcFunc(pContext, opStatus, pMsgContext, ErrorCode);                                                               /* SBSW_DCM_CALL_FUNCPTR_SVC2CSUBFUNC */
  }

  return lStdResult;
}

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C01SrcDidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C01SrcDidLookUp(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdReturn;

  if(opStatus == DCM_INITIAL)
  {
     /* Extract source DID */
    Dcm_UtiConsumeReqDataAsU16(pMsgContext, &(pRepContext->SrcItemDidInfoContext.Did));                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  lStdReturn = Dcm_DidMgrGetDidInfo(opStatus
                                   ,&(pRepContext->SrcItemDidInfoContext)
                                   ,&(pRepContext->DynDidOpTypeContext) /* Use OpTypeContext of DynDID since no more needed at this time! */
                                   ,DCM_DIDMGR_OP_READ);                                                                                             /* SBSW_DCM_COMB_PTR_FORWARD */

  switch(lStdReturn)
  {
  case DCM_E_OK:
    if(Dcm_DidMgrIsOpSupported(Dcm_CfgDidMgrGetDidInfo(&(pRepContext->SrcItemDidInfoContext)), DCM_DIDMGR_OP_DEFINE))                                /* SBSW_DCM_PARAM_PTR_WRITE */
    {
      /* else - no DynDID may be referenced! */
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK;
    }
    else
    {
      lStdReturn = Dcm_StateCheckDID(Dcm_NetGetConnHdlOfRxPduId(pMsgContext->rxPduId)                                                                /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
                                    ,pRepContext->SrcItemDidInfoContext.Did
                                    ,DCM_DIDMGR_OP_READ
                                    ,Dcm_CfgDidMgrGetDidOpInfo(&(pRepContext->SrcItemDidInfoContext))->ExecCondRef
                                    ,ErrorCode);                                                                                                     /* SBSW_DCM_COMB_PTR_FORWARD */
      if(lStdReturn == DCM_E_OK)
      {
        Dcm_RepeaterNextStep(pContext, DCM_SVC2C_PROGRESS_01SRC_DIDCHECKCONDITIONS); /* next job */                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
        lStdReturn = DCM_E_LOOP;
      } /* else DCM_E_NOT_OK (ErrorCode already set) */
    }
    break;
  case DCM_E_PENDING:
    /* lStdReturn is already set */
    break;
  default: /* DCM_E_NOT_OK */
    /* source DID is not supported */
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
    break;
  }

  return lStdReturn;
}
# endif

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C01SrcDidCheckCondition()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C01SrcDidCheckCondition(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;

  if(Dcm_DidMgrIsOpTypeSupported(Dcm_CfgDidMgrGetDidOpInfo(&(pRepContext->SrcItemDidInfoContext)), DCM_DIDMGR_OPTYPE_READCHKCOND))                   /* SBSW_DCM_PARAM_PTR_WRITE */
  {
    DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                             /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

    /* check condition on this DID */
    Dcm_DidMgrInitOpClassInfo(&(pRepContext->SrcItemDidInfoContext), DCM_DIDMGR_OPTYPE_READCHKCOND);                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = Dcm_DidMgrReadCheckCond(opStatus
                                        ,&(pRepContext->SrcItemDidInfoContext)
                                        ,&(pRepContext->DynDidOpTypeContext) /* Use OpTypeContext of DynDID since no more needed at this time! */
                                        ,ErrorCode);                                                                                                 /* SBSW_DCM_COMB_PTR_FORWARD */

  } /* else - not supported operation - go on with getLength */

  if(lStdResult == DCM_E_OK)
  {
    Dcm_RepeaterNextStep(pContext, DCM_SVC2C_PROGRESS_01SRC_DIDGETLENGTH); /* next job */                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP; /* speed up processing */
  }
  return lStdResult;
}
# endif

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C01SrcDidGetLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C01SrcDidGetLength(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  )
{
  Dcm_Svc2CDynDidSrcItemPtrType pSrcItem;
  Std_ReturnType lStdReturn = DCM_E_OK;

  pSrcItem = Dcm_Svc2CGetSrcItem(pRepContext->SrcItemIndex);

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if(Dcm_DidMgrIsOpTypeSupported(Dcm_CfgDidMgrGetDidOpInfo(&(pRepContext->SrcItemDidInfoContext)), DCM_DIDMGR_OPTYPE_READLENGTH))                    /* SBSW_DCM_PARAM_PTR_WRITE */
  {
    Dcm_DidMgrInitOpClassInfo(&(pRepContext->SrcItemDidInfoContext), DCM_DIDMGR_OPTYPE_READLENGTH);                                                  /* SBSW_DCM_PARAM_PTR_WRITE */

    /* Calculate DID data length if applicable */
    lStdReturn = Dcm_DidMgrReadLength(opStatus
                                     ,&(pRepContext->SrcItemDidInfoContext)
                                     ,&(pRepContext->DynDidOpTypeContext) /* Use OpTypeContext of DynDID since no more needed at this time! */
                                     ,ErrorCode);                                                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
  }

  if(lStdReturn == DCM_E_OK)
  {
    uint8 srcDidPos;
    uint8 srcDidSize;

    Dcm_UtiConsumeReqDataAsU8(pMsgContext, &srcDidPos);                                                                                              /* SBSW_DCM_COMB_PTR_FORWARD */
    Dcm_UtiConsumeReqDataAsU8(pMsgContext, &srcDidSize);                                                                                             /* SBSW_DCM_COMB_PTR_FORWARD */

    if ((srcDidPos == 0u)
      ||(srcDidSize == 0u)
      ||(((Dcm_DidMgrDidLengthType)srcDidPos + (Dcm_DidMgrDidLengthType)srcDidSize - 1u) > pRepContext->SrcItemDidInfoContext.DidLength) )
    {
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE; /* source DID referenced data out of boundary or memory size of 0 */                                     /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK; /* finish service processing immediately */
    } /* check for possible read buffer or response overflow */
    else if ((!Dcm_UtiIsAdditionSafe(Dcm_DidMgrDidLengthType, pRepContext->DynDidLength, srcDidSize))                                                /* PRQA S 2995 */ /* MD_Dcm_ConstExpr */
      || (Dcm_UtiPromotedSum(Dcm_DidMgrDidLengthType, pRepContext->DynDidLength, srcDidSize) > pRepContext->MaxAllowedLength))
    {
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE; /* too much data referenced */                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK; /* finish service processing immediately */
    }
    else /* Add this DID to the definition */
    {
      /* update total length of the DynDID for commitment */
      pRepContext->DynDidLength += srcDidSize;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */

      /* store referenced data */
      pSrcItem->DidDescriptor.DidInfoIdx = pRepContext->SrcItemDidInfoContext.Descriptor.DidInfoIdx;                                                 /* SBSW_DCM_POINTER_WRITE_2CSRCITEM */
      pSrcItem->DidDescriptor.Offset = (uint8)(srcDidPos - 1u);                                                                                      /* SBSW_DCM_POINTER_WRITE_2CSRCITEM */
      pSrcItem->DidDescriptor.Size = srcDidSize;                                                                                                     /* SBSW_DCM_POINTER_WRITE_2CSRCITEM */
      Dcm_Svc2CSetDidSrcItem(pRepContext->SrcItemIndex); /* set the type of the source item to DID */                                                /* SBSW_DCM_POINTER_WRITE_BITSET */

      ++(pRepContext->SrcItemIndex); /* next item to be configured */                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
      ++(pRepContext->DynDidItemCount); /* update number of items for commitment */                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */

      --(pRepContext->ReqNumOfItems); /* commit processed item */                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
      if (pRepContext->ReqNumOfItems > 0u) /* any item left? */
      {
        Dcm_RepeaterNextStep(pContext, DCM_SVC2C_PROGRESS_01SRC_DIDLOOKUP); /* next job */                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
        lStdReturn = DCM_E_LOOP; /* speed up processing */
      }
      else
      {
        lStdReturn = DCM_E_OK; /* all source items finished service processing immediately */
      }
    }
  }
  return lStdReturn;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C02SrcItemsGetLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C02SrcItemsGetLength(
  uint8 alfid,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdReturn = DCM_E_NOT_OK;
  Dcm_MemMgrMemBlockType lMemBlock;

  while(pRepContext->ReqNumOfItems > 0u)
  {
    Dcm_MemMgrParseMemStream(alfid, pMsgContext, &lMemBlock);                                                                                        /* SBSW_DCM_COMB_PTR_FORWARD */
    lStdReturn = Dcm_MemMgrCheckMemBlock(&lMemBlock, DCM_MEMMGR_OP_READ, ErrorCode);                                                                 /* SBSW_DCM_COMB_PTR_FORWARD */

    if (lStdReturn == DCM_E_NOT_OK)
    {
      /* stop immediately and report the error */
      pRepContext->ReqNumOfItems = 0u; /* break */                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
    } /* else - check for definition length overflow */
    else if( (!Dcm_UtiIsAdditionSafe(uint32, pRepContext->DynDidLength, lMemBlock.Length))                                                           /* PRQA S 2995 */ /* MD_Dcm_ConstExpr */
           ||(Dcm_UtiPromotedSum(uint32, pRepContext->DynDidLength, lMemBlock.Length) > pRepContext->MaxAllowedLength) )
    {
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE; /* too much data referenced */                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK;
      /* finish service processing immediately */
      pRepContext->ReqNumOfItems = 0u; /* break */                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
    {
      /* else - add this address to the DynDID definition */
      Dcm_Svc2CDynDidSrcItemPtrType pSrcItem = Dcm_Svc2CGetSrcItem(pRepContext->SrcItemIndex);

      /* update total length of the DynDID for commitment */
      pRepContext->DynDidLength += (Dcm_DidMgrDidLengthType)(lMemBlock.Length);                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */


      pSrcItem->MemDescriptor.MemBlock = lMemBlock;                                                                                                  /* SBSW_DCM_POINTER_WRITE_2CSRCITEM */

      Dcm_Svc2CSetMemSrcItem(pRepContext->SrcItemIndex); /* set the type of the source item to MEMORY */                                             /* SBSW_DCM_POINTER_WRITE_BITSET */
      ++(pRepContext->DynDidItemCount); /* update number of items for commitment */                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      ++(pRepContext->SrcItemIndex);    /* next item to be configured */                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
      --(pRepContext->ReqNumOfItems);   /* commit processed item */                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }

  return lStdReturn;
}
# endif

# if (DCM_SVC_2C_03_SUPPORT_ENABLED == STD_ON)                                                                                                       /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_Svc2C03DidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C03DidLookUp(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdReturn;

  if(opStatus == DCM_INITIAL)
  {
    Dcm_UtiConsumeReqDataAsU16(pMsgContext, &(pRepContext->DynDidInfoContext.Did));                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_UtiProvideResDataAsU16(pMsgContext, pRepContext->DynDidInfoContext.Did); /* positive response contains the DynDID (2Byte) */                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  lStdReturn = Dcm_DidMgrGetDidInfo(opStatus
                                   ,&pRepContext->DynDidInfoContext
                                   ,&pRepContext->DynDidOpTypeContext
                                   ,DCM_DIDMGR_OP_DEFINE);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

  switch(lStdReturn)
  {
  case DCM_E_OK:
    /* clear concrete DynDID */
    Dcm_Svc2CDefMgrClear((Dcm_CfgDidMgrDynDidHandleMemType)(Dcm_CfgDidMgrGetDidInfo(&(pRepContext->DynDidInfoContext))->OpRef));
    break;
  case DCM_E_PENDING:
    /* lStdReturn is already set */
    break;
  default: /* DCM_E_NOT_OK */
    /* source DID is not supported */
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    break;
  }

  return lStdReturn;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2CSetMaxAllowedDynDIDLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2CSetMaxAllowedDynDIDLength(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  )
{
  /* initialize common DynDID request context */
# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
  if (Dcm_Svc2AIsPeriodicDid(pRepContext->DynDidInfoContext.Did))
  {
    Dcm_NetConnRefMemType lConnHdl = Dcm_Svc2AGetConnectionOfDID(pRepContext->DynDidInfoContext.Did);
    if (lConnHdl < DCM_NET_INVALID_CONNHDL)
    {
      pRepContext->MaxAllowedLength = (Dcm_DidMgrDidLengthType)Dcm_PbCfgNetConnectionInfo[lConnHdl].UudtFrameSize;                                   /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
    {
      pRepContext->MaxAllowedLength = DCM_SVC2A_MAX_RESPONSE_LEN;                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }
  else
# endif
  {
    /*
     * Perform length check based on the current protocol only. Sid 0x22 will do additional checks at read time in
     * case a client from another protocol is trying to access the DynDID!
     */
    Dcm_CfgNetBufferSizeMemType lBufferSize = Dcm_Svc2CGetNetBufferSize(pContext);
    if (lBufferSize > Dcm_UtiMaxValueOfUintType(Dcm_DidMgrDidLengthType))
    {
      pRepContext->MaxAllowedLength = Dcm_UtiMaxValueOfUintType(Dcm_DidMgrDidLengthType) - 3u;         /* for response: 0x62 DID_H DID_L <DATA> */   /* SBSW_DCM_PARAM_PTR_WRITE */ /* PRQA S 2880 */ /* MD_MSR_Unreachable */
    }
    else
    {
      pRepContext->MaxAllowedLength = (Dcm_DidMgrDidLengthType)lBufferSize - 3u;                       /* for response: 0x62 DID_H DID_L <DATA> */   /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }
}

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CInitDidInfoFromDidInfoIdx()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2CInitDidInfoFromDidInfoIdx(
  Dcm_CfgDidMgrDidInfoRefType didInfoIdx,
  Dcm_DidMgrDidInfoContextPtrType pSrcDidContext
  )
{
  pSrcDidContext->Did = Dcm_CfgWrapDidMgrDidLookUpTable(didInfoIdx + 1u);                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
  (void)Dcm_DidMgrConcreteDidLookUp(pSrcDidContext, DCM_DIDMGR_OP_READ);                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
}
# endif
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2EHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2EHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ERepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;
  Dcm_CfgStateRefOptType lStateRef;

  if (opStatus == DCM_INITIAL)
  {
    /* Min Length already checked in DiagDispatcher and expected to be 3 !!! */
    Dcm_UtiConsumeReqDataAsU16(pMsgContext, &(pRepContext->DidInfoContext.Did));                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  lStdResult = Dcm_DidMgrGetDidInfo(opStatus
                                   ,&(pRepContext->DidInfoContext)
                                   ,&(pRepContext->DidOpTypeContext)
                                   ,DCM_DIDMGR_OP_WRITE);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */

  if (lStdResult == DCM_E_OK)
  {
    Dcm_UtiProvideResData(pMsgContext, 2u);/* return the DID (shared Rx-Tx buffer) */                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Check DID specific length */
    if ( (pMsgContext->reqDataLen >= Dcm_CfgDidMgrGetDidInfo(&(pRepContext->DidInfoContext))->MinLength)
       && (pMsgContext->reqDataLen <= Dcm_CfgDidMgrGetDidInfo(&(pRepContext->DidInfoContext))->MaxLength) )
    {
      lStateRef = Dcm_CfgDidMgrGetDidOpInfo(&(pRepContext->DidInfoContext))->ExecCondRef;

      lStdResult = Dcm_DidMgrStaticDidStateCheck(Dcm_NetGetConnHdlOfRxPduId(pMsgContext->rxPduId)                                                    /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_COMB_PTR_FORWARD */
                                                ,pRepContext->DidInfoContext.Did
                                                ,DCM_DIDMGR_OP_WRITE
                                                ,lStateRef
                                                ,ErrorCode);
      if (lStdResult == DCM_E_OK)
      {
        Dcm_DidMgrInitOpClassInfo(&(pRepContext->DidInfoContext), DCM_DIDMGR_OPTYPE_WRITE);                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */

        Dcm_RepeaterNextStep(pContext, DCM_SVC2E_PROGRESS_CHECKACCESS); /* delegate job */                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

        lStdResult = DCM_E_LOOP;/* speed up processing */
      } /* else DCM_E_NOT_OK - ErrorCode already assigned */
    }
    else
    {
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  }
  else if (lStdResult == DCM_E_PENDING)
  {
    /* DCM_E_PENDING -> try again */
  }
  else
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc2ECheckAccess()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ECheckAccess(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc2ERepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_RsrcMgrGetDidLock(opStatus, pRepContext->DidInfoContext.Did, DCM_RSRCMGR_DIDLOCK_OWNER_SID2E);

  if(lStdResult == DCM_E_OK)
  {
    Dcm_RepeaterNextStep(pContext, DCM_SVC2E_PROGRESS_WRITEDATA); /* delegate job */                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP;/* speed up processing */
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc2EWriteData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2EWriteData(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ERepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;

  lStdResult = Dcm_DidMgrWrite(opStatus
                              ,pMsgContext
                              ,&(pRepContext->DidInfoContext)
                              ,&(pRepContext->DidOpTypeContext)
                              ,ErrorCode);                                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

  switch (lStdResult)
  {
  case DCM_E_PENDING:
    /* Try it the next task cycle */
    break;
  case DCM_E_OK:
    Dcm_DebugReportSecurityEvent(pMsgContext->threadId, DCM_DEBUG_SEV_WRITE_DATA);
    Dcm_RsrcMgrReleaseDidLock(DCM_RSRCMGR_DIDLOCK_OWNER_SID2E);
    break;
  default: /* DCM_E_NOT_OK */
    if (*ErrorCode == DCM_E_REQUESTOUTOFRANGE)
    {
      Dcm_DebugReportSecurityEvent(pMsgContext->threadId, DCM_DEBUG_SEV_WRITE_INV_DATA);
    }

    Dcm_RsrcMgrReleaseDidLock(DCM_RSRCMGR_DIDLOCK_OWNER_SID2E);
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FReturnControlToEcu()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FReturnControlToEcu(
  void
  )
{
  if(Dcm_SingletonContext.Diag.Services.Svc2F.HasAnyActiveIoDid == TRUE)
  {
    Dcm_CfgDidMgrDidOpClassHandleOptType opInfoRefPage = 0;
    Dcm_CfgDidMgrIoDidHandleOptType ioDidIter;

    Dcm_SingletonContext.Diag.Services.Svc2F.HasAnyActiveIoDid = FALSE;

    for(ioDidIter = 0; ioDidIter < Dcm_UtiGenericBitSetCalcSize(DCM_NUM_IODIDS); ioDidIter++)
    {
      Dcm_UtiBitSetBasePtrType pActiveIoDids = Dcm_Svc2FGetActiveIoDids(ioDidIter);
      Dcm_CfgDidMgrDidOpClassHandleOptType opInfoRef = opInfoRefPage;
      DCM_UTI_LOOP_BIT_SCAN(*pActiveIoDids)                                                                                                          /* SBSW_DCM_POINTER_WRITE_2FACTIVEIODIDS */
      {
        if(Dcm_UtiBitOpTest(Dcm_UtiBitSetBaseType, *pActiveIoDids, 0x01u))
        {
          Dcm_DidMgrIoControlRtrnCtrl2Ecu(Dcm_DidMgrGetCtrlOpInfoRef(opInfoRef));
        }
        ++opInfoRef;
      }
      opInfoRefPage += (Dcm_CfgDidMgrDidOpClassHandleOptType)Dcm_UtiGetNumBitsOfXintType(Dcm_UtiBitSetBaseType);/* next bunch of IoDids */           /* PRQA S 2983 */ /* MD_Dcm_Redundant_2983 */
    }
  }
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2FExtractCEMR()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(uint32, DCM_CODE) Dcm_Svc2FExtractCEMR(
  Dcm_ReadOnlyMsgType cemrStream,
  Dcm_CfgDidMgrIoDidCemrLengthMemType cemrSize
  )
{
  uint32 lResult = 0;

  if(cemrSize <= 4u)
  {
    Dcm_CfgDidMgrIoDidCemrLengthOptType lCemrIter;

    /* Extract the CEMR byte-wise */
    for(lCemrIter = 0; lCemrIter < cemrSize; ++lCemrIter)
    {
      lResult <<= 8u;
      lResult |= cemrStream[lCemrIter];
    }

    /* For a 3 byte CEMR a 32bit value will be passed -> move to the MSB to fulfill the IO C/S API convention */
    if(cemrSize == 3u)
    {
      lResult <<= 8u;
    }
  }/* else - leave the result = 0 (invalid value) */

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc2FProcessCEMR()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FProcessCEMR(
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext
  )
{
  Dcm_CfgDidMgrIoDidCemrLengthMemType lCemrSize;

  /* Consider requests with and without CEMR */
  lCemrSize = Dcm_DidMgrGetCtrlEnblMaskLength(Dcm_CfgDidMgrGetDidInfo(&(pRepContext->DidInfoContext)));                                              /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lCemrSize != 0u)
  {
    /*
     * Subtract CEMR length from request length to get only the requested DID size in order to get the concrete length
     * of the last DID signal (if variable length)
     */
    Dcm_UtiUpdateReqLength(pMsgContext, lCemrSize);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
    pRepContext->DidOpTypeContext.OpType.Io.EnableMaskPtr = Dcm_UtiGetReqDataRel(pMsgContext, pMsgContext->reqDataLen);                              /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Extract CEMR as a value */
    pRepContext->DidOpTypeContext.OpType.Io.ControlEnableMaskRecord = Dcm_Svc2FExtractCEMR(pRepContext->DidOpTypeContext.OpType.Io.EnableMaskPtr     /* SBSW_DCM_PARAM_PTR_WRITE */ /* SBSW_DCM_PARAM_PTR_FORWARD */
                                                                                          ,lCemrSize);
  }
  else
  {
    /* else - the request does not contain any CEMR */
    pRepContext->DidOpTypeContext.OpType.Io.EnableMaskPtr = NULL_PTR;                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
  }
}

/**********************************************************************************************************************
 *  Dcm_Svc2FCalculateExpectedReqLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FCalculateExpectedReqLength(
  Dcm_DidMgrDidLengthPtrType expLengthMin,
  Dcm_DidMgrDidLengthPtrType expLengthMax,
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_CfgDidMgrIoDidCemrLengthMemType lCemrSize;

  if(Dcm_UtiBitOpTest(Dcm_DidMgrOpMemType, pRepContext->OpType, DCM_DIDMGR_OPTYPE_IO_SHRTTRMADJ))
  {
    /* Initialize DID handler */
    Dcm_DidMgrInitOpTypeHandler(&(pRepContext->DidInfoContext), &(pRepContext->DidOpTypeContext));                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* short term adjustment - consider optional enable mask record and the DID data! */
    *expLengthMax = (Dcm_DidMgrDidLengthType)Dcm_CfgDidMgrGetDidInfo(&(pRepContext->DidInfoContext))->MaxLength;                                     /* SBSW_DCM_PARAM_PTR_WRITE */
    *expLengthMin = (Dcm_DidMgrDidLengthType)Dcm_CfgDidMgrGetDidInfo(&(pRepContext->DidInfoContext))->MinLength;                                     /* SBSW_DCM_PARAM_PTR_WRITE */
    if(*expLengthMin == 0u) /* IO DID with dynamic length AND single signal */
    {
      *expLengthMin = 1;                                                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }
  else
  {
    *expLengthMin = 0u;                                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
    *expLengthMax = 0u;                                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
  }

  lCemrSize = Dcm_DidMgrGetCtrlEnblMaskLength(Dcm_CfgDidMgrGetDidInfo(&(pRepContext->DidInfoContext)));                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
  *expLengthMin += lCemrSize;                                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */ /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */
  *expLengthMax += lCemrSize;                                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */ /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */
}

/**********************************************************************************************************************
 *  Dcm_Svc2FCheckReqLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_Svc2FCheckReqLength(
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext
  )
{
  Dcm_NegativeResponseCodeType lNrc = DCM_E_POSITIVERESPONSE;
  Dcm_DidMgrDidLengthType expMinReqLen;
  Dcm_DidMgrDidLengthType expMaxReqLen;

  Dcm_Svc2FCalculateExpectedReqLength(&expMinReqLen, &expMaxReqLen, pRepContext);                                                                    /* SBSW_DCM_COMB_PTR_FORWARD */

  /* Check DID specific length */
  if( (pMsgContext->reqDataLen < expMinReqLen)
    ||(pMsgContext->reqDataLen > expMaxReqLen) )
  {
    lNrc = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
  }

  return lNrc;
}

/**********************************************************************************************************************
 *  Dcm_Svc2FIoDidOperationProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FIoDidOperationProcessor(
  Dcm_ContextPtrType pContext,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType  lStdResult = DCM_E_NOT_OK;
  Dcm_CfgStateRefOptType lStateRef;

  /* Initialize the IO-Control operation class from now for any checks that may come
   * (i.e. within Dcm_Svc2FCheckReqLength or later for the IO Control execution)  */
  Dcm_DidMgrInitOpClassInfo(&(pRepContext->DidInfoContext)
                           ,pRepContext->OpType);                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* Validate request length */
  *ErrorCode = Dcm_Svc2FCheckReqLength(pMsgContext, pRepContext);                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_PARAM_PTR_WRITE */

  if(*ErrorCode == DCM_E_POSITIVERESPONSE)
  {
    lStateRef = Dcm_CfgDidMgrGetDidOpInfo(&(pRepContext->DidInfoContext))->ExecCondRef;

    /* Validate remaining state preconditions */
    lStdResult = Dcm_DidMgrStaticDidStateCheck(Dcm_NetGetConnHdlOfRxPduId(pMsgContext->rxPduId)                                                      /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_PARAM_PTR_FORWARD */
                                              ,pRepContext->DidInfoContext.Did
                                              ,DCM_DIDMGR_OP_IO
                                              ,lStateRef
                                              ,ErrorCode);
    if(lStdResult == DCM_E_OK)
    {
      /* Process any eventually supported CEMR */
      Dcm_Svc2FProcessCEMR(pMsgContext, pRepContext);                                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
      Dcm_RepeaterNextStep(pContext, DCM_SVC2F_PROGRESS_CHECKACCESS); /* delegate job */                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */

      lStdResult = DCM_E_LOOP;/* speed up processing */
    }/* else DCM_E_NOT_OK (ErrorCode already set) */
  }/* else DCM_E_NOT_OK (ErrorCode already set) */

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc2FCheckAccess()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FCheckAccess(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,                                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_RsrcMgrGetDidLock(opStatus, pRepContext->DidInfoContext.Did, DCM_RSRCMGR_DIDLOCK_OWNER_SID2F);

  if(lStdResult == DCM_E_OK)
  {
    Dcm_RepeaterNextStep(pContext, DCM_SVC2F_PROGRESS_EXECUTEOP); /* delegate job */                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP;/* speed up processing */
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc2FGetLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FGetLength(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdReturn = DCM_E_OK;

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if(Dcm_DidMgrIsOpTypeSupported(Dcm_CfgDidMgrGetDidOpInfo(&(pRepContext->DidInfoContext)), DCM_DIDMGR_OPTYPE_READLENGTH))
  {
    Dcm_DidMgrInitOpClassInfo(&(pRepContext->DidInfoContext), DCM_DIDMGR_OPTYPE_READLENGTH);                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */

    lStdReturn = Dcm_DidMgrReadLength(opStatus
                                     ,&(pRepContext->DidInfoContext)
                                     ,&(pRepContext->DidOpTypeContext)
                                     ,ErrorCode);                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  if(lStdReturn == DCM_E_OK)
  {
    /* Delegate the job to the data reader */
    Dcm_RepeaterNextStep(pContext, DCM_SVC2F_PROGRESS_READDATA);                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdReturn = DCM_E_LOOP;
  } /* else DCM_E_PENDING or DCM_E_NOT_OK (ErrorCode already set) */

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc2FReadData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FReadData(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType          lStdResult;

  if(opStatus == DCM_INITIAL)
  {
    /* Initialize data context for asynchronous IO DIDs only initially (not in pending status) */
    Dcm_UtiInitDataContext(&Dcm_SingletonContext.Diag.Services.Svc2F.DataContext, Dcm_UtiGetResData(pMsgContext), pMsgContext->resMaxDataLen);       /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* Read DID  */
  Dcm_DidMgrInitOpClassInfo(&(pRepContext->DidInfoContext), DCM_DIDMGR_OPTYPE_READ);                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  lStdResult = Dcm_DidMgrReadDid(opStatus
                                ,&Dcm_SingletonContext.Diag.Services.Svc2F.DataContext
                                ,&(pRepContext->DidInfoContext)
                                ,&(pRepContext->DidOpTypeContext)
                                ,ErrorCode);                                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)
  {
    /* Commit data and go on with response */
    Dcm_UtiProvideResData(pMsgContext, pRepContext->DidInfoContext.DidLength);                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc2FExecuteOp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FExecuteOp(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_DidMgrIoControl(opStatus
                                  ,pMsgContext
                                  ,&(pRepContext->DidInfoContext)
                                  ,&(pRepContext->DidOpTypeContext)
                                  ,ErrorCode);                                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)
  {
# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
    if(pRepContext->OpType != DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU)
    {
      /*
       * After sucessful execution of a control operation other than "ReturnControlToEcu", register the entire IODID for
       * automatic reset on a session/security transition (only if "ReturnControlToEcu" is supported by that IODID)
       */
      if(Dcm_DidMgrIsOpTypeSupported(Dcm_CfgDidMgrGetDidOpInfo(&(pRepContext->DidInfoContext)),
                                     DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU))                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
      {
        Dcm_CfgDidMgrCombinedOpRefType lOpRef;

        lOpRef = Dcm_DidMgrOpInfoRedirector(Dcm_CfgDidMgrGetDidInfo(&(pRepContext->DidInfoContext))->OpRef, OpRefIoControl);

        /* Must have a valid index! */
        Dcm_DebugAssert(lOpRef < DCM_NUM_IODIDS, DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG);                                                            /* COV_DCM_RTM_DEV_DEBUG XF */ /* SBSW_DCM_PARAM_PTR_FORWARD */

        Dcm_Svc2FSetDidActive(lOpRef);                                                                                                               /* SBSW_DCM_POINTER_WRITE_BITSET */

        Dcm_SingletonContext.Diag.Services.Svc2F.HasAnyActiveIoDid = TRUE;
      }
    }
# endif
    /* Decide whether any response data has to be sent back to the client */
    if(Dcm_DidMgrIsOpSupported(Dcm_CfgDidMgrGetDidInfo(&(pRepContext->DidInfoContext)), DCM_DIDMGR_OP_READ))
    {
      Dcm_DidMgrInitOpInfo(&(pRepContext->DidInfoContext), DCM_DIDMGR_OP_READ);                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */

      Dcm_RepeaterNextStep(pContext, DCM_SVC2F_PROGRESS_GETLENGTH);                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_LOOP;
    } /* Otherwise, IO DID does not support reading operation - continue with an empty positive response */
  } /* DCM_E_PENDING | DCM_E_NOT_OK */

  return lStdResult;
}
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CfgSvc86SubFuncInfoGetEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgSvc86SubFuncInfoGetEntry(
  Dcm_DiagSubServiceRefOptType SubSvcRef,
  CONSTP2VAR(Dcm_CfgSvc86SubFuncInfoPtrType, AUTOMATIC, AUTOMATIC) pSubFuncInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lResult;

  if (Dcm_DebugDetectRuntimeError(SubSvcRef >= DCM_CFGSVC86SUBFUNCINFO_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);

    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_NOT_OK;
  }
  else
  {
    *pSubFuncInfo = &Dcm_CfgSvc86SubFuncInfo[SubSvcRef];                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_OK;
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc86Handler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc86Handler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc86RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType                lStdResult;
  Dcm_DiagSubServiceRefOptType  lSubSvcRef;
  uint8                         lReqSf;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lReqSf = Dcm_UtiGetReqDataAsU8(pMsgContext);                                                                                                       /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */

  lStdResult = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                                   ,Dcm_CfgSvc86SubFuncLookUpTable
                                                   ,Dcm_CfgSvc86SubFuncExecPrecondTable
                                                   ,Dcm_Svc86ReqLengthGetter
                                                   ,Dcm_DiagNoSequenceChecker
                                                   ,&lSubSvcRef
                                                   ,ErrorCode);                                                                                      /* SBSW_DCM_COMB_PTR_FORWARD */

  if(lStdResult == DCM_E_OK)
  {
    pRepContext->SubSvcRef  = (Dcm_DiagSubServiceRefMemType)lSubSvcRef;                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
    pRepContext->StoreState = (Dcm_UtiBitOpTest(uint8, lReqSf, 0x40) ? TRUE : FALSE);                                                                /* SBSW_DCM_PARAM_PTR_WRITE */

    Dcm_RepeaterNextStep(pContext, DCM_SVC86_PROGRESS_SUBFUNCTION); /* delegate job */                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP;/* speed up processing */
  } /* else DCM_E_NOT_OK (ErrorCode is already set) */

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc86SubFuncHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc86SubFuncHandler(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc86RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType                 lStdResult;
  Dcm_CfgSvc86SubFuncInfoPtrType pSubFuncInfo;

  lStdResult = Dcm_CfgSvc86SubFuncInfoGetEntry(pRepContext->SubSvcRef, &pSubFuncInfo, ErrorCode);                                                    /* SBSW_DCM_COMB_PTR_FORWARD */

  if (lStdResult == DCM_E_OK)                                                                                                                        /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    lStdResult = pSubFuncInfo->SubSvcFunc(pContext, opStatus, pMsgContext, ErrorCode);                                                               /* SBSW_DCM_CALL_FUNCPTR_SVC86SUBFUNC */
  }

  return lStdResult;
}
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
#include "Dcm_MemMap.h"                                                                                                                              /* PRQA S 5087 */ /* MD_MSR_MemMap */

#define DCM_START_SEC_CODE
#include "Dcm_MemMap.h"                                                                                                                              /* PRQA S 5087 */ /* MD_MSR_MemMap */
#if (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_STATE_AUTHENTICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckRole()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckRole(
  Dcm_CfgStateRefOptType stateRef,
  Dcm_CfgNetAuthInfoRefMemType authInfoRef
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;

  /* Check if authentication restriction is supported for this connection */
  if(authInfoRef != DCM_AUTHMGR_INVALID_AUTH_INFO_REF)
  {
#  if (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
    /* Check if global access has been granted through service whitelist at DSD */
    if(Dcm_AuthMgrIsGlobalAccessGranted())
    {
      lStdResult = DCM_E_OK;
    }
    else
#  endif
    {
      if(!Dcm_StateIsSupportedInRole(Dcm_StateGetPreconditionStates(stateRef), authInfoRef))
      {
        lStdResult = DCM_E_NOT_OK;
      }
    }
  }
  return lStdResult;
}
# endif

# if (DCM_STATE_AUTHENTICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckDispatcherLevel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckDispatcherLevel(
  uint8 sid,
  Dcm_CfgStateRefOptType stateRef,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_CfgNetAuthInfoRefMemType authInfoRef,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

#  if (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
  /* Reset global access flag */
  Dcm_AuthMgrSetGlobalAccess(FALSE);
#  endif

  /* Check authentication role */
  lStdResult = Dcm_AuthMgrCheckRole(stateRef, authInfoRef);

#  if (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
  if(lStdResult == DCM_E_NOT_OK)
  {
    /* If role check fails, try whitelist */
    lStdResult = Dcm_AuthMgrCheckServiceWLDispatcher(sid, pMsgContext, authInfoRef);                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
#  else
  DCM_IGNORE_UNREF_PARAM(sid);                                                                                                                       /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
#  endif

  if(lStdResult == DCM_E_NOT_OK)
  {
    *ErrorCode = DCM_E_AUTHENTICATIONREQUIRED;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
  }

  return lStdResult;
}
# endif

# if (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckServiceWLDispatcher()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckServiceWLDispatcher(
  uint8 sid,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_CfgNetAuthInfoRefMemType authInfoRef
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;

  uint16_least lIter;

  /* Reset global access flag */
  Dcm_AuthMgrSetGlobalAccess(FALSE);

  /* If requesting connection is authenticated: */
  if(Dcm_AuthMgrAuthenticationState(authInfoRef) == DCM_AUTHENTICATED)
  {
    /* Loop through all service white list elements */
    for(lIter = 0u; lIter < Dcm_AuthMgrNumSvcWLElements(authInfoRef); lIter ++)
    {
      /* If service white list element should be processed in DSP: */
      if(!Dcm_AuthMgrSvcWLElemIsDSP(authInfoRef, lIter))
      {
        uint8_least lElemIter;
        boolean lFound = TRUE;
        /* If SID matches the first byte of element: */
        if(sid == Dcm_AuthMgrSvcWLElemDataAt(authInfoRef, lIter, 0u))
        {
          /* Loop through the rest of the element bytes */
          for(lElemIter = 0u; lElemIter < ((uint8_least)Dcm_AuthMgrSvcWLElemLen(authInfoRef, lIter) - 1u); lElemIter ++)
          {
            /* If the iterator does not exceed request data length: */
            if(lElemIter < pMsgContext->reqDataLen)
            {
              /* If the element byte doesn't match corresponding request byte: */
              if(pMsgContext->reqData[lElemIter] != Dcm_AuthMgrSvcWLElemDataAt(authInfoRef, lIter, (lElemIter + 1u)))
              {
                /* Set found boolean to false and skip element */
                lFound = FALSE;
                break;
              }
            }
            else
            {
              /* Element size needs to be less than or equal to the request length */
              lFound = FALSE;
            }
          }
        }
        else
        {
          /* SID doesn't match */
          lFound = FALSE;
        }

        /* If a matching element is found: */
        if(lFound == TRUE)
        {
          /* Grant global request access (no need to check subfunction or data) */
          Dcm_AuthMgrSetGlobalAccess(TRUE);
          lStdResult = DCM_E_OK;
          break;
        }
      }
    }
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_AUTHMGR_DID_CHECK_ENABLED == STD_ON)
#  if (DCM_AUTHMGR_WHITELIST_DID_ENABLED == STD_ON) || \
      (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckDidWL()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckDidWL(
  uint16 did,
  Dcm_DidOpType didOpMask,
  Dcm_CfgNetAuthInfoRefMemType authInfoRef
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  uint16_least lIter;

#   if (DCM_AUTHMGR_WHITELIST_DID_ENABLED == STD_ON)
  /* Loop through entire DID WL */
  for(lIter = 0u; lIter < Dcm_AuthMgrNumDIDWLElements(authInfoRef); lIter++)
  {
    /* If we find the DID we're after */
    if(did == Dcm_AuthMgrDidWLElem(authInfoRef, lIter).DidNumber)
    {
      /* And the right DID op access */
      if(Dcm_UtiBitOpTest(uint8, Dcm_AuthMgrDidWLElem(authInfoRef, lIter).DidAccessMask, didOpMask))
      {
        lStdResult = DCM_E_OK;
        break;
      }
    }
  }
#   endif
#   if (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
  /* Check service white list for allowance */
  if(lStdResult == DCM_E_NOT_OK)                                                                                                                     /* PRQA S 2991, 2995 */ /* MD_Dcm_ConstExpr, MD_Dcm_ConstExpr */
  {
    uint8 lSid = Dcm_DidMgrGetSidFromOp(didOpMask);
    if(lSid != DCM_DIDMGR_SVC_NONE)
    {
      /* Loop over all service WL elements */
      for(lIter = 0u; lIter < Dcm_AuthMgrNumSvcWLElements(authInfoRef); lIter ++)
      {
        if(Dcm_AuthMgrSvcWLElemIsDIDWRIO(authInfoRef, lIter))
        {
          /* Check the bytes of the white list element */
          if((lSid == Dcm_AuthMgrSvcWLElemDataAt(authInfoRef, lIter, 0u))
           && (Dcm_UtiGetHiByte(did) == Dcm_AuthMgrSvcWLElemDataAt(authInfoRef, lIter, 1u))
           && (Dcm_UtiGetLoByte(did) == Dcm_AuthMgrSvcWLElemDataAt(authInfoRef, lIter, 2u)))
          {
            /* We have found a matching element to the request! */
            lStdResult = DCM_E_OK;
            /* No need to check further */
            break;
          }
        }
      }
    }
  }
#   endif

  /* Return search result */
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
#  endif
# endif

# if (DCM_AUTHMGR_DID_CHECK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckDid(
  Dcm_NetConnRefMemType connHdl,
  uint16 did,
  Dcm_DidOpType didOpMask,
  Dcm_CfgStateRefOptType stateRef
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;

  if(connHdl != DCM_NET_INVALID_CONNHDL)
  {
    Dcm_CfgNetAuthInfoRefMemType lAuthInfoRef = Dcm_NetGetAuthInfoRef(connHdl);

    /* Check authentication role */
    lStdResult = Dcm_AuthMgrCheckRole(stateRef, lAuthInfoRef);

#  if (DCM_AUTHMGR_WHITELIST_DID_ENABLED == STD_ON) || \
      (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
    /* If Role check fails, check DID WL if in authenticated state */
    if((lStdResult == DCM_E_NOT_OK) && (Dcm_AuthMgrAuthenticationState(lAuthInfoRef) == DCM_AUTHENTICATED))
    {
      lStdResult = Dcm_AuthMgrCheckDidWL(did, didOpMask, lAuthInfoRef);
    }
#  else
    DCM_IGNORE_UNREF_PARAM(did);                                                                                                                     /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
    DCM_IGNORE_UNREF_PARAM(didOpMask);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
#  endif
  }

  return lStdResult;
}
# endif

# if (DCM_AUTHMGR_WHITELIST_RID_ENABLED == STD_ON) || \
     (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckRidWL()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckRidWL(
  uint16 rid,
  uint8 ridSubfunc,
  Dcm_CfgNetAuthInfoRefMemType authInfoRef
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  uint16_least lIter;

#  if (DCM_AUTHMGR_WHITELIST_RID_ENABLED == STD_ON)
  /* Loop through entire RID WL */
  for(lIter = 0u; lIter < Dcm_AuthMgrNumRIDWLElements(authInfoRef); lIter++)
  {
    /* If we find the RID we're after */
    if(rid == Dcm_AuthMgrRidWLElem(authInfoRef, lIter).RidNumber)
    {
      /* And the right RID op access */
      if(Dcm_UtiBitOpTest(uint8, Dcm_AuthMgrRidWLElem(authInfoRef, lIter).RidAccessMask, Dcm_RidMgrConvOpOfSubFunc(ridSubfunc)))
      {
        lStdResult = DCM_E_OK;
        break;
      }
    }
  }
#  endif
#  if (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
  /* Check service white list for allowance */
  if(lStdResult == DCM_E_NOT_OK)                                                                                                                     /* PRQA S 2991, 2995 */ /* MD_Dcm_ConstExpr, MD_Dcm_ConstExpr */
  {
    /* Loop over all service WL elements */
    for(lIter = 0u; lIter < Dcm_AuthMgrNumSvcWLElements(authInfoRef); lIter++)
    {
      if(Dcm_AuthMgrSvcWLElemIsRID(authInfoRef, lIter))
      {
        /* Check the bytes of the white list element */
        if((ridSubfunc == Dcm_AuthMgrSvcWLElemDataAt(authInfoRef, lIter, 1u))
         && (Dcm_UtiGetHiByte(rid) == Dcm_AuthMgrSvcWLElemDataAt(authInfoRef, lIter, 2u))
         && (Dcm_UtiGetLoByte(rid) == Dcm_AuthMgrSvcWLElemDataAt(authInfoRef, lIter, 3u)))
        {
          /* We have found a matching element to the request! */
          lStdResult = DCM_E_OK;
          /* No need to check further */
          break;
        }
      }
    }
  }
#  endif

  /* Return search result */
  return lStdResult;
}
# endif

# if (DCM_AUTHMGR_RID_CHECK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckRid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckRid(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  uint16 rid,
  uint8 ridSubfunc,
  Dcm_CfgStateRefOptType stateRef
  )
{
  Std_ReturnType lStdResult;

  Dcm_CfgNetAuthInfoRefMemType lAuthInfoRef = Dcm_NetGetAuthInfoRef(Dcm_DiagGetTranspObj(pContext)->ConnHdl);

  /* Check authentication role */
  lStdResult = Dcm_AuthMgrCheckRole(stateRef, lAuthInfoRef);

#  if (DCM_AUTHMGR_WHITELIST_RID_ENABLED == STD_ON) || \
      (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
  /* If Role check fails, check RID WL if in authenticated state */
  if((lStdResult == DCM_E_NOT_OK) && (Dcm_AuthMgrAuthenticationState(lAuthInfoRef) == DCM_AUTHENTICATED))
  {
    lStdResult = Dcm_AuthMgrCheckRidWL(rid, ridSubfunc, lAuthInfoRef);
  }
#  else
  DCM_IGNORE_UNREF_PARAM(rid);                                                                                                                       /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ridSubfunc);                                                                                                                /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
#  endif

  return lStdResult;
}
# endif

# if (DCM_AUTHMGR_WHITELIST_MEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckMemWL()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckMemWL(
  uint8 memId,
  Dcm_CfgNetAuthInfoRefMemType authInfoRef
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;

  uint16_least lIter;

  /* Loop through entire MEM WL */
  for(lIter = 0u; lIter < Dcm_AuthMgrNumMemWLElements(authInfoRef); lIter++)
  {
    /* If we find the MEM we're after */
    if(memId == Dcm_AuthMgrMemWLElem(authInfoRef, lIter).MemNumber)
    {
      lStdResult = DCM_E_OK;
      break;
    }
  }

  /* Return search result */
  return lStdResult;
}
# endif

# if (DCM_STATE_AUTHENTICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrGetCertRole()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrGetCertRole(
  Dcm_OpStatusType opStatus,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lKeyMResult;
  Std_ReturnType lStdResult = DCM_E_OK;

  uint32 lRoleElementLength = DCM_AUTHMGR_CERT_ROLE_SIZE;
  uint8 lRoleReadElement[4];
  Dcm_CfgStateGroupMemType lRoleInLittleEndian;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Extract the role from the certificate */
  lKeyMResult = KeyM_CertElementGet(Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].ConnectionCertificateId
                                   ,Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].CertRoleId
                                   ,lRoleReadElement
                                   ,&lRoleElementLength);                                                                                            /* SBSW_DCM_POINTER_WRITE_CERTIFICATE_ROLE */


  /* If role extraction from certificate was successful */
  if(lKeyMResult == E_OK)
  {
    /* If the size of the read role is equal to configured role size */
    if(lRoleElementLength == DCM_AUTHMGR_CERT_ROLE_SIZE)
    {
      /* Store role in role context. Cast to Dcm_CfgStateGroupMemType to truncate unwanted upper bytes */
      lRoleInLittleEndian = ((Dcm_CfgStateGroupMemType)(Dcm_UtiMake32Bit(lRoleReadElement[3]
                                                                        ,lRoleReadElement[2]
                                                                        ,lRoleReadElement[1]
                                                                        ,lRoleReadElement[0])));

      pRepContext->ConnContext.ActiveRole = lRoleInLittleEndian;                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
    {
      if(Dcm_DebugDetectError(lRoleElementLength > DCM_AUTHMGR_CERT_ROLE_SIZE))
      {
        /* Send panic NRC */
        *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_BUFFER_OVERFLOW);
      }
      else
      {
        /* Otherwise return NRC 55 */
        *ErrorCode = DCM_E_CVF_INVALIDCONTENT;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
    }
  }
  else
  {
    /* Role extraction wasn't successful, return Error */
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
  }

  return lStdResult;
}
# endif

# if (DCM_AUTHMGR_WHITELISTS_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrGetCertWLElement()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrGetCertWLElement(
  uint16 certificateId,
  uint16 certElementId,
  Dcm_MsgType pElementData,
  Dcm_Uint32VarDataPtrType pElementDataLength,
  Dcm_OpStatusType opStatus,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;
  Std_ReturnType lKeyMResult;

    /* If first element to be read: */
  if(opStatus == DCM_INITIAL)
  {
    /* Retrieve first element with KeyM_CertElementGetFirst, which sets up KeyM iterator struct */
    lKeyMResult = KeyM_CertElementGetFirst(certificateId
                                          ,certElementId
                                          ,&pRepContext->CertElementIterator
                                          ,pElementData
                                          ,pElementDataLength);                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else
  {
    /* Retrieve remeining elements with KeyM_CertElementGetNext */
    lKeyMResult = KeyM_CertElementGetNext(&pRepContext->CertElementIterator
                                         ,pElementData
                                         ,pElementDataLength);                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* If KeyM_CertElementGet[First/Next] returns E_OK: */
  if(lKeyMResult == E_OK)
  {
    lStdResult = DCM_E_LOOP;
  }
  /* Otherwise, if KeyM function returns E_NOT_OK: */
  else if(lKeyMResult == E_NOT_OK) /* End of list */
  {
    /* End of elements list, return success */
    lStdResult = DCM_E_OK;
  }
  /* Otherwise, send panic NRC */
  else
  {
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6060 */ /* MD_MSR_STPAR */
# endif

# if (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrServiceWLReadList()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrServiceWLReadList(
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType                     lStdResult;
  Dcm_OpStatusType                   lOpStatus = DCM_INITIAL;
  Dcm_AuthMgrWLServiceContextPtrType pWLServiceContext = &pRepContext->ConnContext.WLContext.WLServiceContext;

  pWLServiceContext->NumServiceWLElements = 0u;                                                                                                      /* SBSW_DCM_GLOBAL_PTR_WRITE */

  /* Loop over all service white list elements until there are no more left */
  do
  {
    uint32 lElementLength = DCM_AUTHMGR_ELEMENT_SERVICE_SIZE;

    lStdResult = Dcm_AuthMgrGetCertWLElement(Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].ConnectionCertificateId
                                            ,Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].CertWLServicesId
                                            ,&(pWLServiceContext->WLServiceElement[pWLServiceContext->NumServiceWLElements].WLData[0u])
                                            ,&lElementLength
                                            ,lOpStatus
                                            ,pRepContext
                                            ,ErrorCode);                                                                                             /* SBSW_DCM_POINTER_WRITE_SERVICE_WL_ELEMENT */ /* SBSW_DCM_COMB_PTR_FORWARD */

    /* If element successfully read: */
    if(lStdResult == DCM_E_LOOP)
    {
      /* If retrieved element length fits within allocated buffer: */
      if((lElementLength > 0u) && (lElementLength <= DCM_AUTHMGR_ELEMENT_SERVICE_SIZE))
      {
        /* Store length of service white list element */
        pWLServiceContext->WLServiceElement[pWLServiceContext->NumServiceWLElements].WLEntryLength = (uint8)lElementLength;                          /* SBSW_DCM_POINTER_WRITE_SERVICE_WL_ELEMENT */

        /* Increment number of service white list entries for next iteration */
        pWLServiceContext->NumServiceWLElements++;                                                                                                   /* SBSW_DCM_GLOBAL_PTR_WRITE */
        lOpStatus = DCM_PENDING;

        /* If buffer too small for the number of entries: Send NRC 0x55 (DCM_E_CVF_INVALIDCONTENT) */
        if(pWLServiceContext->NumServiceWLElements >= DCM_AUTHMGR_NUM_SERVICE_WL_ELEMENTS)
        {
          *ErrorCode = DCM_E_CVF_INVALIDCONTENT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
        }
      }
      else
      {
        /* Otherwise, if read element is bigger than expected: */
        if(Dcm_DebugDetectError(lElementLength > DCM_AUTHMGR_ELEMENT_SERVICE_SIZE))
        {
          /* Send panic NRC */
          *ErrorCode = DCM_E_PANIC_NRC;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
          Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_BUFFER_OVERFLOW);
        }
        else
        {
          /* Otherwise, send NRC 0x55 (DCM_E_CVF_INVALIDCONTENT) */
          *ErrorCode = DCM_E_CVF_INVALIDCONTENT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
        }
      }
    } /* Otherwise, all elements read or send prepared NRC */
  } while((pWLServiceContext->NumServiceWLElements < DCM_AUTHMGR_NUM_SERVICE_WL_ELEMENTS) && (lStdResult == DCM_E_LOOP));

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_AUTHMGR_WHITELIST_DID_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrDidWLReadList()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrDidWLReadList(
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType                 lStdResult;
  Dcm_OpStatusType               lOpStatus = DCM_INITIAL;
  Dcm_AuthMgrWLDidContextPtrType pWLDidContext = &pRepContext->ConnContext.WLContext.WLDidContext;
  uint32                         lElementLength = DCM_AUTHMGR_ELEMENT_DID_SIZE;
  uint8                          lDidReadElement[DCM_AUTHMGR_ELEMENT_DID_SIZE];

  pWLDidContext->NumDidWLElements = 0u;                                                                                                              /* SBSW_DCM_GLOBAL_PTR_WRITE */

  /* Loop over all service white list elements until there are no more left */
  do
  {
    lStdResult = Dcm_AuthMgrGetCertWLElement(Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].ConnectionCertificateId
                                            ,Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].CertWLDidId
                                            ,&lDidReadElement[0u]
                                            ,&lElementLength
                                            ,lOpStatus
                                            ,pRepContext
                                            ,ErrorCode);                                                                                             /* SBSW_DCM_POINTER_WRITE_WL_ELEMENT */ /* SBSW_DCM_COMB_PTR_FORWARD */

    /* If element successfully read: */
    if(lStdResult == DCM_E_LOOP)
    {
      /* If retrieved element length is as expected: */
      if(lElementLength == DCM_AUTHMGR_ELEMENT_DID_SIZE)
      {
        /* Store DID element data into context (big endian format) */
        pWLDidContext->WLDidElement[pWLDidContext->NumDidWLElements].DidNumber = (Dcm_UtiMake16Bit(lDidReadElement[0u], lDidReadElement[1u]));       /* SBSW_DCM_POINTER_WRITE_DID_WL_ELEMENT */
        pWLDidContext->WLDidElement[pWLDidContext->NumDidWLElements].DidAccessMask = lDidReadElement[2u];                                            /* SBSW_DCM_POINTER_WRITE_DID_WL_ELEMENT */

        /* Increment number of DID white list entries for next iteration */
        pWLDidContext->NumDidWLElements++;                                                                                                           /* SBSW_DCM_GLOBAL_PTR_WRITE */
        lOpStatus = DCM_PENDING;

        /* If buffer too small for the number of entries: Send NRC 0x55 (DCM_E_CVF_INVALIDCONTENT) */
        if(pWLDidContext->NumDidWLElements >= DCM_AUTHMGR_NUM_DID_WL_ELEMENTS)
        {
          *ErrorCode = DCM_E_CVF_INVALIDCONTENT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
        }
      }
      else
      {
        /* Otherwise, if read element is bigger than expected: */
        if(Dcm_DebugDetectError(lElementLength > DCM_AUTHMGR_ELEMENT_DID_SIZE))
        {
          /* Send panic NRC */
          *ErrorCode = DCM_E_PANIC_NRC;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
          Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_BUFFER_OVERFLOW);
        }
        else
        {
          /* Otherwise, send NRC 0x55 (DCM_E_CVF_INVALIDCONTENT) */
          *ErrorCode = DCM_E_CVF_INVALIDCONTENT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
        }
      }
    }/* Otherwise, all elements read or send prepared NRC */
  } while((pWLDidContext->NumDidWLElements < DCM_AUTHMGR_NUM_DID_WL_ELEMENTS) && (lStdResult == DCM_E_LOOP));

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_AUTHMGR_WHITELIST_RID_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrRidWLReadList()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrRidWLReadList(
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType                 lStdResult;
  Dcm_OpStatusType               lOpStatus = DCM_INITIAL;
  Dcm_AuthMgrWLRidContextPtrType pWLRidContext = &pRepContext->ConnContext.WLContext.WLRidContext;
  uint32                         lElementLength = DCM_AUTHMGR_ELEMENT_RID_SIZE;
  uint8                          lRidReadElement[DCM_AUTHMGR_ELEMENT_RID_SIZE];

  pWLRidContext->NumRidWLElements = 0u;                                                                                                              /* SBSW_DCM_GLOBAL_PTR_WRITE */

  /* Loop over all service white list elements until there are no more left */
  do
  {
    lStdResult = Dcm_AuthMgrGetCertWLElement(Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].ConnectionCertificateId
                                            ,Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].CertWLRidId
                                            ,&lRidReadElement[0u]
                                            ,&lElementLength
                                            ,lOpStatus
                                            ,pRepContext
                                            ,ErrorCode);                                                                                             /* SBSW_DCM_POINTER_WRITE_WL_ELEMENT */ /* SBSW_DCM_COMB_PTR_FORWARD */

    /* If element successfully read: */
    if(lStdResult == DCM_E_LOOP)
    {
      /* If retrieved element length is as expected: */
      if(lElementLength == DCM_AUTHMGR_ELEMENT_RID_SIZE)
      {
        /* Store RID element data into context (big endian format) */
        pWLRidContext->WLRidElement[pWLRidContext->NumRidWLElements].RidNumber = (Dcm_UtiMake16Bit(lRidReadElement[0u], lRidReadElement[1u]));       /* SBSW_DCM_POINTER_WRITE_RID_WL_ELEMENT */
        pWLRidContext->WLRidElement[pWLRidContext->NumRidWLElements].RidAccessMask = lRidReadElement[2u];                                            /* SBSW_DCM_POINTER_WRITE_RID_WL_ELEMENT */

        /* Increment number of RID white list entries for next iteration */
        pWLRidContext->NumRidWLElements++;                                                                                                           /* SBSW_DCM_GLOBAL_PTR_WRITE */
        lOpStatus = DCM_PENDING;

        /* If buffer too small for the number of entries: Send NRC 0x55 (DCM_E_CVF_INVALIDCONTENT) */
        if(pWLRidContext->NumRidWLElements >= DCM_AUTHMGR_NUM_RID_WL_ELEMENTS)
        {
          *ErrorCode = DCM_E_CVF_INVALIDCONTENT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
        }
      }
      else
      {
        /* Otherwise, if read element is bigger than expected: */
        if(Dcm_DebugDetectError(lElementLength > DCM_AUTHMGR_ELEMENT_RID_SIZE))
        {
          /* Send panic NRC */
          *ErrorCode = DCM_E_PANIC_NRC;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
          Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_BUFFER_OVERFLOW);
        }
        else
        {
          /* Otherwise, send NRC 0x55 (DCM_E_CVF_INVALIDCONTENT) */
          *ErrorCode = DCM_E_CVF_INVALIDCONTENT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
        }
      }
    }/* Otherwise, all elements read or send prepared NRC */
  } while((pWLRidContext->NumRidWLElements < DCM_AUTHMGR_NUM_RID_WL_ELEMENTS) && (lStdResult == DCM_E_LOOP));

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_AUTHMGR_WHITELIST_MEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrMemWLReadList()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrMemWLReadList(
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType                 lStdResult;
  Dcm_OpStatusType               lOpStatus = DCM_INITIAL;
  Dcm_AuthMgrWLMemContextPtrType pWLMemContext = &pRepContext->ConnContext.WLContext.WLMemContext;
  uint32                         lElementLength = DCM_AUTHMGR_ELEMENT_MEM_SIZE;
  uint8                          lMemReadElement[DCM_AUTHMGR_ELEMENT_MEM_SIZE];

  pWLMemContext->NumMemWLElements = 0u;                                                                                                              /* SBSW_DCM_GLOBAL_PTR_WRITE */

  /* Loop over all service white list elements until there are no more left */
  do
  {

    lStdResult = Dcm_AuthMgrGetCertWLElement(Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].ConnectionCertificateId
                                            ,Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].CertWLMemId
                                            ,&lMemReadElement[0u]
                                            ,&lElementLength
                                            ,lOpStatus
                                            ,pRepContext
                                            ,ErrorCode);                                                                                             /* SBSW_DCM_POINTER_WRITE_WL_ELEMENT */ /* SBSW_DCM_COMB_PTR_FORWARD */

    /* If element successfully read: */
    if(lStdResult == DCM_E_LOOP)
    {
      /* If retrieved element length is as expected: */
      if(lElementLength == DCM_AUTHMGR_ELEMENT_MEM_SIZE)
      {
        /* Store MEM element data into context */
        pWLMemContext->WLMemElement[pWLMemContext->NumMemWLElements].MemNumber = lMemReadElement[0u];                                                /* SBSW_DCM_POINTER_WRITE_MEM_WL_ELEMENT */

        /* Increment number of MEM white list entries for next iteration */
        pWLMemContext->NumMemWLElements++;                                                                                                           /* SBSW_DCM_GLOBAL_PTR_WRITE */
        lOpStatus = DCM_PENDING;

        /* If buffer too small for the number of entries: Send NRC 0x55 (DCM_E_CVF_INVALIDCONTENT) */
        if(pWLMemContext->NumMemWLElements >= DCM_AUTHMGR_NUM_MEM_WL_ELEMENTS)
        {
          *ErrorCode = DCM_E_CVF_INVALIDCONTENT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
        }
      }
      else
      {
        /* Otherwise, if read element is bigger than expected: */
        if(Dcm_DebugDetectError(lElementLength > DCM_AUTHMGR_ELEMENT_MEM_SIZE))
        {
          /* Send panic NRC */
          *ErrorCode = DCM_E_PANIC_NRC;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
          Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_BUFFER_OVERFLOW);
        }
        else
        {
          /* Otherwise, send NRC 0x55 (DCM_E_CVF_INVALIDCONTENT) */
          *ErrorCode = DCM_E_CVF_INVALIDCONTENT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
        }
      }
    }/* Otherwise, all elements read or send prepared NRC */
  } while((pWLMemContext->NumMemWLElements < DCM_AUTHMGR_NUM_MEM_WL_ELEMENTS) && (lStdResult == DCM_E_LOOP));

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_TMR_NUM_AUTHENTICATION > 0u)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutAuthentication()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutAuthentication(
  Dcm_ThreadIdMemType threadId
  )
{
  Dcm_TmrTimerCntrMemType       lReloadTick = 0u;
  Dcm_CfgNetAuthInfoRefOptType  lTmrIter;

  DCM_IGNORE_UNREF_PARAM(threadId);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Enter critical section (Reason: A timer can be modified from an ISR) */
  Dcm_UtiEnterCriticalSection();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  /* For each software timer: */
  for(lTmrIter = 0; lTmrIter < DCM_AUTHMGR_NUM_DELAY_TIMERS; ++lTmrIter)
  {
    /* If the software timer is active: */
    if(Dcm_AuthMgrTimerActive(lTmrIter) == TRUE)                                                                                                     /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
    {
      /* Decrement the timer value */
      Dcm_AuthMgrTimerSet((Dcm_CfgNetAuthInfoRefMemType)lTmrIter, (Dcm_AuthMgrTimerType)(Dcm_AuthMgrTimerGet(lTmrIter) - 1u));

      /* If the software timer is still active */
      if(Dcm_AuthMgrTimerActive(lTmrIter) == TRUE)                                                                                                   /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
      {
        /* Reload the hardware timer */
        lReloadTick = 1u;
      }
      else
      {
        /* Otherwise, update the global expired timer mask flag with position of expired timer */
        Dcm_AuthMgrTimerExpireMaskSetBit(lTmrIter);
      }
    }
  }
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  /* Leave critical section */
  Dcm_UtiLeaveCriticalSection();

  /* If at least one timer has expired */
  if(Dcm_AuthMgrAnyTimerExpired())                                                                                                                   /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
  {
    /* Set the event to deauthenticate idle connections in default session */
    Dcm_TskSetEventByThread(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_IDLE_CONN, threadId);
  }

  return lReloadTick;
}
# endif
#endif /* (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_NetRegisterComMActivity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetRegisterComMActivity(
  Dcm_NetTransportObjectPtrType pTranspObj                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  DCM_IGNORE_UNREF_PARAM(pTranspObj);                                                                                                                /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
#if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
  if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) == 0u)/* internal requests do not manage the ComM activity */
#endif
  {
    Dcm_CfgNetNetIdRefMemType lNetHandle;
    Dcm_NetComMContextPtrType pComMContext;

    lNetHandle   = Dcm_PbCfgNetConnectionInfo[pTranspObj->ConnHdl].NetworkIdRef;
    pComMContext = Dcm_NetGetComMContext(lNetHandle);

    Dcm_DebugAssert((pComMContext->RegisteredNetworks != Dcm_UtiMaxValueOfUintType(Dcm_NetConnRefMemType)), DCM_SID_INTERNAL, DCM_E_PARAM);          /* COV_DCM_RTM_DEV_DEBUG XF */

    Dcm_UtiEnterCriticalSection();
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    if(pComMContext->RegisteredNetworks == 0u)
    {
      /* activate only if default session is active, otherwise already active */
      if(   Dcm_StateIsDefaultSessionActive()
        && (Dcm_SingletonContext.Network.ActiveDiagnostic == DCM_NET_COMM_ACTIVE)
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
        && (Dcm_SingletonContext.Network.KeepAlive == FALSE)
#endif
        )
      {
        /* Register one connection */
        ComM_DCM_ActiveDiagnostic(Dcm_PbCfgNetAllComMChannelMap[Dcm_PbCfgNetConnComMChannelMap[lNetHandle]]);
      }
    }

    /* Register one connection */
    ++pComMContext->RegisteredNetworks;                                                                                                              /* SBSW_DCM_POINTER_WRITE_COMMCONTEXT */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiLeaveCriticalSection();
  }
}

/**********************************************************************************************************************
 *  Dcm_NetUnRegisterComMActivity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUnRegisterComMActivity(
  Dcm_NetConnRefMemType connHdl
  )
{
  Dcm_CfgNetNetIdRefMemType lNetHandle;
  Dcm_NetComMContextPtrType pComMContext;

  lNetHandle   = Dcm_PbCfgNetConnectionInfo[connHdl].NetworkIdRef;
  pComMContext = Dcm_NetGetComMContext(lNetHandle);

  Dcm_DebugAssert((pComMContext->RegisteredNetworks != 0u), DCM_SID_INTERNAL, DCM_E_PARAM);                                                          /* COV_DCM_RTM_DEV_DEBUG XF */

  Dcm_UtiEnterCriticalSection();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  /* Unregister one connection */
  --pComMContext->RegisteredNetworks;                                                                                                                /* SBSW_DCM_POINTER_WRITE_COMMCONTEXT */

  if(pComMContext->RegisteredNetworks == 0u)
  {
    /* return only if default session is active */
    if (Dcm_StateIsDefaultSessionActive()
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
       &&(Dcm_SingletonContext.Network.KeepAlive == FALSE)
#endif
       )
    {
      ComM_DCM_InactiveDiagnostic(Dcm_PbCfgNetAllComMChannelMap[Dcm_PbCfgNetConnComMChannelMap[lNetHandle]]);
    }
  }
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiLeaveCriticalSection();
}

/**********************************************************************************************************************
 *  Dcm_NetUnRegisterAllComMActivity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUnRegisterAllComMActivity(
  void
  )
{
  Dcm_UtiEnterCriticalSection();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  {
    Dcm_CfgNetNetIdRefOptType lNetHandleIter;
    for(lNetHandleIter = 0; lNetHandleIter < Dcm_PbCfgNetNumComMChannels; ++lNetHandleIter)
    {
      /* unregister only if no connection is ongoing */
      if(Dcm_PbRamNetComMContext[lNetHandleIter].RegisteredNetworks == 0u)
      {
        ComM_DCM_InactiveDiagnostic(Dcm_PbCfgNetAllComMChannelMap[Dcm_PbCfgNetConnComMChannelMap[lNetHandleIter]]);
      }
    }
  }
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiLeaveCriticalSection();
}

/**********************************************************************************************************************
 *  Dcm_NetUnRegisterActiveConnection()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUnRegisterActiveConnection(
  Dcm_NetTransportObjectPtrType pTranspObj
  )
{
#if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
  if ((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) != 0u)
  {
# if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)
    Dcm_ExtSvc86TxEnd();
# endif
  }
  else
#endif
  {
    Dcm_DebugAssert((Dcm_SingletonContext.Network.NumActiveConnections != 0u), DCM_SID_INTERNAL, DCM_E_PARAM);                                       /* COV_DCM_RTM_DEV_DEBUG XF */

    Dcm_UtiEnterCriticalSection();
    /*=================================*
     BEGIN CRITICAL SECTION
     *=================================*/
    /* Start the idle connection timer for the authenticated session connection */
#if (DCM_AUTHMGR_DEFAULT_SESSION_TIMEOUT_ENABLED == STD_ON)
    /* Check if authentication restriction is supported for this connection */
    if (Dcm_NetGetAuthInfoRef(pTranspObj->ConnHdl) != DCM_AUTHMGR_INVALID_AUTH_INFO_REF)
    {
      Dcm_AuthMgrTimerStart(Dcm_NetGetAuthInfoRef(pTranspObj->ConnHdl), DCM_AUTHMGR_DEFAULT_SESSION_TIMEOUT);
    }
#endif

    /* If this was not a functional request from different tester with 0x3E 0x80 or a denied parallel tester request */
    if ((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_IGNORE) == 0u)
    {
      /* The timers shall be restarted later with the original timer values (when the last connection goes inactive) */
      Dcm_TmrSetTimer(DCM_TMR_ID_S3, DCM_DIAG_TIME_S3);
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
      Dcm_TmrSetTimer(DCM_TMR_ID_KEEP_ALIVE, DCM_NET_KEEP_ALIVE_TIME);
#endif
    }

    /* Un-register an active connection */
    --Dcm_SingletonContext.Network.NumActiveConnections;

    if(Dcm_SingletonContext.Network.NumActiveConnections == 0u)
    {
      /* Start or resume the S3 timer and keep-alive timer with the last set values */
      Dcm_TmrResumeTimer(DCM_TMR_ID_S3);
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
      Dcm_TmrResumeTimer(DCM_TMR_ID_KEEP_ALIVE);
#endif
    }

    /*=================================*
     END CRITICAL SECTION
     *=================================*/
    Dcm_UtiLeaveCriticalSection();
  }
  Dcm_NetTranspObjRelease(pTranspObj);                                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */

/**********************************************************************************************************************
 *  Dcm_NetAllocateOrGetTranspObject()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetAllocateOrGetTranspObject(
  Dcm_NetConnRefOptType connHdl,
  CONSTP2VAR(Dcm_NetTransportObjectPtrType, AUTOMATIC, AUTOMATIC) pTranspObj
  )
{
  BufReq_ReturnType lResult = BUFREQ_E_NOT_OK; /* No free transport object found */

  if(Dcm_DebugDetectRuntimeError(connHdl >= Dcm_PbCfgNetNumConnections))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
  {
    if(Dcm_PbRamNetConnHdl2TObjMap[connHdl] >= DCM_NET_INVALID_TOBJID)/* check if already assigned */
    {
      Dcm_CfgNetTObjHandleOptType lTObjIter;

      for(lTObjIter = 0; lTObjIter < Dcm_PbCfgNetNumTransportObjects; ++lTObjIter)
      {
        if(Dcm_PbRamNetTransportObject[lTObjIter].State == DCM_NET_TOBJ_STATE_FREE)
        {
          Dcm_NetPutToConn2TObjMap(connHdl, (Dcm_CfgNetTObjHandleMemType)lTObjIter); /* Assign ownership information */
          *pTranspObj = Dcm_NetGetTransportObject(lTObjIter);                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
          lResult = BUFREQ_OK;
          break;
        }/* Transport Object is in use - check next one */
      }
    }
    else
    {
      *pTranspObj = Dcm_NetGetTransportObject(Dcm_PbRamNetConnHdl2TObjMap[connHdl]);                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
      lResult = BUFREQ_OK;
    }
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_NetGetTranspObjOfConnection()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetGetTranspObjOfConnection(
  Dcm_NetConnRefOptType connHdl,
  CONSTP2VAR(Dcm_NetTransportObjectPtrType, AUTOMATIC, AUTOMATIC) pTranspObj
  )
{
  BufReq_ReturnType lResult = BUFREQ_E_NOT_OK;

  if(Dcm_DebugDetectRuntimeError(connHdl >= Dcm_PbCfgNetNumConnections))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
  {
    if(Dcm_PbRamNetConnHdl2TObjMap[connHdl] < DCM_NET_INVALID_TOBJID)
    {
      *pTranspObj = Dcm_NetGetTransportObject(Dcm_PbRamNetConnHdl2TObjMap[connHdl]);                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
      lResult = BUFREQ_OK;
    }
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_NetTranspObjRelease()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTranspObjRelease(
  Dcm_NetTransportObjectPtrType pTranspObj
  )
{
  /* If the transport object is still in use: */
  if(pTranspObj->State != DCM_NET_TOBJ_STATE_FREE) /* assure the object has validly initialized fields */
  {
    /* Its states are valid and can be used if needed */
    /* Reset only the relevant states of the transport object */
    Dcm_NetPutToConn2TObjMap(pTranspObj->ConnHdl, DCM_NET_INVALID_TOBJID); /* Clear the ownership information */
    pTranspObj->ResType  = DCM_NET_TOBJ_RESTYPE_NONE;                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
    pTranspObj->Flags    = DCM_NET_TOBJ_FLAG_NONE;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
    /* Reset the guard state (object in use) at last to avoid critical section usage */
    pTranspObj->State    = DCM_NET_TOBJ_STATE_FREE;                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */

  }
  /* Otherwise nothing to do */
}

/**********************************************************************************************************************
 *  Dcm_NetGetConnHdlByTesterAddress()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Dcm_NetConnRefMemType, DCM_CODE) Dcm_NetGetConnHdlByTesterAddress(
  uint16 testerAddress
  )
{
  Dcm_NetConnRefOptType lConnIter;
  Dcm_NetConnRefMemType lResult = DCM_NET_INVALID_CONNHDL;

  for(lConnIter = 0; lConnIter < Dcm_PbCfgNetNumConnections; ++lConnIter)
  {
    if (testerAddress == Dcm_PbCfgNetConnectionInfo[lConnIter].ClientSrcAddr)
    {
      lResult = (Dcm_NetConnRefMemType)lConnIter;
      break;
    }
  }
  return lResult;
}

#if ((DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON) && (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)) || \
    (DCM_AUTHMGR_SET_DEAUTH_ROLE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetGetConnHdlByConnectionId()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Dcm_NetConnRefMemType, DCM_CODE) Dcm_NetGetConnHdlByConnectionId(
  uint16 connectionId
  )
{
  Dcm_NetConnRefOptType lConnIter;
  Dcm_NetConnRefMemType lResult = DCM_NET_INVALID_CONNHDL;

  for(lConnIter = 0; lConnIter < Dcm_PbCfgNetNumConnections; ++lConnIter)
  {
    if(connectionId == Dcm_PbCfgNetConnectionInfo[lConnIter].ConnectionId)
    {
      lResult = (Dcm_NetConnRefMemType)lConnIter;
      break;
    }
  }
  return lResult;
}
#endif

/**********************************************************************************************************************
 *  Dcm_NetUsdtTxConfirmation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUsdtTxConfirmation(
  Dcm_NetTransportObjectPtrType pTranspObj,
  Dcm_NetTransmissionResultType result
  )
{
  if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_CANCELED) != 0u)
  {
    Dcm_NetBufferContextPtrType pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);
    Dcm_NetBufferRelease(pBufferContext); /* the buffer is free now */                                                                               /* PRQA S 3387 */ /* MD_Dcm_OptimizedInlineCode_3387 */ /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
    /* ComM is already released in the DiagPostProcessing task */
    Dcm_NetUnRegisterActiveConnection(pTranspObj);/* no further processing needed */                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else
  {
    if(pTranspObj->ResType == DCM_NET_TOBJ_RESTYPE_SIMPLE)
    {
#if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
      if ((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) == 0u)
#endif
      {
        Dcm_NetUnRegisterComMActivity(pTranspObj->ConnHdl);
      }
      Dcm_NetUnRegisterActiveConnection(pTranspObj);/* no further processing needed */                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
    else
    {
      Dcm_DiagOnTxFinished(pTranspObj, result);                                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
    }
  }
}

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutPeriodicTx()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutPeriodicTx(
  Dcm_ThreadIdMemType threadId
  )
{
  Dcm_TmrTimerCntrMemType lReloadTick;
  boolean                 lDoReload;

  DCM_IGNORE_UNREF_PARAM(threadId);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lDoReload = Dcm_OnTimeoutTxObjectHandler();
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
  if (!lDoReload)
  {
    lDoReload = Dcm_OnTimeoutDelayTimerHandler();
  }
# endif

  lReloadTick = (Dcm_TmrTimerCntrMemType)((lDoReload == TRUE)?1u:0u);

  return lReloadTick;
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgAllocate()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Dcm_CfgNetPTxObjHandleMemType, DCM_CODE) Dcm_NetPeriodicMsgAllocate(
  uint16 Did
  )
{
  Dcm_CfgNetPTxObjHandleMemType perTxObjHandle = DCM_NET_INVALID_PTXOBJ_HANDLE;

  /* If all queued messages were sent, reset counters (continue with highest prio UUDT) */
  if(Dcm_NetPeriodicMsgGetNextMsgHdl() == Dcm_NetPeriodicMsgGetTxObjectSentCntr())
  {
    /* Note: No critical section needed to avoid interrupt by Dcm_NetPeriodicMsgRelease because at this point, all
     *       messages are already sent and so no more notification interrupt can occur */
    Dcm_NetPeriodicMsgResetNextMsgHdl();
    Dcm_NetPeriodicMsgResetTxObjectSentCntr();
  }

  /* If there is a message ID left that has a lower priority: */
  if(Dcm_NetPeriodicMsgGetNextMsgHdl() < Dcm_NetPeriodicMsgNumMsgsCurrConnection())
  {
    Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj;

    perTxObjHandle = (Dcm_CfgNetPTxObjHandleMemType)Dcm_NetPeriodicMsgGetNextMsgHdl();
    pPeriodicTxObj = Dcm_NetGetPeriodicTxObject(perTxObjHandle);
    pPeriodicTxObj->State = DCM_NET_PERIODIC_TX_STATE_RESERVED; /* Mark tx object as reserved */                                                     /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */
    pPeriodicTxObj->Did = Did; /* Store the DID */                                                                                                   /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */
    Dcm_NetPeriodicMsgIncNextMsgHdl(); /* Increment message handle for next message */
  }

  return perTxObjHandle;
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgRelease()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgRelease(
  Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj
  )
{
# if (DCM_NET_UUDT_DELAYTIMER_ENABLED == STD_ON)
  if (pPeriodicTxObj->State == DCM_NET_PERIODIC_TX_STATE_ONTX)
  {
    Dcm_NetPTxDelayTimerStart(); /* start delay timer */
  }
# endif

  Dcm_NetPTxObjTimerStop(pPeriodicTxObj);                                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
  pPeriodicTxObj->State = DCM_NET_PERIODIC_TX_STATE_FREE;                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */

  Dcm_NetPeriodicMsgIncTxObjectSentCntr(); /* Update sent message statistics */
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgTransmit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgTransmit(
  Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj,
  PduLengthType length
  )
{
  PduLengthType lLength = length;

  Dcm_DebugAssert((Dcm_NetPeriodicMsgGetConnection() < DCM_NET_INVALID_CONNHDL), DCM_SID_INTERNAL, DCM_E_PARAM);                                     /* COV_DCM_RTM_DEV_DEBUG XF */

# if (DCM_NET_PERIODIC_MSG_PADDING_ENABLED == STD_ON)
  if(Dcm_DebugDetectRuntimeError(Dcm_PbCfgNetConnectionInfo[Dcm_NetPeriodicMsgGetConnection()].UudtFrameSize > DCM_NET_PERIODIC_BUFFER_SIZE))        /* COV_DCM_RTM_RUNTIME_CHECK XF */
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
  {
    for(; lLength < Dcm_PbCfgNetConnectionInfo[Dcm_NetPeriodicMsgGetConnection()].UudtFrameSize; lLength++)
    {
      pPeriodicTxObj->TxBuffer[lLength] = DCM_NET_PERIODIC_MSG_PADDING_PATTERN;                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }
# endif

# if (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
  /* In case of generic connection, append the meta data at the end of the paylaod. */
  if(Dcm_NetIsGenericConnection(Dcm_NetPeriodicMsgGetConnection()))
  {
    if(Dcm_DebugDetectRuntimeError(lLength > (PduLengthType)(DCM_NET_PERIODIC_BUFFER_SIZE - DCM_NET_METADATA_LENGTH)))                               /* COV_DCM_RTM_RUNTIME_CHECK XF */
    {
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    }
    else
    {
      pPeriodicTxObj->TxBuffer[lLength] = Dcm_NetGetNodeAddress(Dcm_SingletonContext.Network.PeriodicTxContext.ConnHdlInUse);                        /* SBSW_DCM_PARAM_PTR_WRITE */
      lLength++;
      pPeriodicTxObj->TxBuffer[lLength] = (Dcm_MsgItemType)Dcm_NetPeriodicMsgGetClientSrcAddr();                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
      lLength++;
    }
  }
# endif

  pPeriodicTxObj->TxPduInfo.SduLength = lLength;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
  pPeriodicTxObj->State = DCM_NET_PERIODIC_TX_STATE_QUEUED;                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
  Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND_UUDT);
}
#endif

/**********************************************************************************************************************
 *  Dcm_NetIsKeepAliveRequest()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(boolean, DCM_CODE) Dcm_NetIsKeepAliveRequest(
  PduIdType rxPduId,
  P2CONST(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info,
  uint8 neededLength
  )
{
  boolean lIsTesterPresent = FALSE;
  if (info != NULL_PTR)                                                                                                                              /* PRQA S 2822 */ /* MD_Dcm_2822 */ /* SBSW_DCM_PARAM_PTR_FORWARD */
  {
    if (info->SduLength == neededLength)
    {
      if ((Dcm_PbCfgNetRxPduInfo[rxPduId].IsFuncReq == TRUE)
         && (info->SduDataPtr[0] == 0x3Eu) && (info->SduDataPtr[1] == 0x80u))                                                                        /* PRQA S 2822 */ /* MD_Dcm_2822 */
      {
        lIsTesterPresent = TRUE;
      }
    }
  }
  return lIsTesterPresent;
}

/**********************************************************************************************************************
 *  Dcm_NetSetComModeEntered()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetSetComModeEntered(
  NetworkHandleType networkId,
  Dcm_NetComMStateType newComState
  )
{
  /* used to always verify for valid parameter */
  sint16_least lDcmComMHandle = Dcm_UtiLookUpUint8(Dcm_PbCfgNetNetworkHdlLookUp, networkId);                                                         /* SBSW_DCM_POINTER_FORWARD_GLOBAL */

  if(lDcmComMHandle >= 0) /* consider only DCM relevant channels */
  {
    Dcm_NetComMContextPtrType pComMContext;

    pComMContext = Dcm_NetGetComMContext((Dcm_CfgNetNetIdRefOptType)lDcmComMHandle);

    Dcm_UtiEnterCriticalSection();
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    pComMContext->ComState = newComState;                                                                                                            /* SBSW_DCM_POINTER_WRITE_COMMCONTEXT */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiLeaveCriticalSection();
  }/* else - not a DCM channel -> ignore */
}

/**********************************************************************************************************************
 *  Dcm_NetStartOfReception()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetStartOfReception(
  PduIdType rxPduId,
  P2CONST(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info,
  PduLengthType tpSduLength,
  P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) bufferSizePtr,
  Dcm_NetTransportObjectFlagType addTObjFlags
  )
{
  BufReq_ReturnType lResult = BUFREQ_E_NOT_OK;
  Dcm_NetConnRefMemType lConnHdl = Dcm_NetGetConnHdlOfRxPduId(rxPduId);                                                                              /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
  DCM_IGNORE_UNREF_PARAM(info);                                                                                                                      /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* If the communication state allows any diagnostic request reception (at least SilentCommunicationMode): */
  if( ((DCM_NET_COMM_STATE_FLAG_RX_EN & Dcm_NetGetComStateByConnection(lConnHdl)) != 0u)
#if (DCM_NET_RX_BLOCKING_ENABLED == STD_ON)
    &&(Dcm_SingletonContext.Network.RxAllowed == TRUE)
#endif
#if (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
    &&( (!Dcm_NetIsGenericConnection(lConnHdl))
      ||(Dcm_PbCfgNetRxPduInfo[rxPduId].IsFuncReq == TRUE)
      ||(info->SduDataPtr[info->SduLength-1u] == Dcm_PbCfgNetConnectionInfo[lConnHdl].EcuAddress) )                                                  /* PRQA S 2822 */ /* MD_Dcm_2822 */ /* SBSW_DCM_PARAM_PTR_FORWARD */
#endif
    )
  {
    Dcm_NetTransportObjectPtrType pTranspObj;

    /* Enter critical section (Reason: Needed only on multi-channel DCM configurations to guarantee the correct
     * transport object allocation and initialization) */
    Dcm_UtiEnterCriticalSection();
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    /* Allocate new or get existing, already associated with this DcmRxPduId transport object */
    /* If allocation or getter succeeded: */
    if(Dcm_NetAllocateOrGetTranspObject(lConnHdl, &pTranspObj) == BUFREQ_OK)                                                                         /* SBSW_DCM_POINTER_FORWARD_STACK */
    {
      /* If the transport object is allocated as a new one: */
      if(pTranspObj->State == DCM_NET_TOBJ_STATE_FREE)
      {
        Dcm_PbCfgNetBufferInfoPtrType lBufferInfo;

        pTranspObj->BufferHdl = Dcm_NetGetProtObjOfConnection(lConnHdl)->RxTxBufferRef;                                                              /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
        lBufferInfo = Dcm_NetGetBufferInfo(pTranspObj->BufferHdl);

        /* If the request message length fits the Rx-buffer associated with the DcmRxPduId: */
        if(tpSduLength <= lBufferInfo->Size)
        {
          Dcm_NetBufferContextPtrType pBufferContext;

          /* Prepare for positive result or NRC 0x21 response: */
          pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);
          /* Prepare result to be reported for the available Rx-buffer size */
          *bufferSizePtr = lBufferInfo->Size;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */

          /* Initialize the transport object */
          pTranspObj->RxPduId  = rxPduId;                                                                                                            /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          pTranspObj->ConnHdl   = (Dcm_NetConnRefMemType)lConnHdl;                                                                                   /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */

          /* Set up Rx message context */
          pTranspObj->RxLength = (Dcm_CfgNetBufferSizeMemType)tpSduLength;/* safe cast, since tpSduLength <= bufferSize = value fits Dcm_CfgNetBufferSizeMemType */ /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          pTranspObj->BuffPos  = 0u; /* start writing from the buffer begin */                                                                       /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          pTranspObj->State    = DCM_NET_TOBJ_STATE_ONRX;                                                                                            /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          pTranspObj->Flags    = addTObjFlags;                                                                                                       /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */

#if (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
          /* #20 If the transport object uses generic connection, set meta data. */
          if (Dcm_NetIsGenericConnection(lConnHdl))
          {
            /* Source address of the request shall be the target address of the response. */
            pTranspObj->ClientSrcAddr = info->SduDataPtr[info->SduLength-(PduLengthType)2u];                                                         /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          }
          else
#endif
          {
            pTranspObj->ClientSrcAddr = Dcm_PbCfgNetConnectionInfo[lConnHdl].ClientSrcAddr;                                                          /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
          }

          /* #30 If the new request can be received - that is: */
          if( Dcm_NetBufferIsFree(pBufferContext) /* Is the buffer free? */
#if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
            &&( ((DCM_STATE_VALUE_SESSION_INIT & Dcm_StateGetPendingSession()) != 0u) /* a default session is/will be active */
              ||( (Dcm_NetGetSessionConnection() == lConnHdl)
                &&(Dcm_NetGetSessionClientSrcAddr() == pTranspObj->ClientSrcAddr) ) /* the owner of the (non-default) session */
              ||(Dcm_NetGetProtObjOfConnection(lConnHdl)->Priority
                < Dcm_NetGetProtObjOfConnection(Dcm_NetGetSessionConnection())->Priority) /* higher priority -> let it through */
              )
#endif
            )
          {
            /* Lock the buffer and allow further request reception */
            pTranspObj->RxData = lBufferInfo->BufferPtr;                                                                                             /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
            Dcm_NetBufferLock(pBufferContext); /* the buffer is in use now */                                                                        /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
            lResult = BUFREQ_OK;
          }
#if (DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
          else
          {
            /* Otherwise, prepare for pseudo request reception (only SID and sub-function will be copied) (if multiple client environment enabled) */
            pTranspObj->RxData = &pTranspObj->AddBuffer[1];                                                                                          /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
            /* no free "real buffer" object - ignore or simulate reception for NRC 0x21 */
            pTranspObj->Flags |= (Dcm_NetTransportObjectFlagType)(DCM_NET_TOBJ_FLAG_BUSY | DCM_NET_TOBJ_FLAG_COPYHEAD | DCM_NET_TOBJ_FLAG_IGNORE);   /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
            lResult = BUFREQ_OK;
          }
#endif
        }
        else
        {
          /* Otherwise, reject the message reception with the result "message too long" */
          lResult = BUFREQ_E_OVFL;
        }

        /* #40 If the message reception is to be continued, register the client connection as active  */
        if(lResult == BUFREQ_OK)
        {
          Dcm_NetRegisterActiveConnection(pTranspObj);                                                                                               /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
        }
        else
        {
          /* Otherwise, release the allocated transport object */
          Dcm_NetTranspObjRelease(pTranspObj);/* no further processing needed */                                                                     /* SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ */
        }
      }/* Otherwise, the transport object is already in use (i.e. parallel request from the same tester):
        *   - reject the message reception if no functional TesterPresent (checked later on) */
    }/* Otherwise, no free transport object found (more clients than transport objects configured, legal use case
      * to save resources) - reject the message reception if no functional TesterPresent (checked later on) */
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    /* Leave critical section */
    Dcm_UtiLeaveCriticalSection();

    if (lResult == BUFREQ_E_NOT_OK)
    {
      uint8 lLengthForTesterPresent = 2u; /* 0x3E 0x80 */

#if (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
      if (Dcm_NetIsGenericConnection(lConnHdl))
      {
        lLengthForTesterPresent += DCM_NET_METADATA_LENGTH;
      }
#endif

      if (Dcm_NetIsKeepAliveRequest(rxPduId, info, lLengthForTesterPresent))                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
      {
        /* functional Tester Present as a parallel request */
        *bufferSizePtr = 2u;                                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
        lResult = BUFREQ_OK;
      }
    }
  } /* Otherwise, reject the message reception */
  return lResult;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6050, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL, MD_MSR_STMIF */
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferExecute()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_PagedBufferExecute(
  Dcm_ContextPtrType pContext,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;                                                                                                          /* PRQA S 2981 */ /* MD_Dcm_RetVal */

  Dcm_UtiResetRuntimeLimiter();

  DCM_UTI_LOOP_FOR_EVER                                                                                                                              /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
  {
    Dcm_DiagSvcUpdateFuncType pUpdateFunc;

    pUpdateFunc = Dcm_DiagGetUpdateFunc(pContext->PagedBuffer.UpdateFuncRef);

    /* Delegate to the page writer */
    lStdResult = pUpdateFunc(pContext
                            ,pContext->PagedBuffer.OpStatus
                            ,pDataContext
                            ,ErrorCode);                                                                                                             /* SBSW_DCM_CALL_FUNCPTR_SVCUPDATERS */

    if(lStdResult != DCM_E_LOOP)
    {
      break;
    }/* else - just loop again */

    pContext->PagedBuffer.OpStatus = DCM_INITIAL;                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */

    if (Dcm_UtiRuntimeLimitReached() == TRUE)
    {
      lStdResult = DCM_E_PENDING_LIMITER;
      break;
    }
  }

  return lStdResult;
}
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferCancel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_PagedBufferCancel(
  Dcm_ContextPtrType pContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lResult = DCM_E_OK;

  /* If page buffer is currently activated: */
  if(pContext->PagedBuffer.State != DCM_PAGEDBUFFER_STATE_INACTIVE)
  {
    /* If not all data was written by the application: */
    if(pContext->PagedBuffer.UpdateFinished == FALSE)
    {
      /* Notify the application about the cancellation */
      Dcm_DiagSvcCancelFuncType lCancelFunc = Dcm_DiagGetCancelFunc(pContext->PagedBuffer.CancelFuncRef);

      lCancelFunc(pContext);                                                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_CALL_FUNCPTR_SVCCANCELLERS */
    }

    /* If no transmission was started yet: */
    if(pContext->PagedBuffer.State == DCM_PAGEDBUFFER_STATE_ACTIVATED)                                                                               /* COV_DCM_RTM_DESIGN_LOWER_LAYER XF */
    {
      /* Send the appropriate NRC by using the linear buffer if needed */
      *ErrorCode = DCM_DIAG_CANCEL_OP_NRC;                                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
      lResult = DCM_E_NOT_OK;
    }

    /* Reset page buffer state */
    Dcm_PagedBufferInitByThread(pContext->ThreadId);
    /* Clear any pending events in the Dcm_PagedBufferTask() to avoid any further processing */
    Dcm_TskClrEventByThread(DCM_TSK_ID_PGDBUF, DCM_TSK_EV_PGDBUF_UPDATE_PAGE, pContext->ThreadId);
  }

  return lResult;
}
#endif /* (DCM_PAGED_BUFFER_ENABLED == STD_ON) */
#if (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateCheckRID()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_StateCheckRID(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  uint16 rid,
  uint8 ridSubfunc,
  Dcm_CfgStateRefOptType stateRef,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdReturn;

  /* Get the precondition package for the related diagnostic entity */
  CONSTP2CONST(Dcm_CfgStateDiagStateInfoType, AUTOMATIC, DCM_CONST) pStatePreconditions = &Dcm_StateGetPreconditionStates(stateRef);

  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* First verify the diagnostic session pre-condition (UDS verification order) */
  if(!Dcm_StateIsSupportedInSession(*pStatePreconditions))                                                                                           /* COV_DCM_RTM_DESIGN_LOWER_LAYER XF */
  {
    /* If not met, return appropriate to UDS NRC for the evaluated diagnostic entity (i.e. NRC 0x7F for services, 0x7E for sub-functions etc.) */
    *ErrorCode = Dcm_StateSessionNrcs[DCM_DIAG_CHK_LVL_PARAMETER];                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
  /* Otherwise, if supported, verify the authentication requirement (UDS verification order) */
# if (DCM_STATE_AUTHENTICATION_ENABLED == STD_ON)
  if(Dcm_AuthMgrCheckRid(pContext, rid, ridSubfunc, stateRef) == DCM_E_NOT_OK)                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
  {
    /* If not met, do return NRC 0x34 */
    *ErrorCode = DCM_E_AUTHENTICATIONREQUIRED;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
# endif
  /* Otherwise, if supported, verify the security access level pre-condition (UDS verification order) */
# if (DCM_STATE_SECURITY_ENABLED == STD_ON)
  if(!Dcm_StateIsSupportedInSecurityLevel(*pStatePreconditions))
  {
    /* If not met, do return NRC 0x33 (UDS) */
    *ErrorCode = DCM_E_SECURITYACCESSDENIED;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
# endif
  {
# if (DCM_MODEMGR_CHECK_SUPPORT_ENABLED == STD_ON)
    /* Otherwise, if supported, get the the mode-related pre-condition expression(s) result */
    lStdReturn = Dcm_ModeCheck(Dcm_CfgStatePreconditions[stateRef].ModeRuleRef, ErrorCode);                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
# else
    /* Otherwise, everything fine - return positive response code */
    lStdReturn = DCM_E_OK;
# endif
  }

  DCM_IGNORE_UNREF_PARAM(rid);                                                                                                                       /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ridSubfunc);                                                                                                                /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return lStdReturn;
}
#endif

/**********************************************************************************************************************
 *  Dcm_StateCheck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_StateCheck(
  Dcm_CfgStateRefOptType stateRef,
  Dcm_DiagCheckLvlType chkLevel,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdReturn;

  /* Get the precondition package for the related diagnostic entity */
  CONSTP2CONST(Dcm_CfgStateDiagStateInfoType, AUTOMATIC, DCM_CONST) pStatePreconditions = &Dcm_StateGetPreconditionStates(stateRef);

  /* First verify the diagnostic session pre-condition (UDS verification order) */
  if(!Dcm_StateIsSupportedInSession(*pStatePreconditions))                                                                                           /* COV_DCM_RTM_DESIGN_LOWER_LAYER XF */
  {
    /* If not met, return appropriate to UDS NRC for the evaluated diagnostic entity (i.e. NRC 0x7F for services, 0x7E for sub-functions etc.) */
    *ErrorCode = Dcm_StateSessionNrcs[chkLevel];                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
  /* Otherwise, if supported, verify the security access level pre-condition (UDS verification order) */
#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
  if(!Dcm_StateIsSupportedInSecurityLevel(*pStatePreconditions))
  {
    /* If not met, do return NRC 0x33 (UDS) */
    *ErrorCode = DCM_E_SECURITYACCESSDENIED;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
#endif
  {
#if (DCM_MODEMGR_CHECK_SUPPORT_ENABLED == STD_ON)
    /* Otherwise, if supported, get the the mode-related pre-condition expression(s) result */
    lStdReturn = Dcm_ModeCheck(Dcm_CfgStatePreconditions[stateRef].ModeRuleRef, ErrorCode);                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
#else
    /* Otherwise, everything fine - return positive response code */
    lStdReturn = DCM_E_OK;
#endif
  }

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_StateSetSession()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_StateSetSession(
  Dcm_StateIndexOptType stateRef
  )
{
  Dcm_CfgStateGroupMemType oldSession;

  oldSession = Dcm_SingletonContext.StateMgr.Preconditions.Session;

  /* Commit the new diagnostic session */
  Dcm_SplitTaskEnterCS();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  Dcm_SingletonContext.StateMgr.Preconditions.Session = Dcm_UtiGetBitFromIndex(Dcm_CfgStateGroupMemType, stateRef);
  Dcm_StateSyncPendingSession();
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_SplitTaskLeaveCS();

  /* Notify application for a diagnostic session transition (also for self-transitions e.g. Default->Default): */
  (void)Rte_Switch_DcmDiagnosticSessionControl_DcmDiagnosticSessionControl(Dcm_CfgStateSessionInfo[stateRef].Mode);

  Dcm_StateExecOnStateChangeFunc(Dcm_CfgStateSessionNotificationInfo, Dcm_StateGetSessionValue(Dcm_UtiGetBitPosition(oldSession)), Dcm_StateGetSessionValue(stateRef)); /* SBSW_DCM_POINTER_FORWARD_GLOBAL */

  /* If the new session is the default one, reset all related internally handled diagnostic jobs (order irrelevant): */
  if(Dcm_StateIsDefaultSessionActive())
  {
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
    if(Dcm_SingletonContext.Network.KeepAlive == FALSE)
#endif
    {
      Dcm_NetUnRegisterAllComMActivity();
    }

#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
    Dcm_Svc2ASchdStopAll();
#endif
#if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
    Dcm_Svc2FReturnControlToEcu();
#endif
#if(DCM_AUTHMGR_DEFAULT_SESSION_TIMEOUT_ENABLED == STD_ON)
    Dcm_AuthMgrDetectIdleConnection(oldSession);
#endif
  }

  /* On any diagnostic session transition (order irrelevant): */
#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
  /* Enable DTCsetting in DEM (if ControlDTCsetting service is not supported in current session) */
  Dcm_Svc85OnChangeSession();
#endif
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
  /* Enable communication abilities of application and NM messages (if CommunicationControl service is not supported in current session) */
  Dcm_Svc28OnChangeSession();
#endif
#if (DCM_SVC_86_RST_ON_DSC_ENABLED == STD_ON)
  /* Notify the diagnostic service 0x86 processor (if diagnostic service 0x86 is handled by DCM) */
  Dcm_ExtSvc86OnChangeSession(oldSession, Dcm_SingletonContext.StateMgr.Preconditions.Session);
#endif

#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
# if (DCM_STATE_SECURITY_BYPASS_ENABLED == STD_ON)
  if(Dcm_SingletonContext.Diag.IsSecurityBypass == FALSE)
# endif
  {
    /* Reset the security access level back to "locked" (if diagnostic service 0x27 is supported by the ECU configuration) */
    Dcm_StateSetSecurity(0);
  }
#else
# if (DCM_STATE_NOTIFY_SVC_PRO_ENABLED == STD_ON)
  /* Notify all service processors that are interested in a state change */
  Dcm_StateNotifyServiceProcessors();
# endif
#endif
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */

#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateSetSecurity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_StateSetSecurity(
  Dcm_StateIndexOptType stateRef
  )
{
  Dcm_CfgStateGroupMemType oldLevel;

  oldLevel = Dcm_SingletonContext.StateMgr.Preconditions.Security;

  /* #10 Commit the new security access level */
  Dcm_SingletonContext.StateMgr.Preconditions.Security = Dcm_UtiGetBitFromIndex(Dcm_CfgStateGroupMemType, stateRef);

  /* #20 Notify application for a security access level transition (only for non-self-transitions e.g. Locked->Level1): */
  if((oldLevel & Dcm_SingletonContext.StateMgr.Preconditions.Security) == 0u) /* consider only non-self transitions (i.e. Locked->Locked) */
  {
    Dcm_SecLevelType               secLev;
# if (DCM_MODE_SECURITY_ACCESS_ENABLED == STD_ON)
    Rte_ModeType_DcmSecurityAccess newMode;

    newMode = (Rte_ModeType_DcmSecurityAccess)((stateRef == 0u)?RTE_MODE_DcmSecurityAccess_LockedLevel
                                                               :Dcm_CfgStateSecurityInfo[stateRef - 1u].Mode);

    /* Notify application */
    (void)Rte_Switch_DcmSecurityAccess_DcmSecurityAccess(newMode);
# endif

    if (oldLevel == (Dcm_UtiMaxValueOfUintType(Dcm_CfgStateGroupMemType) - 1u))  /* Check for transition back from bypass mode */
    {
      secLev = 0;
    }
    else
    {
      secLev = Dcm_UtiGetBitPosition(oldLevel); /* Local variable needed to avoid warnings for side-effects on macro Dcm_StateGetSecurityValue() */
    }
    Dcm_StateExecOnStateChangeFunc(Dcm_CfgStateSecurityNotificationInfo, Dcm_StateGetSecurityValue(secLev), Dcm_StateGetSecurityValue(stateRef));    /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
  }
# if (DCM_STATE_NOTIFY_SVC_PRO_ENABLED == STD_ON)
  /* Notify all service processors that are interested in a state change */
  Dcm_StateNotifyServiceProcessors();
# endif
}
#endif
/**********************************************************************************************************************
 *  Dcm_DiagRcrRpTxFinished()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagRcrRpTxFinished(
  Dcm_NetTransportObjectPtrType pTranspObj,                                                                                                          /* COV_DCM_RTM_NO_RCR_RP_TX */ /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NetTransmissionResultType txStatus
  )
{
  Dcm_ContextPtrType pContext = Dcm_GetThreadContext(Dcm_NetGetThreadIdOfTranspObj(pTranspObj));                                                     /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */

  pContext->Diag.TxStatus = txStatus;/* store current Tx state */                                                                                    /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */

  pTranspObj->ResType = DCM_NET_TOBJ_RESTYPE_NONE;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
  Dcm_UtiBitOpClr(Dcm_NetTransportObjectFlagType, pTranspObj->Flags, DCM_NET_TOBJ_FLAG_RCRRP_ON_TX);                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
  Dcm_UtiBitOpSet(Dcm_NetTransportObjectFlagType, pTranspObj->Flags, DCM_NET_TOBJ_FLAG_RCRRP_SENT);/* mark RCR-RP at least once sent state */        /* SBSW_DCM_PARAM_PTR_WRITE */
  pTranspObj->State   = DCM_NET_TOBJ_STATE_READY;                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */

  Dcm_TskSetEventByThread(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_TX_END_RCRRP, Dcm_NetGetThreadIdOfTranspObj(pTranspObj));  /* Notify for sent RCR_RP */ /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */
}

/**********************************************************************************************************************
 *  Dcm_DiagSetP2Timings()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagSetP2Timings(
  Dcm_StateIndexMemType sesStateIdx,
  Dcm_NetProtRefMemType protocolIdx,
  Dcm_ThreadIdMemType threadId
  )
{
  Dcm_ContextPtrType pContext = Dcm_GetThreadContext(threadId);

  Dcm_UtiEnterCriticalSection();

  /*=================================*
    BEGIN CRITICAL SECTION
    *=================================*/

  /* Calculate the current P2 timings considering the protocol related adjust timings */
  pContext->Diag.P2Timings.P2 = Dcm_DiagGetP2Time(sesStateIdx)
                              - Dcm_NetGetP2AdjTime(protocolIdx);                                                                                    /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */

  pContext->Diag.P2Timings.P2Star = Dcm_DiagGetP2StarTime(sesStateIdx)
                                  - Dcm_NetGetP2StarAdjTime(protocolIdx);                                                                            /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */

  /*=================================*
    END CRITICAL SECTION
    *=================================*/
  Dcm_UtiLeaveCriticalSection();
}

/**********************************************************************************************************************
 *  Dcm_DiagCancelProcessing()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagCancelProcessing(
  Dcm_NetTransportObjectPtrType pTranspObj                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
#if (DCM_MULTI_THREAD_ENABLED == STD_ON)
  Dcm_ContextPtrType pContext = Dcm_GetThreadContext(DCM_THREAD_ID_BASIC);
#endif

  DCM_IGNORE_UNREF_PARAM(pTranspObj);                                                                                                                /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

#if (DCM_MULTI_THREAD_ENABLED == STD_ON)
  if( (Dcm_NetGetThreadIdOfTranspObj(pTranspObj) == DCM_THREAD_ID_BASIC)
    ||((DCM_DIAG_QUEUE_FLAG_IS_WAITING & pContext->Diag.QueuedSet.Flags) == 0u) )
#endif
  {
    Dcm_TmrStopTimerByThread(DCM_TMR_ID_P2, DCM_THREAD_ID_BASIC);
  }

#if (DCM_MULTI_THREAD_ENABLED == STD_ON)
  /* Update diagnostic kernel queue flags: */
  Dcm_UtiEnterCriticalSection();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  Dcm_UtiBitOpSet(Dcm_DiagProcessorFlagType, pContext->Diag.QueuedSet.Flags, DCM_DIAG_QUEUE_FLAG_IS_CANCELING);                                      /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiLeaveCriticalSection();
#endif

  Dcm_TskKillAllTasks();
  Dcm_TskSetEventByThread(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_KILL_JOBS, DCM_THREAD_ID_BASIC);
}

/**********************************************************************************************************************
 *  Dcm_DiagRxIndication()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagRxIndication(
  Dcm_NetTransportObjectPtrType pTranspObj                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_ContextPtrType pContext = Dcm_GetThreadContext(Dcm_NetGetThreadIdOfTranspObj(pTranspObj));                                                     /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */

#if (DCM_DIAG_RST2DEF_ON_FUNC_OBD_REQ_ENABLED == STD_ON)
  /* #10 Handle OBD requests (SID [0x00-0x0F]) when only one diagnostic client is used */
  if ( (pTranspObj->RxData[0] < 0x10u)
# if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
     &&(Dcm_PbCfgNetNumProtocols == 1u)
# endif
     &&((DCM_STATE_VALUE_SESSION_INIT & Dcm_StateGetPendingSession()) == 0u)
     &&(Dcm_PbCfgNetRxPduInfo[pTranspObj->RxPduId].IsFuncReq == TRUE)                                                                                /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
     )
  {
    /* The number of threads is limited to one, so use basic thread here */
    Dcm_TskSetEventByThread(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_INT_SET2DEF, DCM_THREAD_ID_BASIC);
    Dcm_DiagSetP2Timings(0, 0, DCM_THREAD_ID_BASIC);
  }
#endif

  /* #20 Update diagnostic kernel queue flags: */
  Dcm_UtiEnterCriticalSection();
  /*=================================*
    BEGIN CRITICAL SECTION
    *=================================*/
  pContext->Diag.QueuedSet.Flags |= DCM_DIAG_QUEUE_FLAG_IS_WAITING;                                                                                  /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
  /*=================================*
    END CRITICAL SECTION
    *=================================*/
  Dcm_UtiLeaveCriticalSection();

  /* #30 Prepare for new diagnostic request processing by setting all relevant for the real-time task properties: */
  Dcm_DiagSetQueuedTranspObj(pContext, pTranspObj);                                                                                                  /* SBSW_DCM_COMB_PTR_FORWARD */
  Dcm_TmrStartTimerByThread(DCM_TMR_ID_P2, pContext->Diag.P2Timings.P2, Dcm_NetGetThreadIdOfTranspObj(pTranspObj));                                  /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
  Dcm_SingletonContext.Network.KeepAlive = TRUE;
#endif

  /* #40 Signal the Dcm_DiagTaskWorker that the request is now ready for processing */
  Dcm_TskSetEventByThread(DCM_TSK_ID_DIAG_RX, DCM_TSK_EV_DIAG_RX_NEW_REQ, Dcm_NetGetThreadIdOfTranspObj(pTranspObj));                                /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */

/**********************************************************************************************************************
 *  Dcm_DiagTxFinalization()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTxFinalization(
  Dcm_NetTransportObjectPtrType pTranspObj,                                                                                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NetTransmissionResultType txStatus
  )
{
  Dcm_ContextPtrType pContext;

  pContext = Dcm_GetThreadContext(Dcm_NetGetThreadIdOfTranspObj(pTranspObj));                                                                        /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */

  pContext->Diag.TxStatus = txStatus;                                                                                                                /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
  pContext->Diag.State    = DCM_DIAG_STATE_POST_PROCESS;                                                                                             /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */

  Dcm_SplitTaskEnterCS();
  /*=================================*
    BEGIN CRITICAL SECTION
    *=================================*/
  Dcm_UtiBitOpClr(Dcm_DiagProcessorFlagType, pContext->Diag.QueuedSet.Flags, DCM_DIAG_QUEUE_FLAG_IS_ACTIVE);                                         /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
  /*=================================*
    END CRITICAL SECTION
    *=================================*/
  Dcm_SplitTaskLeaveCS();

  if(((DCM_DIAG_APPL_NOTIFICATION_FASTPOSTPROCESSOR)& pContext->Diag.ApplNotification) != 0u)                                                        /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
  {
    Dcm_DiagSvcConfirmationFuncType lFastConfFunc;
    Dcm_ConfirmationStatusType      lConfStatus;

    lFastConfFunc = Dcm_DiagGetPostProcessorFunc(Dcm_CfgDiagServiceInfo[pContext->Diag.SidIndex].FastConfFuncRef);                                   /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
    lConfStatus   = Dcm_DiagGetPostProcessResult(pContext);                                                                                          /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */

    /* Execute any internal service processors fast-post-handlers */
    lFastConfFunc(pContext, lConfStatus);                                                                                                            /* SBSW_DCM_CALL_FUNCPTR_SVCPOSTPROCESSORS */ /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
  }

  /* Release the connection */
  if((DCM_NET_TOBJ_FLAG_CANCELED & pTranspObj->Flags) == 0u) /* let the connection expire with the Tx confirmation (after CancelTransmit) */
  {
    Dcm_NetBufferContextPtrType pBufferContext;

    pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);
    Dcm_NetBufferRelease(pBufferContext); /* the buffer is free now */                                                                               /* PRQA S 3387 */ /* MD_Dcm_OptimizedInlineCode_3387 */ /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
    Dcm_NetUnRegisterActiveConnection(pTranspObj);/* Start the S3 timer if needed here to have maximum real-time accuracy (from communication bus point of view) */ /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  Dcm_TskSetEventByThread(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_TX_END_FINAL, Dcm_NetGetThreadIdOfTranspObj(pTranspObj));                       /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */

#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagOnFblResTxFinished()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagOnFblResTxFinished(
  Dcm_NetTransportObjectPtrType pTranspObj,                                                                                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NetTransmissionResultType txStatus
  )
{
  Dcm_NetBufferContextPtrType pBufferContext;

  pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);

  Dcm_NetBufferRelease(pBufferContext);                                                                                                              /* PRQA S 3387 */ /* MD_Dcm_OptimizedInlineCode_3387 */ /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
  Dcm_NetUnRegisterActiveConnection(pTranspObj);                                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */

  Dcm_SingletonContext.Diag.StartUpFbl.TxStatus = txStatus;
  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_FBLRES, DCM_TSK_EV_DIAG_FBLRES_TXCONF);
}
#endif

#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutFblRes()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutFblRes(
  Dcm_ThreadIdMemType threadId
  )
{
  DCM_IGNORE_UNREF_PARAM(threadId);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_FBLRES, DCM_TSK_EV_DIAG_FBLRES_CANCEL);
  return 0u;
}
#endif

/**********************************************************************************************************************
 *  Dcm_OnTimeoutP2()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutP2(
  Dcm_ThreadIdMemType threadId                                                                                                                       /* COV_DCM_RTM_NO_RCR_RP_TX */
  )
{
  Dcm_TskSetEventByThread(DCM_TSK_ID_DIAG_RX, DCM_TSK_EV_DIAG_RX_TMR_P2_TO, threadId);
  return 0u;
}

/**********************************************************************************************************************
 *  Dcm_OnTimeoutS3()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutS3(
  Dcm_ThreadIdMemType threadId
  )
{
  if(!Dcm_StateIsDefaultSessionActive())
  {
    Dcm_TskSetEventByThread(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_INT_SET2DEF, threadId);
    Dcm_DiagSetP2Timings(0, Dcm_NetGetProtIdOfActiveProtocol(), threadId);

#if (DCM_STATE_AUTHENTICATION_ENABLED == STD_ON)
    {
      Dcm_CfgNetAuthInfoRefMemType lAuthInfoRef = Dcm_NetGetAuthInfoRef(Dcm_NetGetSessionConnection());

      if (lAuthInfoRef != DCM_AUTHMGR_INVALID_AUTH_INFO_REF)
      {
        if (Dcm_AuthMgrAuthenticationState(lAuthInfoRef) == DCM_AUTHENTICATED)
        {
          Dcm_AuthMgrTimerExpireMaskSetBit(lAuthInfoRef);
          Dcm_TskSetEventByThread(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_IDLE_CONN, threadId);
        }
      }
    }
#endif
  }
  return 0u;
}

#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutKeepAlive()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutKeepAlive(
  Dcm_ThreadIdMemType threadId
  )
{
  DCM_IGNORE_UNREF_PARAM(threadId);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if(Dcm_StateIsDefaultSessionActive())                                                                                                              /* COV_DCM_RTM_DEPENDS_ON_CFG */
  {
    Dcm_NetUnRegisterAllComMActivity();
  } /* else - ComM activity will be unregistered by S3 timeout */

  Dcm_SingletonContext.Network.KeepAlive = FALSE;

  return 0u; /* No reload */
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagExecIndicationFunc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagExecIndicationFunc(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_MsgItemType sid,
  Dcm_DiagApplNotificationType notificationType,
  Dcm_CfgDiagNotificationInfoPtrType notifList,
  Dcm_NegativeResponseCodePtrType ErrorCode                                                                                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lResult = DCM_E_OK; /* positive case */
  uint16_least   lIter;

  pContext->Diag.ApplNotification |= notificationType; /* mark application has been notified */                                                      /* SBSW_DCM_PARAM_PTR_WRITE */

  /* Prepare for post processing later */
  pContext->Diag.PostProcessorContext.Sid     = sid;                                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
  pContext->Diag.PostProcessorContext.SrcAddr = Dcm_DiagGetTranspObj(pContext)->ClientSrcAddr;                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
  pContext->Diag.PostProcessorContext.ReqType = (uint8)pContext->Diag.MsgContext.msgAddInfo.reqType;                                                 /* SBSW_DCM_PARAM_PTR_WRITE */

  *ErrorCode = DCM_E_POSITIVERESPONSE;                                                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */

  for(lIter = 0u; notifList[lIter].IndFunc != NULL_PTR; ++lIter)                                                                                     /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
  {
    Std_ReturnType               lStdResult;
    Dcm_NegativeResponseCodeType lNrc = DCM_E_POSITIVERESPONSE; /* Initialize out parameter */

    lStdResult = notifList[lIter].IndFunc(sid
                                         ,pContext->Diag.MsgContext.reqData
                                         ,(uint16)pContext->Diag.MsgContext.reqDataLen
                                         ,(uint8)pContext->Diag.MsgContext.msgAddInfo.reqType
                                         ,pContext->Diag.PostProcessorContext.SrcAddr
                                         ,&lNrc);                                                                                                    /* SBSW_DCM_CALL_FUNCPTR_TERMINATED_LIST */

    if(lStdResult != DCM_E_OK)
    {
      lResult = DCM_E_NOT_OK; /* Mark error, but let other checks to be performed - check for higher priority NOT_ACCEPTED result */

      switch(lStdResult)
      {
      case DCM_E_NOT_OK:
        Dcm_UtiHandleApplNrc(lStdResult, &lNrc, DCM_E_CONDITIONSNOTCORRECT);                                                                         /* SBSW_DCM_POINTER_FORWARD_STACK */
        break;
      case DCM_E_REQUEST_NOT_ACCEPTED:
        lNrc = DCM_E_CONDITIONSNOTCORRECT; /* In DCM_E_REQUEST_NOT_ACCEPTED case no positive response shall be sent! */
        pContext->Diag.DoSuppressResponse = TRUE; /* Try to suppress, but if an RCR-RP has been already sent - send the registered NRC */            /* SBSW_DCM_PARAM_PTR_WRITE */
        break;
      default:
        /* Unexpected return value */
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
        lNrc = DCM_E_PANIC_NRC;
        break;
      }

      /* Try to register NRC if no other has been set! */
      if (*ErrorCode == DCM_E_POSITIVERESPONSE)
      {
        *ErrorCode = lNrc;                                                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
      }
    }
  }

  return lResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_ProcessingDone()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ProcessingDone(
  Dcm_ThreadIdOptType threadId
  )
{
  Dcm_ContextPtrType pContext = Dcm_GetThreadContext(threadId);

  /* If positive response to be sent: */
  if(pContext->Diag.ErrorRegister == DCM_E_POSITIVERESPONSE)
  {
    /* If SPRMIB == TRUE (suppression of positive response): */
    if(pContext->Diag.MsgContext.msgAddInfo.suppressPosResponse != 0u)
    {
      /* Mark no response to be sent */
      pContext->Diag.DoSuppressResponse = TRUE;                                                                                                      /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
    }/* Otherwise - proceed with positive response transmission */
  }
  else /* Otherwise (negative response): */
  {
    /* If functionally requested diagnostic job: */
    if(pContext->Diag.MsgContext.msgAddInfo.reqType != 0u)
    {
      switch(pContext->Diag.ErrorRegister)
      {
        case DCM_E_SERVICENOTSUPPORTED:
        case DCM_E_SUBFUNCTIONNOTSUPPORTED:
        case DCM_E_REQUESTOUTOFRANGE:
#if (DCM_DIAG_SUPPRESS_NRC_7F_7E_ENABLED == STD_ON)
        case DCM_E_SERVICENOTSUPPORTEDINACTIVESESSION:
        case DCM_E_SUBFUNCTIONNOTSUPPORTEDINACTIVESESSION:
#endif
          /* Suppress negative response for certain NRCs only */
          pContext->Diag.DoSuppressResponse = TRUE;                                                                                                  /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
          break;
        default:
          /* Otherwise - proceed with negative response transmission */
          break;
      }
    }/* Otherwise - proceed with negative response transmission */
    /* Update negative response code IdsM events */
    Dcm_DebugReportSecurityEventNRC(threadId, pContext->Diag.ErrorRegister);
  }
  /* Update diagnostic sub-component activity state */
  pContext->Diag.State = DCM_DIAG_STATE_ON_TX;                                                                                                       /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */

  /* Notify the transmission task for linear data response transmission/suppression */
  Dcm_TskSetEventByThread(DCM_TSK_ID_DIAG_TX, DCM_TSK_EV_DIAG_TX_SEND_LINEAR, threadId);
}

/**********************************************************************************************************************
 *  Dcm_SetNegResponse()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_SetNegResponse(
  Dcm_NegativeResponseCodeType nrc,
  Dcm_ThreadIdOptType threadId
  )
{
  Dcm_ContextPtrType pContext = Dcm_GetThreadContext(threadId);

  if(pContext->Diag.ErrorRegister == DCM_E_POSITIVERESPONSE)
  {
    pContext->Diag.ErrorRegister = nrc;                                                                                                              /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
  }
}
/**********************************************************************************************************************
 *  Dcm_DiagLookUpFilter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_DiagLookUpFilter(
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Uint8ConstDataPtrType lookUpTable,
  Dcm_VarRefMemPtrType lookUpFilterTable,
  uint8 value,
  Dcm_DiagCheckLvlType chkLevel,
  Dcm_NegativeResponseCodePtrType errorCode
  )
{
  sint16_least lLookUpResult;

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Check if diagnostic object exists in current variant */
  lLookUpResult = Dcm_DiagVariantLookUpFilter(lookUpTable, lookUpFilterTable, value);                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* If diagnostic object not supported in current variant at all: */
  if(lLookUpResult < 0)
  {
    /* Set appropriate NRC depending on the diagnostic object type */
    *errorCode = Dcm_DiagObjNotFoundNrcs[chkLevel];                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  /* Otherwise if requested SID is not accessible by the client sent it, exit service validation by sending NRC 0x11 */
  else if( (chkLevel == DCM_DIAG_CHK_LVL_SERVICE_ID)
         &&((Dcm_PbCfgDiagSvcId2ProtMap[lLookUpResult] & Dcm_UtiGetBitFromIndex(Dcm_CfgDiagSvc2ProtMapMemType, Dcm_NetGetProtIdOfMsgContext(pMsgContext))) == 0u) )
  {
    lLookUpResult = -1; /* override result */
    *errorCode = DCM_E_SERVICENOTSUPPORTED;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
  {
    /* Otherwise return positive result  */
  }

  return lLookUpResult;
}                                                                                                                                                    /* PRQA S 6060 */ /* MD_MSR_STPAR */

/**********************************************************************************************************************
 *  Dcm_DiagSvcWithSubFuncStateCheck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagSvcWithSubFuncStateCheck(
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_CfgStateRefOptType stateRef,
  Dcm_DiagSubFuncSequenceCheckerFuncType subFuncSequenceChecker,
  Dcm_DiagSubServiceRefOptType subSvcRef,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdReturn;

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(subFuncSequenceChecker);                                                                                                    /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(subSvcRef);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */


  if(!Dcm_StateIsSupportedInSession(Dcm_StateGetPreconditionStates(stateRef)))
  {
    /* If session is not correct, send NRC 0x7E */
    *ErrorCode = DCM_E_SUBFUNCTIONNOTSUPPORTEDINACTIVESESSION;                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
#if (DCM_STATE_AUTHENTICATION_ENABLED == STD_ON)
  if(Dcm_AuthMgrCheckRole(stateRef, Dcm_AuthMgrGetAuthInfoRef(pMsgContext)) == DCM_E_NOT_OK)
  {
    /* If authentication role is not correct, send NRC 0x34 */
    lStdReturn = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_AUTHENTICATIONREQUIRED;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
#endif
  /* If supported, verify the security access level pre-condition (UDS verification order) */
#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
  if(!Dcm_StateIsSupportedInSecurityLevel(Dcm_StateGetPreconditionStates(stateRef)))
  {
    /* If not met, do return NRC 0x33 (UDS) */
    *ErrorCode = DCM_E_SECURITYACCESSDENIED;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
#endif
#if (DCM_DIAG_SF_SEQUENCE_CHECK_SUPPORT_ENABLED == STD_ON)
  if(subFuncSequenceChecker(pMsgContext, subSvcRef, ErrorCode) != DCM_E_OK)                                                                          /* SBSW_DCM_PARAM_FUNCPTR_CALL */
  {
    /* If SF sequence is not correct, ErrorCode already set */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
#endif
  {
#if (DCM_MODEMGR_CHECK_SUPPORT_ENABLED == STD_ON)
    /* Otherwise, if supported, get the the mode-related pre-condition expression(s) result */
    lStdReturn = Dcm_ModeCheck(Dcm_CfgStatePreconditions[stateRef].ModeRuleRef, ErrorCode);                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
#else
    /* Otherwise, everything fine - return positive response code */
    lStdReturn = DCM_E_OK;
#endif
  }

  return lStdReturn;
}
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutSecurityAccess()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutSecurityAccess(
  Dcm_ThreadIdMemType threadId
  )
{
  Dcm_TmrTimerCntrMemType lReloadTick = 0u;
  uint8_least             lTmrIter;
# if (DCM_STATE_SEC_RESET_ATT_CNTR_ON_TIMEOUT_ENABLED == STD_ON)
  uint32_least            lJustExpiredMask = 0u;
# endif

  DCM_IGNORE_UNREF_PARAM(threadId);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* For each software timer: */
  for(lTmrIter = 0; lTmrIter < DCM_SVC_27_NUM_DELAY_TIMERS; ++lTmrIter)
  {
# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
    /* If delay time is set to infinity: */
    if((boolean)(Dcm_Svc27ReloadReadFailedGet(lTmrIter)) == TRUE)                                                                                    /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
    {
      /* Reload forever */
      lReloadTick = 1u;
    }
    else
# endif
    {
      /* Otherwise, if the software timer is active: */
      if(Dcm_Svc27TimerActive(lTmrIter) == TRUE)                                                                                                     /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
      {
        /* Decrement the timer value */
        Dcm_Svc27TimerSet(lTmrIter, (Dcm_TmrTimerCntrMemType)(Dcm_Svc27TimerGet(lTmrIter) - 1u));

        /* If the software timer is still active */
        if(Dcm_Svc27TimerActive(lTmrIter) == TRUE)                                                                                                   /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
        {
          /* Reload the hardware timer */
          lReloadTick = 1u;
        }
# if (DCM_STATE_SEC_RESET_ATT_CNTR_ON_TIMEOUT_ENABLED == STD_ON)
        else
        {
          /* Otherwise, remember the index of the just expired timer */
          lJustExpiredMask |= Dcm_UtiGetBitFromIndex(uint32_least, lTmrIter);
        }
# endif
      }
    }
  }

# if (DCM_STATE_SEC_RESET_ATT_CNTR_ON_TIMEOUT_ENABLED == STD_ON)
  {
    uint8_least lSecLvlIter;

    /* For each security level */
    for(lSecLvlIter = 0; lSecLvlIter < DCM_STATE_SECURITY_NUM_LEVELS; ++lSecLvlIter)
    {
      /* If the corresponding timer of the given security level is just expired */
      if(Dcm_Svc27TimerJustExpired(lJustExpiredMask, lSecLvlIter) == TRUE)                                                                           /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
      {
        /*
         * Reset the corresponding attempt counter of the given security level (if only single counter used, it will
         * be overwritten multiple times and application will be informed for each security level).
         * If multiple counter used, only changed counters will be reset and informed.
         */
#  if (DCM_SVC_27_MULTI_ATTEMPT_COUNTER_ENABLED == STD_ON)
        if(Dcm_Svc27CounterGet(lSecLvlIter) != 0u)
#  endif
        {
          Dcm_Svc27CounterReset(lSecLvlIter);
#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
          Dcm_SingletonContext.Diag.Services.Svc27.SetAttCntrEventMask |= Dcm_UtiGetBitFromIndex(uint32, lSecLvlIter);
#  endif
        }
      }
    }
  }

#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  /* If at least one attempt counter was reset */
  if(Dcm_SingletonContext.Diag.Services.Svc27.SetAttCntrEventMask != 0u)
  {
    /* Notify the application about changed attempt counter values */
    Dcm_TskSetEvent(DCM_TSK_ID_SVC27, DCM_TSK_EV_SVC_27_ATTEMPT_CNTR_WRITE);
  }
#  endif

# endif

  return lReloadTick;
}

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27UtiSetAttemptCntr()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc27UtiSetAttemptCntr(
  Dcm_OpStatusType opStatus,
  P2VAR(uint32, AUTOMATIC, DCM_VAR_NOINIT) levelMask
  )
{
  uint8_least lSecLvlIter;

  /* For each security level: */
  for (lSecLvlIter = 0u; lSecLvlIter < DCM_CFGSVC27SECLEVELINFO_SIZE; ++lSecLvlIter)
  {
    /* If the attempt counter for that specific security level is not already written: */
    if(Dcm_UtiBitOpTest(uint32, *levelMask, Dcm_UtiGetBitFromIndex(uint32, lSecLvlIter)))
    {
      Dcm_CfgSvc27SecLevelInfoPtrType pSecLevelInfo;
      Std_ReturnType                  lResult;
      Dcm_NegativeResponseCodeType    lNrc;

      lResult = Dcm_CfgSvc27SecLevelInfoGetEntry(lSecLvlIter, &pSecLevelInfo, &lNrc);                                                                /* SBSW_DCM_COMB_PTR_FORWARD */

      if (lResult == DCM_E_OK)                                                                                                                       /* COV_DCM_RTM_RUNTIME_CHECK TX */
      {
        /* Notify the application about the new attempt counter value */
        lResult = pSecLevelInfo->SetAttemptCntrFunc(opStatus, Dcm_Svc27CounterGet(lSecLvlIter));                                                     /* SBSW_DCM_CALL_FUNCPTR_SVC27SECLEVEL */

        if (lResult == DCM_E_PENDING)
        {
          /* Otherwise try it later */
        }
        else
        {
          Dcm_DebugAssert(((lResult == DCM_E_OK) || (lResult == DCM_E_NOT_OK)), DCM_SID_SETSECURITYATTEMPTCOUNTER, DCM_E_INTERFACE_RETURN_VALUE);
          /*
           * If the attempt counter was written successfully or an error occurred, don't try to write the attempt
           * counter again.
           */
          Dcm_SplitTaskEnterCS(); /* Avoid interrupt from Dcm_OnTimeoutSecurityAccess */
          /*=================================*
            BEGIN CRITICAL SECTION
           *=================================*/
          Dcm_UtiBitOpClr(uint32                                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
                         ,*levelMask
                         ,Dcm_UtiGetBitFromIndex(uint32, lSecLvlIter));
          /*=================================*
            END CRITICAL SECTION
           *=================================*/
          Dcm_SplitTaskLeaveCS();
        }
      }
    }
  }
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc27ReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc27ReqLengthGetter(
  Dcm_DiagSubServiceRefOptType sfRef
  )
{
  /* Return sub-function specific length */
  return Dcm_CfgSvc27SubFuncInfo[sfRef].ReqLength;
}

/**********************************************************************************************************************
 *  Dcm_Svc27SubFuncSequenceChecker()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc27SubFuncSequenceChecker(
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DiagSubServiceRefOptType subSvcRef,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if((Dcm_Svc27IsKeyRequest(subSvcRef) == TRUE)                                                                                                      /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
    &&(Dcm_Svc27IsThisKeyRequestExpected(Dcm_Svc27GetSecLvlRef(subSvcRef)) == FALSE))                                                                /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
  {
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_REQUESTSEQUENCEERROR;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
  }

  return lStdResult;
}
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_29_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_29_APCE_INTERNAL == STD_ON) || (DCM_SVC_29_04_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29CertificateStoreVerify()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29CertificateStoreVerify(
  uint16 clientCertId,
  uint16 clientCertLength,
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;
  KeyM_CertDataType lClientCertificate;

  /* Create certificate structure from request to be passed on to Key Manager */
  lClientCertificate.certDataLength = (uint32)clientCertLength;
  lClientCertificate.certData = Dcm_UtiGetReqData(pMsgContext);

  /* Store CertId in Dcm_SingletonContext to process when KeyM is finished */
  Dcm_Svc29SetPendingKeyMCertId(clientCertId);

  /* Store certificate on Key Manager and get operation result */
  lStdResult = Dcm_Svc29KeyMSetCertificate(Dcm_Svc29GetPendingKeyMCertId(), &lClientCertificate, ErrorCode);                                         /* SBSW_DCM_COMB_PTR_FORWARD */

  if (lStdResult == DCM_E_OK)
  {
    /* If certificate storage was sucessfull attemp to verify */
    lStdResult = Dcm_Svc29KeyMVerifyCertificate(pContext, Dcm_Svc29GetPendingKeyMCertId(), ErrorCode);                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
  }/* Otherwise, send the already set NRC */

  return lStdResult;
}
# endif

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON) || (DCM_SVC_29_04_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29CertificateVerificationDoneHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29CertificateVerificationDoneHandler(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
                                                                                                                                                      /* Check for callback result of KeyM */
  lStdResult = Dcm_Svc29ValidateKeyMCbkResult(ErrorCode);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */

  if (lStdResult == DCM_E_OK)
  {
    switch (pRepContext->SubSvcId)
    {
#  if (DCM_SVC_29_04_SUPPORT_ENABLED == STD_ON)
      case DCM_SVC29_SUBFUNC_TRANSMIT_CERTIFICATE:
        Dcm_UtiProvideResDataAsU8(pMsgContext, DCM_SVC29_CERTIFICATE_VERIFIED);                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
        break;
#  endif
#  if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
      case DCM_SVC29_SUBFUNC_VERIFY_CERT_UNIDIR:
      case DCM_SVC29_SUBFUNC_VERIFY_CERT_BIDIR:
        /* Provide authenticationReturnParameter with value Ownership Verification Necessary to response buffer */
        Dcm_UtiProvideResDataAsU8(pMsgContext, DCM_SVC29_OWNERSHIP_VERIFICATION_NECESSARY);                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
        /* Generate the server challenge */
        lStdResult = Dcm_Svc29GenerateServerChallenge(pContext, pMsgContext, ErrorCode, pRepContext);                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
        break;
#  endif
      default:                                                                                                                                       /* COV_DCM_RTM_UNREACHABLE X */
        lStdResult = DCM_E_NOT_OK;
        *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);
        break;
    }
  } /* else ErrorCode already set */

  return lStdResult;
}
# endif


# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29GenerateServerChallenge()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29GenerateServerChallenge(
  Dcm_ContextPtrType pContext,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;
  Std_ReturnType lCsmResult;

  Dcm_Svc29SetPendingCsmJobId(Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].RandomJobId);
  Dcm_Svc29SetLengthAsyncCbk(Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].EcuChallengeLength);

  /* Provide size of server challenge in response */
  Dcm_UtiProvideResDataAsU16(pMsgContext, (uint16)Dcm_Svc29GetLengthAsyncCbk());                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */

  lStdResult = Dcm_UtiMsgContextVerifySize(pMsgContext, Dcm_Svc29GetLengthAsyncCbk(), ErrorCode);                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* Check if buffer can hold the server challenge */
  if(lStdResult == DCM_E_OK)                                                                                                                         /* COV_DCM_RTM_RUNTIME_CHECK TX */
  {
    /* Set callback processing state to generate challenge */
    Dcm_Svc29SetCbkProcessingState(DCM_SVC29_CBK_PROC_STATE_GENERATE_CHALLENGE);

    /* Start asynchronous challenge generation */
    lCsmResult = Csm_RandomGenerate(Dcm_Svc29GetPendingCsmJobId()
                                   ,Dcm_UtiGetResData(pMsgContext)
                                   ,&Dcm_Svc29GetLengthAsyncCbk());                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_POINTER_WRITE_MESSAGE_CONTEXT_RESBUFFER */

    if(lCsmResult == DCM_E_OK)
    {
      /* If async job was accepted change progress state */
      Dcm_RepeaterNextStep(pContext, DCM_SVC29_PROGRESS_WAITCHALLENGEGEN);                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_PENDING;
    }
    /* If async job was rejected send NRC and dont loop */
    else if(lCsmResult == CRYPTO_E_BUSY)
    {
      *ErrorCode = DCM_E_BUSYREPEATREQUEST;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
    else
    {
      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    }
  }
  return lStdResult;
}
# endif

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29ChallengeGenerationDoneHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29ChallengeGenerationDoneHandler(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Validate the callback result */
  lStdResult = Dcm_Svc29ValidateCsmCbkResult(ErrorCode);                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* Check if ecu challenge length copied succesfully */
  if(lStdResult == DCM_E_OK)
  {
    /* Check if expected challenge length is generated */
    if(Dcm_DebugDetectRuntimeError(Dcm_Svc29GetLengthAsyncCbk() != Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].EcuChallengeLength))          /* COV_DCM_RTM_RUNTIME_CHECK XF */
    {
      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
    else
    {
      /* Notify message context about server challenge data written from previous async operation */
      Dcm_UtiProvideResData(pMsgContext, Dcm_Svc29GetLengthAsyncCbk());                                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */

      switch(pRepContext->SubSvcId)
      {
#  if (DCM_SVC_29_01_SUPPORT_ENABLED == STD_ON)
        case DCM_SVC29_SUBFUNC_VERIFY_CERT_UNIDIR:
          lStdResult = Dcm_Svc29FinalizeSequenceStartReq(pMsgContext, ErrorCode);                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
          break;
#  endif
#  if (DCM_SVC_29_02_SUPPORT_ENABLED == STD_ON)
        case DCM_SVC29_SUBFUNC_VERIFY_CERT_BIDIR:
          lStdResult = Dcm_Svc29GetServerCertificate(pMsgContext, ErrorCode, pRepContext);                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

          if(lStdResult == DCM_E_OK)
          {
            lStdResult = Dcm_Svc29GenerateSignature(pContext, pMsgContext, ErrorCode, pRepContext);                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
          } /* else ErrorCode already set */
          break;
#  endif
        default:
          *ErrorCode = DCM_E_PANIC_NRC;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
          Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);
          break;
      }
    }
  } /* else ErrorCode already set */

  return lStdResult;
}
# endif

# if (DCM_SVC_29_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29GenerateSignature()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29GenerateSignature(
  Dcm_ContextPtrType pContext,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;
  Std_ReturnType lCsmResult;

  /* Check if response buffer can hold the proof of ownership length field */
  if (pMsgContext->resMaxDataLen > DCM_SVC29_REQ_LENGTH_FIELD_BYTELEN)
  {
    Dcm_Svc29SetPendingCsmJobId(Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].SignClientChallengeJobId);
    /* Provide Csm_SignatureGenerate with all available buffer length (without 2Bytes for the lengthField) */
    Dcm_Svc29SetLengthAsyncCbk((pMsgContext->resMaxDataLen - DCM_SVC29_REQ_LENGTH_FIELD_BYTELEN));

    Dcm_Svc29SetCbkProcessingState(DCM_SVC29_CBK_PROC_STATE_SIGN_CHALLENGE);

    /* Sign client challenge */
    lCsmResult = Csm_SignatureGenerate(Dcm_Svc29GetPendingCsmJobId()
                                      ,CRYPTO_OPERATIONMODE_SINGLECALL
                                      ,Dcm_SingletonContext.Diag.Services.Svc29.ChallengeSwapBuffer
                                      ,(uint32)Dcm_Svc29GetLengthChallengeSwapBuffer()
                                      ,Dcm_UtiGetResDataRel(pMsgContext, DCM_SVC29_REQ_LENGTH_FIELD_BYTELEN)                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
                                      ,&Dcm_Svc29GetLengthAsyncCbk());                                                                               /* SBSW_DCM_COMB_PTR_FORWARD */ /* SBSW_DCM_POINTER_WRITE_MESSAGE_CONTEXT_RESBUFFER */
    if(lCsmResult == E_OK)
    {
      /* If async job was accepted change progress state and keep looping */
      Dcm_RepeaterNextStep(pContext, DCM_SVC29_PROGRESS_SUBFUNC02_WAITCHALLENGESIGNED);                                                              /* SBSW_DCM_PARAM_PTR_FORWARD */
      lStdResult = DCM_E_PENDING;
    }
    /* If async job was rejected send response and dont loop */
    else if(lCsmResult == CRYPTO_E_BUSY)
    {
      *ErrorCode = DCM_E_BUSYREPEATREQUEST;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
    else if(lCsmResult == CRYPTO_E_SMALL_BUFFER)
    {
      *ErrorCode = DCM_E_RESPONSETOOLONG;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
    else
    {
      *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    }
  }
  /* If res buffer is out of space send NRC and stop looping */
  else
  {
    *ErrorCode = DCM_E_RESPONSETOOLONG;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
  }
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_SVC_29_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29_02ChallengeSigningDoneHandler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29_02ChallengeSigningDoneHandler(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_Svc29ValidateCsmCbkResult(ErrorCode);                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* If callback was successful continue processing: */
  if(lStdResult == DCM_E_OK)
  {
    /* Provide server generated signature data length */
    Dcm_UtiProvideResDataAsU16(pMsgContext, (uint16)Dcm_Svc29GetLengthAsyncCbk());                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
    /* Notify message context about server generated signature data written from previous async operation */
    Dcm_UtiProvideResData(pMsgContext, Dcm_Svc29GetLengthAsyncCbk());                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */

    lStdResult = Dcm_Svc29FinalizeSequenceStartReq(pMsgContext, ErrorCode);                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
  } /* else ErrorCode already set */

  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc29ReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc29ReqLengthGetter(
  Dcm_DiagSubServiceRefOptType sfRef
  )
{
  return Dcm_CfgSvc29SubFuncInfo[sfRef].ReqLength;
}

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29_03RoleRead()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29_03RoleRead(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{

  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  lStdResult = Dcm_Svc29ValidateCsmCbkResult(ErrorCode);                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */

  /* If callback was successful continue processing: */
  if(lStdResult == DCM_E_OK)
  {
  /* Verify the verify pointer from the CSM signature verify job */
    if(Dcm_Svc29GetSignatureVerifyResult() == CRYPTO_E_VER_OK)
    {
      /* Read the role from the certificate via KeyM */
      lStdResult = Dcm_AuthMgrGetCertRole(opStatus, ErrorCode, pRepContext);                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */

      /* If role read from certificate was successful */
      if(lStdResult == DCM_E_OK)
      {
        /* Move on to further processing of service 0x29 */
        Dcm_RepeaterNextStep(pContext, DCM_SVC29_PROGRESS_SUBFUNC03_SERVICEWHITELISTREAD);                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
        lStdResult = DCM_E_LOOP;
      }
    }
    else
    {
      /* CSM signature verify job failed, send NRC 0x58 */
      *ErrorCode = DCM_E_OWNERSHIPVERIFICATIONFAILED;                                                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdResult = DCM_E_NOT_OK;
    }
  } /* else ErrorCode already set */

  return lStdResult;
}
# endif

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29_03ServiceWL()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29_03ServiceWL(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

#  if (DCM_AUTHMGR_WHITELIST_SERVICES_ENABLED == STD_ON)
  lStdResult = DCM_E_OK;

  /* If white list supported by tester */
  if(Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].CertWLServicesId != DCM_AUTHMGR_INVALID_WL_KEYM_ELEMENT_ID)
  {
    /* Read elements from Service white list */
    lStdResult = Dcm_AuthMgrServiceWLReadList(pRepContext, ErrorCode);                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  if(lStdResult == DCM_E_OK)
#  else
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
#  endif
  {
    Dcm_RepeaterNextStep(pContext, DCM_SVC29_PROGRESS_SUBFUNC03_DIDWHITELISTREAD);                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP;
  }

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return lStdResult;
}
# endif

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29_03DidWL()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29_03DidWL(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

#  if (DCM_AUTHMGR_WHITELIST_DID_ENABLED == STD_ON)
  lStdResult = DCM_E_OK;

  /* If white list supported by tester */
  if(Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].CertWLDidId != DCM_AUTHMGR_INVALID_WL_KEYM_ELEMENT_ID)
  {
    lStdResult = Dcm_AuthMgrDidWLReadList(pRepContext, ErrorCode);                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  if(lStdResult == DCM_E_OK)
#  else
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
#  endif
  {
    Dcm_RepeaterNextStep(pContext, DCM_SVC29_PROGRESS_SUBFUNC03_RIDWHITELISTREAD);                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP;
  }

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return lStdResult;
}
# endif

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29_03RidWL()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29_03RidWL(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

#  if (DCM_AUTHMGR_WHITELIST_RID_ENABLED == STD_ON)
  lStdResult = DCM_E_OK;

  /* If white list supported by tester */
  if(Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].CertWLRidId != DCM_AUTHMGR_INVALID_WL_KEYM_ELEMENT_ID)
  {
    lStdResult = Dcm_AuthMgrRidWLReadList(pRepContext, ErrorCode);                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  if(lStdResult == DCM_E_OK)
#  else
  DCM_IGNORE_UNREF_PARAM(pRepContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
#  endif
  {
    Dcm_RepeaterNextStep(pContext, DCM_SVC29_PROGRESS_SUBFUNC03_MEMWHITELISTREAD);                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP;
  }

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return lStdResult;
}
# endif

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29_03MemWL()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29_03MemWL(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

#  if (DCM_AUTHMGR_WHITELIST_MEM_ENABLED == STD_ON)
  lStdResult = DCM_E_OK;

  /* If white list supported by tester */
  if (Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].CertWLMemId != DCM_AUTHMGR_INVALID_WL_KEYM_ELEMENT_ID)
  {
    lStdResult = Dcm_AuthMgrMemWLReadList(pRepContext, ErrorCode);                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  if (lStdResult == DCM_E_OK)
#  else
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
#  endif
  {
    /* Set connection state to authenticated */
    pRepContext->ConnContext.AuthState = DCM_AUTHENTICATED;                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */

    /* Provide authenticationReturnParameter with authentication complete */
    Dcm_UtiProvideResDataAsU8(pMsgContext, DCM_SVC29_OWNERSHIP_VERIFIED_AUTHENTICATION_COMPLETE);                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Provide session key info length field */
    Dcm_UtiProvideResDataAsU16(pMsgContext, (uint16)0x00);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Change to next processing state and loop over */
    Dcm_RepeaterNextStep(pContext, DCM_SVC29_PROGRESS_PERSIST_AUTHENTICATION);                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_LOOP;
  }

  return lStdResult;
}
# endif

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29_03PersistAuthentication()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29_03PersistAuthentication(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode,                                                                                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext                                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Std_ReturnType lStdReturn = DCM_E_OK;                                                                                                              /* PRQA S 2981 */ /* MD_Dcm_RetVal */
#  if (DCM_AUTHMGR_PERSIST_STATE_ENABLED == STD_ON)
  Std_ReturnType lModeCheck = DCM_E_OK;
#  endif

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

#  if (DCM_AUTHMGR_PERSIST_STATE_ENABLED == STD_ON)
  if (opStatus == DCM_INITIAL)
  {
    /* Write authentication state to NvM if mode rule is activated. */
    lModeCheck = Dcm_ModeCheck(DCM_MODE_AUTH_PERSIST_STATE_MODERULE_REF, ErrorCode);                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  if (lModeCheck == DCM_E_OK)
  {
    /* Trigger NvM to write the corresponding block */
    lStdReturn = Dcm_UtiNvMWrite(opStatus
                                ,&pRepContext->ConnContext                                                                                           /* PRQA S 0315 */ /* MD_MSR_Dir1.1 */ /* SBSW_DCM_SVC29_NV_ACCESS */
                                ,Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].NvMBlockId);

    if (lStdReturn == DCM_E_NOT_OK)
    {
      /* NvM storage failed */
      *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }

  if (lStdReturn == DCM_E_OK)
#  endif
  {
#  if(DCM_AUTHMGR_WHITELISTS_ENABLED == STD_ON)
    Dcm_AuthMgrWLContextPtrType pConnWLContext;

    lStdReturn = Dcm_AuthMgrGetWLContext(pRepContext->AuthInfoHdl, &pConnWLContext, ErrorCode);                                                      /* SBSW_DCM_COMB_PTR_FORWARD */

    if (lStdReturn == DCM_E_OK)                                                                                                                      /* COV_DCM_RTM_RUNTIME_CHECK TX */
#  endif
    {
#  if(DCM_AUTHMGR_WHITELISTS_ENABLED == STD_ON)
      *pConnWLContext = pRepContext->ConnContext.WLContext;                                                                                          /* SBSW_DCM_POINTER_WRITE_AUTHNVMDATA */
#  endif
      Dcm_AuthMgrUpdateActiveRole(pRepContext->AuthInfoHdl, pRepContext->ConnContext.ActiveRole);
      Dcm_AuthMgrSetAuthentication(pRepContext->AuthInfoHdl, pRepContext->ConnContext.AuthState);

      Dcm_Svc29ResetSequence();

      Dcm_DebugReportSecurityEvent(pMsgContext->threadId, DCM_DEBUG_SEV_AUTHENTICATION_SUCCESSFUL);
    }
  }

  return lStdReturn;
}
# endif

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc29VerifySignature()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29VerifySignature(
  uint16 proofOfOwnershipLength,
  Dcm_ContextPtrType pContext,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;
  Std_ReturnType lCsmResult;

  Dcm_Svc29RepeaterProxyContextConstPtrType pRepContext = &pContext->Repeater.Context.Svc29;

  Dcm_Svc29SetPendingCsmJobId(Dcm_CfgAuthMgrNetConnInfo[pRepContext->AuthInfoHdl].ProofOfOwnershipJobId);

  Dcm_Svc29SetSignatureVerifyResult(CRYPTO_E_VER_NOT_OK);

  /* Set callback processing state to verify signature */
  Dcm_Svc29SetCbkProcessingState(DCM_SVC29_CBK_PROC_STATE_VERIFY_POOW);
  /* Trigger the Csm signature verify job */
  lCsmResult = Csm_SignatureVerify(Dcm_Svc29GetPendingCsmJobId()
                                  ,CRYPTO_OPERATIONMODE_SINGLECALL
                                  ,Dcm_SingletonContext.Diag.Services.Svc29.ChallengeSwapBuffer
                                  ,Dcm_Svc29GetLengthChallengeSwapBuffer()
                                  ,Dcm_UtiGetReqData(pMsgContext)
                                  ,(uint32)proofOfOwnershipLength
                                  ,&Dcm_Svc29GetSignatureVerifyResult());                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_COMB_PTR_FORWARD */

  switch(lCsmResult)
  {
  case E_OK:
    Dcm_RepeaterNextStep(pContext, DCM_SVC29_PROGRESS_SUBFUNC03_WAITSIGVERIFY);                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdResult = DCM_E_PENDING;
    break;
  case CRYPTO_E_BUSY:
    *ErrorCode = DCM_E_BUSYREPEATREQUEST;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  case CRYPTO_E_SMALL_BUFFER:
    *ErrorCode = DCM_E_RESPONSETOOLONG;                                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  case CRYPTO_E_KEY_NOT_VALID:
    *ErrorCode = DCM_E_OWNERSHIPVERIFICATIONFAILED;                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    break;
  default:
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdResult = DCM_E_NOT_OK;
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    break;
  }
  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc29SubFuncSequenceChecker()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc29SubFuncSequenceChecker(
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DiagSubServiceRefOptType subSvcRef,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;

  DCM_IGNORE_UNREF_PARAM(subSvcRef);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if(Dcm_UtiGetReqDataAsU8(pMsgContext) == DCM_SVC29_SUBFUNC_PROOF_OF_OWNERSHIP)                                                                     /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */
  {
    if(Dcm_Svc29IsOwnershipRequestExpected())
    {
      if(Dcm_NetGetConnHdlOfRxPduId(Dcm_Svc29GetRxPduId()) != Dcm_NetGetConnHdlOfRxPduId(pMsgContext->rxPduId))
      {
        /* This causes NRC 0x22 to be sent back */
        lStdResult = DCM_E_NOT_OK;
        *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
      }/* else return DCM_E_OK */
    }
    else
    {
      /* This causes NRC 24 to be sent back. Wrong sequence */
      lStdResult = DCM_E_NOT_OK;
      *ErrorCode = DCM_E_REQUESTSEQUENCEERROR;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }/* else return DCM_E_OK */

  return lStdResult;
}
#endif /* (DCM_SVC_29_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
# if (DCM_TMR_NUM_SVC2A_SCHEDULER > 0u)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutSvc2AScheduler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutSvc2AScheduler(
  Dcm_ThreadIdMemType threadId
  )
{
  Dcm_TmrTimerCntrMemType lReturn = 0;

  DCM_IGNORE_UNREF_PARAM(threadId);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries != 0u)
  {
    boolean doActivateProcessorTask;

    doActivateProcessorTask = Dcm_Svc2ASchdUpdateTimers();

    if(doActivateProcessorTask == TRUE)
    {
      Dcm_TskSetEvent(DCM_TSK_ID_SVC2A_SCHEDULER, DCM_TSK_EV_SVC2A_SCHEDULER_PROCESS);/* at least one job to do */
    }
    lReturn = 1u;/* immediate timeout in next slot */
  }/* else - a NOP activate - will be the last one */
  return lReturn;/* no reload */
}
# endif
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdStopAll()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdStopAll(
  void
  )
{
  if(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries != 0u)
  {
    Dcm_Svc2ASchdItemHandleOptType lSchdIter;

    for(lSchdIter = 0; lSchdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++lSchdIter)
    {
      Dcm_Svc2ASchdStopItemByHandle(lSchdIter);
    }
  }
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdCancelReadByHandle()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdCancelReadByHandle(
  Dcm_Svc2ASchdItemHandleOptType schdHandle
  )
{
  if( (Dcm_RsrcMgrHasDidLock(DCM_RSRCMGR_DIDLOCK_OWNER_SID2A) == TRUE)
    &&(schdHandle == Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.CurrentEntryIndex) )
  {
    Dcm_NegativeResponseCodeType lNrc;/* not evaluated after the API call */
    Dcm_DiagDataContextType      lDataContext;

    Dcm_UtiInitDataContext(&lDataContext
                       ,&Dcm_NetPeriodicMsgGetTxBuffer(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle)[1]
                       ,(Dcm_MsgLenType)(DCM_NET_PERIODIC_BUFFER_SIZE - 1u));                                                                        /* SBSW_DCM_POINTER_INIT_DATA_CONTEXT */

    /* cancel ongoing operation immediately  */
    (void)Dcm_DidMgrReadDid(DCM_CANCEL
                           ,&lDataContext
                           ,&(Dcm_Svc2ASchdGetEntry(schdHandle)->DidContext)
                           ,&(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.DidOpTypeContext)
                           ,&lNrc);                                                                                                                  /* SBSW_DCM_COMB_PTR_FORWARD */

    /* Finish scheduled job */
    Dcm_Svc2ASchdFinishEntryProcessing(FALSE);
  }/* else - nothing to do */
}

# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdCancelReadByDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdCancelReadByDid(
  uint16 did
  )
{
  Dcm_Svc2ASchdItemHandleOptType lSchdHandle = 0u;

  if(Dcm_Svc2ASchdGetItemByDid(did, &lSchdHandle) == TRUE)                                                                                           /* SBSW_DCM_POINTER_FORWARD_STACK */
  {
    Dcm_Svc2ASchdCancelReadByHandle(lSchdHandle);
  }
}
# endif

# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2AGetConnectionOfDID()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Dcm_NetConnRefMemType, DCM_CODE) Dcm_Svc2AGetConnectionOfDID(
  uint16 did
  )
{
  Dcm_NetConnRefMemType lConnHdl = DCM_NET_INVALID_CONNHDL;
  Dcm_Svc2ASchdItemHandleOptType lSchdHandle = 0u;

  if(Dcm_Svc2ASchdGetItemByDid(did, &lSchdHandle) == TRUE)                                                                                           /* SBSW_DCM_POINTER_FORWARD_STACK */
  {
    Dcm_Svc2ASchdEntryConstPtrType pSchdEntry = Dcm_Svc2ASchdGetEntry(lSchdHandle);
    if(pSchdEntry->Rate < DCM_SVC2A_RATE_TYPE_STOPPED)
    {
      lConnHdl = Dcm_NetPeriodicMsgGetConnection();
    }
  }
  return lConnHdl;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdStopItemByHandle()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdStopItemByHandle(
  Dcm_Svc2ASchdItemHandleOptType schdHandle
  )
{
  Dcm_Svc2ASchdEntryPtrType pSchdEntry = Dcm_Svc2ASchdGetEntry(schdHandle);
  if(pSchdEntry->Rate < DCM_SVC2A_RATE_TYPE_STOPPED)
  {
    pSchdEntry->Rate = DCM_SVC2A_RATE_TYPE_STOPPED;                                                                                                  /* SBSW_DCM_POINTER_WRITE_2ASCHEDULERENTRY */
    /* must have at least one element (this one) */
    Dcm_DebugAssert((Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries > 0u)
                   ,DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                                          /* COV_DCM_RTM_DEV_DEBUG XF */

    --Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries; /* update statistic */

    Dcm_Svc2ASchdCancelReadByHandle(schdHandle);

    Dcm_NetPeriodicMsgStopDid(pSchdEntry->DidContext.Did);
    if(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries == 0u)/* scheduler is empty */
    {
      Dcm_NetPeriodicMsgResetConnection(); /* allow other tester to use service 0x2A */
      Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.CurrentEntryIndex = 0u;
# if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
      /* stop timer updater */
      Dcm_TmrStopTimer(DCM_TMR_ID_SVC2A_SCHEDULER);
# else
      /* no need to deactivate the task - if the event was set, the task will deactivate itself after a single short
       * execution time activation */
# endif
    }
  }/* else - this item is not scheduled at all */
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdStopItemByDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdStopItemByDid(
  uint16 did
  )
{
  Dcm_Svc2ASchdItemHandleOptType lSchdHandle = 0u;

  if(Dcm_Svc2ASchdGetItemByDid(did, &lSchdHandle) == TRUE)                                                                                           /* SBSW_DCM_POINTER_FORWARD_STACK */
  {
    Dcm_Svc2ASchdStopItemByHandle(lSchdHandle);
  }
}
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdGetItemByDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(boolean, DCM_CODE) Dcm_Svc2ASchdGetItemByDid(
  uint16 did,
  P2VAR(Dcm_Svc2ASchdItemHandleOptType, AUTOMATIC, AUTOMATIC) schdHandle
  )
{
  boolean lItemFound = FALSE;
  Dcm_Svc2ASchdItemHandleOptType lSchdIter;

  if(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries != 0u)
  {
    for(lSchdIter = 0; lSchdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++lSchdIter)
    {
      Dcm_Svc2ASchdEntryConstPtrType pSchdEntry = Dcm_Svc2ASchdGetEntry(lSchdIter);
      if( (pSchdEntry->Rate < DCM_SVC2A_RATE_TYPE_STOPPED)
        &&(pSchdEntry->DidContext.Did == did) )
      {
        *schdHandle = lSchdIter;                                                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
        lItemFound = TRUE;
        break;
      }
    }
  }
  return lItemFound;
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdFinishEntryProcessing()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdFinishEntryProcessing(
  boolean doSendResponse
  )
{
  Dcm_NetPeriodicTxObjectPtrType pPeriodicTxObj;

  pPeriodicTxObj = Dcm_NetGetPeriodicTxObject(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle);

  if(doSendResponse == TRUE)
  {
    Dcm_Svc2ASchdEntryConstPtrType pSchdEntry =
      Dcm_Svc2ASchdGetEntry(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.CurrentEntryIndex);
    Dcm_NetPeriodicMsgTransmit(pPeriodicTxObj, ((PduLengthType)pSchdEntry->DidContext.DidLength + 1u));                                              /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */
  }
  else
  {
    /* release resource if not used */
    Dcm_NetPeriodicMsgRelease(pPeriodicTxObj);                                                                                                       /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */
  }

  /* free for next DID */
  Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle = DCM_NET_INVALID_PTXOBJ_HANDLE;

  Dcm_RsrcMgrReleaseDidLock(DCM_RSRCMGR_DIDLOCK_OWNER_SID2A);
}
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2ADidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADidLookUp(
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2ARepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdReturn;
  boolean doProcessDid = TRUE;

  if(opStatus == DCM_INITIAL)
  {
    if(pMsgContext->reqDataLen != 0u)
    {
      uint8 perDidLoByte;
      Dcm_UtiConsumeReqDataAsU8(pMsgContext, &perDidLoByte);                                                                                         /* SBSW_DCM_COMB_PTR_FORWARD */

      pRepContext->DidInfoContext.Did = Dcm_Svc2AMakePeriodicDid(perDidLoByte);                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
    {
      doProcessDid = FALSE;
    }
  }

  if(doProcessDid == TRUE)
  {
    lStdReturn = Dcm_DidMgrGetDidInfo(opStatus
                                     ,&(pRepContext->DidInfoContext)
                                     ,&(pRepContext->DidOpTypeContext)
                                     ,DCM_DIDMGR_OP_READ);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
    if(lStdReturn == DCM_E_OK)
    {
      pRepContext->HasAnySupportedDids = TRUE; /* register a supported DID */                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
      /* go on with the DID condition check - DCM_E_OK */
    }
    else if(lStdReturn == DCM_E_PENDING)
    {
      /* already set */
    }
    else
    {
      /* Just skip this DID - DCM_E_NOT_OK - request a new client loop */
      lStdReturn = DCM_E_LOOP;
    }
  }
  else
  {
    /* empty run loop ended without any DID to be processed (for this activation of the repeater proxy) */
    /* all DIDs processed */
    if (pRepContext->HasAnySupportedDids == FALSE)
    {
      *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK;
    }
    else
    {
      lStdReturn = DCM_E_PROCESSINGDONE;
    }
  }

  return lStdReturn;
}
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_2C_03_SUPPORT_ENABLED == STD_ON)                                                                                                       /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrClear()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2CDefMgrClear(
  Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle
  )
{
  Dcm_Svc2CDynDidItemPtrType pItem;

#  if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
  {
    uint16 lDid = Dcm_DidMgrGetDynDidIdFromHandle(dynDidHandle);
    /* Try stopping any active periodic DID (can be still read at that time)! */
    Dcm_Svc2ASchdStopItemByDid(lDid);
  }
#  endif

  pItem = Dcm_Svc2CGetItem(dynDidHandle);
  pItem->Length = 0u;                                                                                                                                /* SBSW_DCM_POINTER_WRITE_2CITEM */
  pItem->Count  = 0u;                                                                                                                                /* SBSW_DCM_POINTER_WRITE_2CITEM */
}
# endif
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CCheckAndSetNumOfItems()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CCheckAndSetNumOfItems(
  Dcm_MsgLenType numRequestedItems,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdReturn;

  if (((Dcm_MsgLenType)Dcm_DidMgrGetDynDidSize(pRepContext->DynDidHandle) - pRepContext->DynDidItemCount) < numRequestedItems)
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
  {
    pRepContext->ReqNumOfItems = (uint8)numRequestedItems;                                                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_OK;
  }

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc2CParseAndCheckDynDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CParseAndCheckDynDid(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode,
  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext
  )
{
  Std_ReturnType lStdReturn;

  if(opStatus == DCM_INITIAL)
  {
    Dcm_UtiConsumeReqDataAsU16(pMsgContext, &pRepContext->DynDidInfoContext.Did);                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  lStdReturn = Dcm_DidMgrGetDidInfo(opStatus
                                   ,&pRepContext->DynDidInfoContext                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
                                   ,&pRepContext->DynDidOpTypeContext                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
                                   ,DCM_DIDMGR_OP_DEFINE);

  switch(lStdReturn)
  {
  case DCM_E_OK:
    lStdReturn = Dcm_StateCheckDID(Dcm_NetGetConnHdlOfRxPduId(pMsgContext->rxPduId)                                                                  /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
                                  ,pRepContext->DynDidInfoContext.Did
                                  ,DCM_DIDMGR_OP_READ
                                  ,Dcm_CfgDidMgrGetDidOpInfo(&(pRepContext->DynDidInfoContext))->ExecCondRef
                                  ,ErrorCode);                                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
    if (lStdReturn == DCM_E_OK)
    {
      Dcm_Svc2CDynDidItemConstPtrType pItem;

      Dcm_Svc2CSetMaxAllowedDynDIDLength(pContext, pRepContext);                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
      pRepContext->DynDidHandle = (Dcm_CfgDidMgrDynDidHandleMemType)Dcm_CfgDidMgrGetDidInfo(&(pRepContext->DynDidInfoContext))->OpRef;               /* SBSW_DCM_PARAM_PTR_WRITE */

      pItem = Dcm_Svc2CGetItem(pRepContext->DynDidHandle);
      pRepContext->DynDidLength = pItem->Length; /* set current length for updates during service processing */                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      pRepContext->SrcItemIndex = Dcm_Svc2CGetSrcItemIndex(pRepContext->DynDidHandle, pItem->Count);                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
      pRepContext->DynDidItemCount = pItem->Count;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */

      Dcm_UtiProvideResData(pMsgContext, 2u); /* positive response contains the DynDID (2Byte) */                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
      /* lStdReturn = DCM_E_OK - already set */
    } /* else DCM_E_NOT_OK (ErrorCode already set) */
    break;
  case DCM_E_PENDING:
    break;
  default: /* DCM_E_NOT_OK */
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
    break;
  }
  return lStdReturn;
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */

/**********************************************************************************************************************
 *  Dcm_Svc2CReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc2CReqLengthGetter(
  Dcm_DiagSubServiceRefOptType sfRef
  )
{
  DCM_IGNORE_UNREF_PARAM(sfRef);                                                                                                                     /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  /* Return sub-function specific length (always zero -> dynamic since it depends on the complete request content) */
  return 0u;
}
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc86ReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc86ReqLengthGetter(
  Dcm_DiagSubServiceRefOptType sfRef
  )
{
  /* Return sub-function specific length */
  return Dcm_CfgSvc86SubFuncInfo[sfRef].ReqLength;
}
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
#include "Dcm_MemMap.h"                                                                                                                              /* PRQA S 5087 */ /* MD_MSR_MemMap */

/**********************************************************************************************************************
 *  GLOBAL FUNCTIONS
 *********************************************************************************************************************/
#define DCM_START_SEC_CODE
#include "Dcm_MemMap.h"                                                                                                                              /* PRQA S 5087 */ /* MD_MSR_MemMap */
#if (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_AUTHMGR_SET_DEAUTH_ROLE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_SetDeauthenticatedRole()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_SetDeauthenticatedRole(
  uint16 connectionId,                                                                                                                               /* PRQA S 1330 */ /* MD_Dcm_RteSpecific_1330 */
  P2CONST(uint8, AUTOMATIC, RTE_DCM_APPL_DATA) deauthenticatedRole                                                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if (Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
  {
    Dcm_NetConnRefMemType lConnHdl;

    lConnHdl = Dcm_NetGetConnHdlByConnectionId(connectionId);

    if (Dcm_DebugDetectError(lConnHdl == DCM_NET_INVALID_CONNHDL))
    {
      lErrorId = DCM_E_PARAM;
    }
    else if (Dcm_DebugDetectError(Dcm_NetGetAuthInfoRef(lConnHdl) == DCM_AUTHMGR_INVALID_AUTH_INFO_REF))
    {
      lErrorId = DCM_E_PARAM;
    }
    else
    {
      /* ----- Implementation ---------------------------------------------- */
      uint8_least               lRoleIndex;
      Dcm_CfgStateGroupMemType  lRoleInLittleEndian = 0x00u;

      for (lRoleIndex = 0; lRoleIndex < DCM_AUTHMGR_CERT_ROLE_SIZE; lRoleIndex++)
      {
        lRoleInLittleEndian |= (Dcm_CfgStateGroupMemType)deauthenticatedRole[lRoleIndex]<<(lRoleIndex * 8u);
      }

      /* Enter critical section (Reason: API is reentrant) */
      Dcm_UtiEnterCriticalSection();
      /*=================================*
      BEGIN CRITICAL SECTION
      *=================================*/
      Dcm_AuthMgrSetPendingRole(Dcm_NetGetAuthInfoRef(lConnHdl), lRoleInLittleEndian);
      Dcm_SingletonContext.AuthMgr.PendingData.ConnectionMask |= Dcm_UtiGetBitFromIndex(uint32, lConnHdl);
      /*=================================*
      END CRITICAL SECTION
      *=================================*/
      Dcm_UtiLeaveCriticalSection();

      Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_EXT_SETROLE);
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_DCMSETDEAUTHENTICATEDROLE, lErrorId);

  return DCM_E_OK;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_AUTHMGR_MEM_CHECK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_AuthMgrCheckMem()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_AuthMgrCheckMem(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_CfgStateRefOptType stateRef,
  uint8 memId
  )
{
  Std_ReturnType lStdResult;

  Dcm_CfgNetAuthInfoRefMemType lAuthInfoRef = Dcm_NetGetAuthInfoRef(Dcm_DiagGetTranspObj(pContext)->ConnHdl);

  /* Check authentication role */
  lStdResult = Dcm_AuthMgrCheckRole(stateRef, lAuthInfoRef);

#  if (DCM_AUTHMGR_WHITELIST_MEM_ENABLED == STD_ON)
  /* Check the MEM whitelist only in authenticated state */
  if((lStdResult == DCM_E_NOT_OK) && (Dcm_AuthMgrAuthenticationState(lAuthInfoRef) == DCM_AUTHENTICATED))
  {
    lStdResult = Dcm_AuthMgrCheckMemWL(memId, lAuthInfoRef);
  }
#  else
  DCM_IGNORE_UNREF_PARAM(memId);                                                                                                                     /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
#  endif

  return lStdResult;
}
# endif
#endif /* (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_VERSION_INFO_API == STD_ON)
/**********************************************************************************************************************
 *  Dcm_GetVersionInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_GetVersionInfo(
  P2VAR(Std_VersionInfoType, AUTOMATIC, DCM_APPL_DATA) versioninfo
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(versioninfo == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    versioninfo->vendorID = (uint16)DCM_VENDOR_ID;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
    versioninfo->moduleID = (uint16)DCM_MODULE_ID;                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
    versioninfo->sw_major_version = (uint8)DCM_SW_MAJOR_VERSION;                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
    versioninfo->sw_minor_version = (uint8)DCM_SW_MINOR_VERSION;                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
    versioninfo->sw_patch_version = (uint8)DCM_SW_PATCH_VERSION;                                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_GETVERSIONINFO, lErrorId);
}
#endif
#if (DCM_NET_COMMCTRL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetSetComControlChannelState()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_NetSetComControlChannelState(
  uint8_least index,
  Dcm_CommunicationModeType value
  )
{
  if (Dcm_DebugDetectRuntimeError(index >= Dcm_PbCfgNetNumAllComMChannels))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
  }
  else
  {
    Dcm_PbRamNetComCtrlChannels[index] = value;                                                                                                      /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_POINTER_WRITE_COMCONTROLCHANNEL */
  }
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_TriggerTransmit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_TriggerTransmit(
  PduIdType txPduId,
  P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) pTxPduInfo
  )
{
  Std_ReturnType lResult  = E_NOT_OK;                                                                                                                /* PRQA S 2981 */ /* MD_Dcm_RetVal */
  uint8          lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_DebugDetectError(Dcm_NetIsTxPduIdValid(txPduId) == FALSE))
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(Dcm_DebugDetectError(pTxPduInfo == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if(Dcm_DebugDetectError(pTxPduInfo->SduDataPtr == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if(Dcm_DebugDetectError(Dcm_NetPeriodicMsgGetConnection() != Dcm_NetGetConnHdlOfTxPduId(txPduId)))
  {
    lErrorId = DCM_E_ILLEGAL_STATE;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_CfgNetPTxObjHandleMemType lPerTxObjHandle;

    lPerTxObjHandle = (Dcm_CfgNetPTxObjHandleMemType)Dcm_NetPeriodicMsgGetHandleFromTxPduId(txPduId);

    if(Dcm_DebugDetectError(Dcm_NetPeriodicMsgNumMsgsCurrConnection() <= lPerTxObjHandle))
    {
      lErrorId = DCM_E_ILLEGAL_STATE;
    }
    else
    {
      P2CONST(PduInfoType, AUTOMATIC, DCM_VAR_NOINIT) txPduInfoPtr = &(Dcm_NetGetPeriodicTxObject(lPerTxObjHandle)->TxPduInfo);

      Dcm_UtiMemCopySafe(txPduInfoPtr->SduDataPtr
                        ,pTxPduInfo->SduDataPtr
                        ,0u
                        ,pTxPduInfo->SduLength
                        ,txPduInfoPtr->SduLength);                                                                                                   /* SBSW_DCM_COMB_PTR_FORWARD */

      pTxPduInfo->SduLength = txPduInfoPtr->SduLength;                                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
      lResult = E_OK;
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_TRIGGERTRANSMIT, lErrorId);

  return lResult;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */
#endif /* (DCM_NET_PERIODIC_TX_ENABLED == STD_ON) */

/**********************************************************************************************************************
 *  Dcm_GetActiveProtocol()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_GetActiveProtocol(
  P2VAR(Dcm_ProtocolType, AUTOMATIC, DCM_APPL_DATA) ActiveProtocol
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_DebugDetectError(ActiveProtocol == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    if(Dcm_NetGetProtIdOfActiveProtocol() >= DCM_NET_INVALID_PROTID)
    {
      *ActiveProtocol = DCM_NO_ACTIVE_PROTOCOL;                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
    }
    else
    {
      *ActiveProtocol = Dcm_PbCfgNetProtocolInfo[Dcm_NetGetProtIdOfActiveProtocol()].Id;                                                             /* PRQA S 2840 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_GETACTIVEPROTOCOL, lErrorId);

  return DCM_E_OK;
}

/**********************************************************************************************************************
 *  Dcm_GetTesterSourceAddress()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_GetTesterSourceAddress(
  PduIdType DcmRxPduId,
  P2VAR(uint16, AUTOMATIC, DCM_APPL_DATA) TesterSourceAddress
  )
{
  Std_ReturnType lResult  = DCM_E_NOT_OK;                                                                                                            /* PRQA S 2981 */ /* MD_Dcm_RetVal */
  uint8          lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_DebugDetectError(Dcm_NetIsRxPduIdValid(DcmRxPduId) == FALSE))
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(Dcm_DebugDetectError(TesterSourceAddress == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
#if (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
  else if(Dcm_DebugDetectError(Dcm_NetIsGenericConnection(Dcm_NetGetConnHdlOfRxPduId(DcmRxPduId))))
  {
    lErrorId = DCM_E_PARAM;
  }
#endif
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    lResult = DCM_E_OK;
    *TesterSourceAddress = Dcm_PbCfgNetConnectionInfo[Dcm_NetGetConnHdlOfRxPduId(DcmRxPduId)].ClientSrcAddr;                                         /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_PARAM_PTR_WRITE */
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_GETTESTERSOURCEADDRESS, lErrorId);

  return lResult;
}

#if (DCM_DIAG_VIRTUAL_REQUEST_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ProcessVirtualRequest()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_ProcessVirtualRequest(
  PduIdType RxPduId,
  Dcm_MsgType Data,
  PduLengthType Length
  )
{
  Std_ReturnType lResult  = DCM_E_NOT_OK;
  uint8          lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_DebugDetectError(Dcm_NetIsRxPduIdValid(RxPduId) == FALSE))
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(Dcm_DebugDetectError(Data == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
  /* if (length > <BufferSize>)
  {
    This check is done through the Dcm_NetRxIndInternal API!
  }
  else */
  {
    /* ----- Implementation ------------------------------------------------ */
    uint16 lClientSrcAddr;

# if (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
    if(Dcm_NetIsGenericConnection(Dcm_NetGetConnHdlOfRxPduId(RxPduId)))
    {
      /* The client source address is stored behind payload data */
      lClientSrcAddr = Data[Length];
    }
    else
# endif
    {
      lClientSrcAddr = Dcm_NetGetTesterAddress(Dcm_NetGetConnHdlOfRxPduId(RxPduId));
    }

    lResult = Dcm_NetRxIndInternal(RxPduId, lClientSrcAddr, Data, Length);                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_PROCESSVIRTUALREQUEST, lErrorId);

  return lResult;
}
#endif

/**********************************************************************************************************************
 *  Dcm_SetActiveDiagnostic()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_SetActiveDiagnostic(
  boolean active
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if (Dcm_DebugDetectError( (active != DCM_NET_COMM_ACTIVE) && (active != DCM_NET_COMM_NOT_ACTIVE) ))
  {
    lErrorId = DCM_E_PARAM;                                                                                                                          /* PRQA S 2880 */ /* MD_MSR_Unreachable */
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    /* Enter critical section (Reason: API is reentrant) */
    Dcm_UtiEnterCriticalSection();
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    /* Apply new ComM management state */
    Dcm_SingletonContext.Network.ActiveDiagnostic = active;
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    /* Leave critical section */
    Dcm_UtiLeaveCriticalSection();
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_SETACTIVEDIAGNOSTIC, lErrorId);

  return DCM_E_OK;
}

/**********************************************************************************************************************
 *  Dcm_GetRequestKind()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_GetRequestKind(
  uint16 TesterSourceAddress,
  P2VAR(Dcm_RequestKindType, AUTOMATIC, DCM_APPL_DATA) RequestKind
  )
{
  Std_ReturnType lResult  = DCM_E_NOT_OK;
  uint8          lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if (Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if (Dcm_DebugDetectError(RequestKind == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_NetConnRefMemType lConnHdl;

    lConnHdl = Dcm_NetGetConnHdlByTesterAddress(TesterSourceAddress);

    /* Check if the tester source address is a valid one */
    if (lConnHdl < DCM_NET_INVALID_CONNHDL)
    {
#if (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
      if (Dcm_DebugDetectError(Dcm_NetIsGenericConnection(lConnHdl)))
      {
        lErrorId = DCM_E_PARAM;
      }
      else
#endif
      {
        Dcm_NetTransportObjectPtrType pTranspObj;
        BufReq_ReturnType             lBufReqResult;

        /* Assure that no interrupt will change the state of the conn2tobj map and the tobj state/flags */
        Dcm_UtiEnterCriticalSection();
        /*=================================*
          BEGIN CRITICAL SECTION
          *=================================*/
        lBufReqResult = Dcm_NetGetTranspObjOfConnection(lConnHdl, &pTranspObj);                                                                      /* SBSW_DCM_POINTER_FORWARD_STACK */

        if (lBufReqResult == BUFREQ_OK)
        {
          /* If for this tester any request is ongoing: */
          if (pTranspObj->State != DCM_NET_TOBJ_STATE_FREE)
          {
#if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
            /* Determine the kind of the request */
            if ((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) != 0u)
            {
              *RequestKind = DCM_REQ_KIND_ROE;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
            }
            else
#endif
            {
              *RequestKind = DCM_REQ_KIND_EXTERNAL;                                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
            }
          }
          else
          {
            /* Otherwise consider this tester idling */
            *RequestKind = DCM_REQ_KIND_NONE;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
          }
        }
        else
        {
          *RequestKind = DCM_REQ_KIND_NONE;                                                                                                          /* SBSW_DCM_PARAM_PTR_WRITE */
        }
        /*=================================*
          END CRITICAL SECTION
          *=================================*/
        Dcm_UtiLeaveCriticalSection();

        lResult = DCM_E_OK;
      }
    } /* else - result already set to NOT_OK */
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_GETREQUESTKIND, lErrorId);

  return lResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_ComM_NoComModeEntered()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_ComM_NoComModeEntered(
  NetworkHandleType networkId
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_NetSetComModeEntered(networkId, DCM_NET_COMM_STATE_RX_DIS_TX_DIS);
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_COMMENTERNOCOMMODE, lErrorId);
}

/**********************************************************************************************************************
 *  Dcm_ComM_SilentComModeEntered()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_ComM_SilentComModeEntered(
  NetworkHandleType networkId
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_NetSetComModeEntered(networkId, DCM_NET_COMM_STATE_RX_EN_TX_DIS);
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_COMMENTERSILENTCOMMODE, lErrorId);
}

/**********************************************************************************************************************
 *  Dcm_ComM_FullComModeEntered()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_ComM_FullComModeEntered(
  NetworkHandleType networkId
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_NetSetComModeEntered(networkId, DCM_NET_COMM_STATE_RX_EN_TX_EN);
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_COMMENTERFULLCOMMODE, lErrorId);
}

#if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnRequestDetection()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_OnRequestDetection(
  PduIdType canTpRxPduId,
  uint8 tpAddrExtension
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  /* Check initialization state */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    /* Check whether the CanTpPduId is between the upper and lower bound of DCM CanTpPduIds */
    if(
# if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
        (Dcm_PbCfgNetNumCanRxPduIds > 0u) &&  /* Check for a non-empty map */
# endif
        ( (canTpRxPduId >= Dcm_PbCfgNetCanTpRxPduIdMin)
        &&(canTpRxPduId <= Dcm_PbCfgNetCanTpRxPduIdMax) )
      )
    {
      PduIdType lDcmRxPduId;

      /* Retrieve the DCM RxPduId from the CanTp PduId */
      lDcmRxPduId = Dcm_NetGetDcmRxPduIdOfCanTpPduId(canTpRxPduId);

      /* Check for DCM connection on this SDU */
      if(lDcmRxPduId < Dcm_PbCfgNetNumRxPduIds)
      {
        Dcm_NetConnRefMemType lConnHdl = Dcm_NetGetConnHdlOfRxPduId(lDcmRxPduId);

        /* Compare the N_TA with the own ECU address. React only on external ECU requests */
        if(Dcm_NetGetNodeAddress(lConnHdl) != tpAddrExtension)
        {
          Dcm_NetOnRequestDetection(lConnHdl);
        }/* else - a DcmPduId and the same N_TA -> request will be ignored on task level */
      }/* else - not a DcmPduId or a functional DcmPduId -> ignore */
    }/* else - not a DcmPduId -> ignore */
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_ONREQUESTDETECTION, lErrorId);
}
#endif

/**********************************************************************************************************************
 *  Dcm_StartOfReception()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(BufReq_ReturnType, DCM_CODE) Dcm_StartOfReception(
  PduIdType rxPduId,
  P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info ,                                                                                                /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  PduLengthType tpSduLength,
  P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) bufferSizePtr
  )
{
  BufReq_ReturnType lResult  = BUFREQ_E_NOT_OK;                                                                                                      /* PRQA S 2981 */ /* MD_Dcm_RetVal */
  uint8             lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_DebugDetectError(Dcm_NetIsRxPduIdValid(rxPduId) == FALSE))
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(Dcm_DebugDetectError(bufferSizePtr == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
#if (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
  /* info is not NULL_PTR when the connection is generic. */
  else if(Dcm_DebugDetectError( (info == NULL_PTR) &&  Dcm_NetIsGenericConnection(Dcm_NetGetConnHdlOfRxPduId(rxPduId)) ))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if (Dcm_DebugDetectError(((info != NULL_PTR) /* info pointer check done again to avoid a Misra justification */
                                && Dcm_NetIsGenericConnection(Dcm_NetGetConnHdlOfRxPduId(rxPduId))
                                && ((info->SduLength < DCM_NET_METADATA_LENGTH)
                                   || ((info->SduLength > DCM_NET_METADATA_LENGTH) && (tpSduLength < (info->SduLength-DCM_NET_METADATA_LENGTH)))
                                   ))))
  {
    lErrorId = DCM_E_PARAM;
  }
#endif
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    lResult = Dcm_NetStartOfReception(rxPduId, info, tpSduLength, bufferSizePtr, DCM_NET_TOBJ_FLAG_NONE);                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_STARTOFRECEPTION, lErrorId);

  return lResult;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_CopyRxData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(BufReq_ReturnType, DCM_CODE) Dcm_CopyRxData(
  PduIdType rxPduId,
  P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info ,                                                                                                /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) bufferSizePtr
  )
{
  BufReq_ReturnType  lResult  = BUFREQ_E_NOT_OK;                                                                                                     /* PRQA S 2981 */ /* MD_Dcm_RetVal */
  uint8              lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_DebugDetectError(Dcm_NetIsRxPduIdValid(rxPduId) == FALSE))
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(Dcm_DebugDetectError(Dcm_NetIsPduInfoValid(info) == FALSE))                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if(Dcm_DebugDetectError(bufferSizePtr == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_NetTransportObjectPtrType pTranspObj;

    lResult = Dcm_NetGetTranspObjOfConnection(Dcm_NetGetConnHdlOfRxPduId(rxPduId), &pTranspObj);                                                     /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_POINTER_FORWARD_STACK */

    DCM_IGNORE_UNREF_PARAM(rxPduId);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

    /* Check always for valid call state - if free or ready -> ignore call
    * This check is necessary in case Dcm_Init is called some time during ongoing transmission and in case of a parallel functional TesterPresent
    */
    if( (lResult == BUFREQ_OK)
      &&(pTranspObj->State == DCM_NET_TOBJ_STATE_ONRX)
      &&(rxPduId == pTranspObj->RxPduId) )
    {
      lResult = Dcm_NetCopyRxData(pTranspObj, info, bufferSizePtr);                                                                                  /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */
    }
    else
    {
      /* Check for valid call state */
      if(Dcm_NetIsKeepAliveRequest(rxPduId, info, 2u))                                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
      {
        *bufferSizePtr = 0u;                                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
        lResult = BUFREQ_OK;
      }
      else
      {
        lErrorId = DCM_E_ILLEGAL_STATE;
      }
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_COPYRXDATA, lErrorId);

  return lResult;
}                                                                                                                                                    /* PRQA S 6030, 6050, 6080 */ /* MD_MSR_STCYC, MD_MSR_STCAL, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_TpRxIndication()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_TpRxIndication(
  PduIdType rxPduId,
  Std_ReturnType result
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_DebugDetectError(Dcm_NetIsRxPduIdValid(rxPduId) == FALSE))
  {
    lErrorId = DCM_E_PARAM;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_NetTpRxIndication(rxPduId, result);
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_TPRXINDICATION, lErrorId);
}

/**********************************************************************************************************************
 *  Dcm_CopyTxData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(BufReq_ReturnType, DCM_CODE) Dcm_CopyTxData(
  PduIdType txPduId,
  P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info ,                                                                                                /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  P2VAR(RetryInfoType, AUTOMATIC, DCM_APPL_DATA) retry ,                                                                                             /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) availableDataPtr
  )
{
  BufReq_ReturnType lResult  = BUFREQ_E_NOT_OK;                                                                                                      /* PRQA S 2981 */ /* MD_Dcm_RetVal */
  uint8             lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_DebugDetectError(Dcm_NetIsTxPduIdValid(txPduId) == FALSE))
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(Dcm_DebugDetectError(Dcm_NetIsPduInfoValid(info) == FALSE))                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if(Dcm_DebugDetectError(availableDataPtr == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if(Dcm_DebugDetectError( (retry != NULL_PTR) /* else - if(retry == NULL_PTR) -> not used => OK */
                              &&(retry->TpDataState != TP_DATACONF) ))
  {
    lErrorId = DCM_E_PARAM;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_NetTransportObjectPtrType pTranspObj;

    lResult = Dcm_NetGetTranspObjOfConnection(Dcm_NetGetConnHdlOfTxPduId(txPduId), &pTranspObj);                                                     /* SBSW_DCM_POINTER_FORWARD_STACK */

    DCM_IGNORE_UNREF_PARAM(txPduId);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
    DCM_IGNORE_UNREF_PARAM(retry);                                                                                                                   /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

    if(lResult == BUFREQ_OK)
    {
      if(Dcm_DebugDetectError(pTranspObj->State != DCM_NET_TOBJ_STATE_ONTX))                                                                         /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY XF */
      {
        lErrorId = DCM_E_ILLEGAL_STATE;
      }
      else
      {
        lResult = Dcm_NetCopyTxData(pTranspObj, info, availableDataPtr);                                                                             /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */
      }
    }
    else
    {
      /* Check for valid call state */
      lErrorId = DCM_E_ILLEGAL_STATE;
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_COPYTXDATA, lErrorId);

  return lResult;
}                                                                                                                                                    /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_TpTxConfirmation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_TpTxConfirmation(
  PduIdType txPduId,
  Std_ReturnType result
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  DCM_IGNORE_UNREF_PARAM(txPduId);                                                                                                                   /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_DebugDetectError(Dcm_NetIsTxPduIdValid(txPduId) == FALSE))
  {
    lErrorId = DCM_E_PARAM;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_NetTransportObjectPtrType pTranspObj;
    BufReq_ReturnType             lResult;

    lResult = Dcm_NetGetTranspObjOfConnection(Dcm_NetGetConnHdlOfTxPduId(txPduId), &pTranspObj);                                                     /* SBSW_DCM_POINTER_FORWARD_STACK */

    if(lResult == BUFREQ_OK)
    {
      if(Dcm_DebugDetectError(pTranspObj->State != DCM_NET_TOBJ_STATE_ONTX))
      {
        lErrorId = DCM_E_ILLEGAL_STATE;
      }
      else
      {
        Dcm_NetUsdtTxConfirmation(pTranspObj, result);                                                                                               /* SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION */
      }
    }
    else
    {
      lErrorId = DCM_E_ILLEGAL_STATE;
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_TPTXCONFIRMATION, lErrorId);
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_TxConfirmation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_TxConfirmation(
  PduIdType txPduId
  )
{
#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
  uint8 lErrorId = DCM_E_NO_ERROR;

  DCM_IGNORE_UNREF_PARAM(txPduId);                                                                                                                   /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_DebugDetectError(Dcm_NetIsTxPduIdValid(txPduId) == FALSE))
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(Dcm_DebugDetectError(Dcm_NetPeriodicMsgGetConnection() != Dcm_NetGetConnHdlOfTxPduId(txPduId)))
  {
    lErrorId = DCM_E_ILLEGAL_STATE;
  }
  else if(Dcm_DebugDetectError(Dcm_NetPeriodicMsgGetHandleFromTxPduId(txPduId) >= Dcm_NetPeriodicMsgNumMsgsCurrConnection()))
  {
    lErrorId = DCM_E_ILLEGAL_STATE;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_NetPeriodicMsgRelease(Dcm_NetGetPeriodicTxObject(Dcm_NetPeriodicMsgGetHandleFromTxPduId(txPduId)));                                          /* SBSW_DCM_POINTER_WRITE_PERTXOBJ */
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_TXCONFIRMATION, lErrorId);
#else
  /* Function is not used since 0x2A or periodic messages are not available.
   * Note: PduR may still need this API to be able to link in case periodic messages are available, but SID 0x2A shall
   * not be supported.
   */
  DCM_IGNORE_UNREF_PARAM(txPduId);                                                                                                                   /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
#endif /* (DCM_NET_PERIODIC_TX_ENABLED == STD_ON) */
}
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferStart()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_PagedBufferStart(
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_MsgLenType resDataLen
  )
{
  Dcm_ContextPtrType pContext = Dcm_GetThreadContext(pMsgContext->threadId);

  /* Once multiple multi frame response started, can not be started again */
  Dcm_DebugAssert((pContext->PagedBuffer.State == DCM_PAGEDBUFFER_STATE_INACTIVE), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                           /* COV_DCM_RTM_DEV_DEBUG XF */
  /* No multiple multi frame response if a NRC has been already registered */
  Dcm_DebugAssert((pContext->Diag.ErrorRegister == DCM_E_OK), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                /* COV_DCM_RTM_DEV_DEBUG XF */

  /*  Initialize paged-buffer response transmission */
  pContext->PagedBuffer.UpdateFuncRef = Dcm_CfgDiagServiceInfo[pContext->Diag.SidIndex].UpdateFuncRef;                                               /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
  pContext->PagedBuffer.CancelFuncRef = Dcm_CfgDiagServiceInfo[pContext->Diag.SidIndex].CancelFuncRef;                                               /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
  pContext->PagedBuffer.BufferHdl = Dcm_DiagGetTranspObj(pContext)->BufferHdl;                                                                       /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
  pContext->PagedBuffer.WriteIndex = (Dcm_CfgNetBufferSizeMemType)(pContext->Diag.MsgContext.resDataLen                                              /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
    + pContext->Diag.MsgContext.resProtHeadLen); /* Write behind SID and the prepared data */
  pContext->PagedBuffer.ReadIndex = 0u;                                                                                                              /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
  pContext->PagedBuffer.RemainingLen = resDataLen; /* Keep track of response data to be copied */                                                    /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
  pContext->PagedBuffer.State = DCM_PAGEDBUFFER_STATE_ACTIVATED;                                                                                     /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
  pContext->PagedBuffer.UpdateFinished = FALSE;                                                                                                      /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
  pContext->PagedBuffer.UpdaterDataProvisionState = DCM_PAGEDBUFFER_WAIT_FOR_DATA;                                                                   /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */
  pContext->PagedBuffer.OpStatus = DCM_INITIAL;                                                                                                      /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */

  /*  Calculate total response length, considering any already linearly written data */
  pContext->Diag.MsgContext.resDataLen += (Dcm_MsgLenType)resDataLen;                                                                                /* SBSW_DCM_POINTER_WRITE_THREADCONTEXT */

  /*  Initiate paged-data reader */
  Dcm_TskSetEventByThread(DCM_TSK_ID_PGDBUF, DCM_TSK_EV_PGDBUF_UPDATE_PAGE, pMsgContext->threadId);
}
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferTask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_PagedBufferTask(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  )
{
  Std_ReturnType               lStdResult;
  Dcm_NetBufferContextPtrType  pBufferContext;
  Dcm_NegativeResponseCodeType lNrc = DCM_E_PANIC_NRC; /* to avoid compiler warnings */

  pBufferContext = Dcm_NetGetBufferContext(pContext->PagedBuffer.BufferHdl);

  Dcm_UtiEnterCriticalSection();
  /*=================================*
    BEGIN CRITICAL SECTION
    *=================================*/
  /* If any diagnostic job is open: */
  if( ((pContext->Diag.State & (DCM_DIAG_STATE_PROCESS | DCM_DIAG_STATE_ON_TX)) != 0u)
    && (!Dcm_NetBufferIsFree(pBufferContext)) )                                                                                                      /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY TX tx tx */
  {
    /* Avoid buffer releasing on asynchronous TxConfirmation with failed status */
    Dcm_NetBufferUsageEnter(pBufferContext);                                                                                                         /* PRQA S 3387 */ /* MD_Dcm_OptimizedInlineCode_3387 */ /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
    /*=================================*
      END CRITICAL SECTION
      *=================================*/
    Dcm_UtiLeaveCriticalSection();

    /* Update paged data */
    lStdResult = Dcm_PagedBufferUpdatePage(pContext, &lNrc);                                                                                         /* SBSW_DCM_POINTER_FORWARD_STACK */

    Dcm_UtiEnterCriticalSection();
    /*=================================*
      BEGIN CRITICAL SECTION
      *=================================*/
    Dcm_NetBufferUsageLeave(pBufferContext);                                                                                                         /* PRQA S 3387 */ /* MD_Dcm_OptimizedInlineCode_3387 */ /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */

    /* If the application needs more time: */
    if(lStdResult == DCM_E_PENDING)
    {
      /* If the paged-buffer was not the last user, try getting data again */
      if(!Dcm_NetBufferIsFree(pBufferContext))                                                                                                       /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY TX */
      {
        Dcm_TskSetLocalEvent(pEventContext->PostEv, DCM_TSK_EV_PGDBUF_UPDATE_PAGE);                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
      }/* else - buffer is free - no more data is to be expected */
    }/* else - that is all */
    /*=================================*
      END CRITICAL SECTION
      *=================================*/
    Dcm_UtiLeaveCriticalSection();

    if (lStdResult == DCM_E_NOT_OK)
    {
      Dcm_SetNegResponse(lNrc, pContext->ThreadId);
      Dcm_ProcessingDone(pContext->ThreadId);
    }
  }
  else
  {
    /*=================================*
    END CRITICAL SECTION
    *=================================*/
    Dcm_UtiLeaveCriticalSection();
  }
}
#endif
/**********************************************************************************************************************
 *  Dcm_StateGetSession()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 */
FUNC(Dcm_CfgStateGroupMemType, DCM_CODE) Dcm_StateGetSession(
  void
  )
{
  return Dcm_SingletonContext.StateMgr.Preconditions.Session;
}

#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateGetSecurity()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 */
FUNC(Dcm_CfgStateGroupMemType, DCM_CODE) Dcm_StateGetSecurity(
  void
  )
{
  return Dcm_SingletonContext.StateMgr.Preconditions.Security;
}
#endif

/**********************************************************************************************************************
 *  Dcm_StateSetPendingSession()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_StateSetPendingSession(
  Dcm_CfgStateGroupMemType session
  )
{
  Dcm_SingletonContext.StateMgr.PendingSession = session;
}

/**********************************************************************************************************************
 *  Dcm_StateGetPendingSession()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 */
FUNC(Dcm_CfgStateGroupMemType, DCM_CODE) Dcm_StateGetPendingSession(
  void
  )
{
  return Dcm_SingletonContext.StateMgr.PendingSession;
}

/**********************************************************************************************************************
 *  Dcm_ResetToDefaultSession()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_ResetToDefaultSession(
  void
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    /* Just register an externally triggered request for changing back to default diagnostic session */
    Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_EXT_SET2DEF);
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_RESET2DEFAULTSESSION, lErrorId);

  return DCM_E_OK;
}

/**********************************************************************************************************************
 *  Dcm_GetSesCtrlType()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_GetSesCtrlType(
  P2VAR(Dcm_SesCtrlType, AUTOMATIC, DCM_APPL_DATA) SesCtrlType
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_DebugDetectError(SesCtrlType == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    /* Return the diagnostic session ID of the currently (still) active (committed not pending) diagnostic session state */
    *SesCtrlType = Dcm_CfgStateSessionInfo[Dcm_UtiGetBitPosition(Dcm_SingletonContext.StateMgr.Preconditions.Session)].Value;                        /* SBSW_DCM_PARAM_PTR_WRITE */
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_GETSESCTRLTYPE, lErrorId);

  return DCM_E_OK;
}

#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_GetSecurityLevel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_GetSecurityLevel(
  P2VAR(Dcm_SecLevelType, AUTOMATIC, DCM_APPL_DATA) SecLevel
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_DebugDetectError(SecLevel == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
# if (DCM_STATE_SECURITY_BYPASS_ENABLED == STD_ON)
  if(Dcm_DebugDetectError(Dcm_SingletonContext.Diag.IsSecurityBypass == TRUE))
  {
    lErrorId = DCM_E_ILLEGAL_STATE;
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    uint8 stateIdx = Dcm_UtiGetBitPosition(Dcm_SingletonContext.StateMgr.Preconditions.Security);
    /* Return the security access level ID of the currently active security access level state */
    *SecLevel = Dcm_StateGetSecurityValue(stateIdx);                                                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_GETSECLEVEL, lErrorId);

  return DCM_E_OK;
}
#endif

#if (DCM_STATE_SECURITY_EXT_SETTER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_SetSecurityLevel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_SetSecurityLevel(
  Dcm_SecLevelType SecLevel
  )
{
  Std_ReturnType lResult  = DCM_E_NOT_OK;
  uint8          lErrorId = DCM_E_NO_ERROR;
  sint8_least    lStateIdx;

  /* Convert security access level to internal zero based security access state handle */
  lStateIdx = Dcm_StateFindStateIndexFromSecLevel(SecLevel);/* Calling this API is safe since it does not depend on any internal DCM state (no initialization is needed!) */

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if (Dcm_DebugDetectError(lStateIdx < 0))
  {
    lErrorId = DCM_E_PARAM;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_StateSetSecurity((Dcm_StateIndexOptType)lStateIdx);

    lResult = DCM_E_OK;
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_SETSECLEVEL, lErrorId);

  return lResult;
}
#endif

#if (DCM_STATE_SECURITY_FIXED_BYTES_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_GetSecurityLevelFixedBytes()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_GetSecurityLevelFixedBytes(
  Dcm_SecLevelType SecLevel,
  P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) FixedBytes,
  P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) BufferSize
  )
{
  Std_ReturnType  lResult  = DCM_E_NOT_OK;
  uint8           lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if (Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if (Dcm_DebugDetectError( (FixedBytes == NULL_PTR) || (BufferSize == NULL_PTR) ))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    lResult = Dcm_StateGetSecurityLevelFixedBytes(SecLevel, FixedBytes, BufferSize);                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_GETSECLEVELFIXEDBYTES, lErrorId);

  return lResult;
}
#endif

#if (DCM_STATE_SECURITY_BYPASS_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_SetSecurityBypass()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_SetSecurityBypass(
  boolean SecBypass
  )
{
  Std_ReturnType lResult  = DCM_E_NOT_OK;
  uint8          lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  /*  Check that the module is initialized. */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  /* Check for valid parameter. */
  else if(Dcm_DebugDetectError((SecBypass != FALSE) && (SecBypass != TRUE)))
  {
    lErrorId = DCM_E_PARAM;                                                                                                                          /* PRQA S 2880 */ /* MD_MSR_Unreachable */
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_SingletonContext.Diag.IsSecurityBypass = SecBypass;

    /* Just register security bypass mode */
    Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_EXT_SETSECBYPASS);
    lResult = DCM_E_OK;
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_SETSECURITYBYPASS, lErrorId);

  return lResult;
}
#endif
/**********************************************************************************************************************
 *  Dcm_InitMemory()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_InitMemory(
  void
  )
{
  Dcm_DebugDeInit();
}

/**********************************************************************************************************************
 *  Dcm_Init()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_Init(
  Dcm_ConfigPtrType configPtr
  )
{
  DCM_IGNORE_UNREF_PARAM(configPtr);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

#if (DCM_VARMGR_SUPPORT_ENABLED == STD_ON)
  if(Dcm_VarMgrInit(configPtr) == TRUE)                                                                                                              /* PRQA S 2991, 2995 */ /* MD_Dcm_ConstExpr, MD_Dcm_ConstExpr */ /* SBSW_DCM_PARAM_PTR_FORWARD */
#endif
  {
    /* Initialize run-time kernel sub-system */
    Dcm_TmrInit();
    Dcm_TskInit();

    /* Initialize communication sub-systems */
    Dcm_NetInit(configPtr);                                                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
    Dcm_PagedBufferInit();
#endif

    /* Initialize diagnostic service helpers sub-systems */
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)
    Dcm_DidMgrInit();                                                                                                                                /* PRQA S 2987 */ /* MD_Dcm_2987 */
#endif
    Dcm_RsrcMgrInit();

    /* Initialize diagnostic state management sub-systems */
#if (DCM_MODE_COMMCTRL_ENABLED == STD_ON) || \
    (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
    Dcm_ModeInit();
#endif
    Dcm_StateInit();
#if (DCM_AUTHMGR_SUPPORT_ENABLED == STD_ON)
    Dcm_AuthMgrInit();                                                                                                                               /* PRQA S 2987 */ /* MD_Dcm_2987 */
#endif

    /* Initialize diagnostic service processing kernel sub-system */
    Dcm_DiagInit(configPtr);                                                                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */

    /* Initialize debug sub-component as last to mark DCM as completely initialized */
    Dcm_DebugInit();/* from now on the DCM is ready to work */
#if (DCM_FBLMGR_SUPPORT_ENABLED == STD_ON)
    Dcm_FblMgrReset();
#endif /* (DCM_FBLMGR_SUPPORT_ENABLED == STD_ON) */
  }
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */

#if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_MainFunctionTimer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_MainFunctionTimer(
  void
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  if(!Dcm_DebugIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
  {
    Dcm_TskScheduler(DCM_TSK_PRIO_HIGH);
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_MAINFUNCTION, lErrorId);
}
#endif

#if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_MainFunctionWorker()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_MainFunctionWorker(
  void
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  if(!Dcm_DebugIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
  {
    Dcm_TskScheduler(DCM_TSK_PRIO_LOW);
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_MAINFUNCTION, lErrorId);
}
#endif

#if (DCM_SPLIT_TASKS_ENABLED == STD_OFF)
/**********************************************************************************************************************
 *  Dcm_MainFunction()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_MainFunction(
  void
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  if(!Dcm_DebugIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
  {
    Dcm_TskScheduler(DCM_TSK_PRIO_NONE);
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_MAINFUNCTION, lErrorId);
}
#endif

/**********************************************************************************************************************
 *  Dcm_GetThreadContext()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Dcm_ContextPtrType, DCM_CODE) Dcm_GetThreadContext(
  Dcm_ThreadIdOptType threadId
  )
{
  Dcm_ContextPtrType pContext;

  if (Dcm_DebugDetectRuntimeError(threadId >= DCM_NUM_THREADS))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    pContext = &Dcm_ThreadContext[0];
  }
  else
  {
    pContext = &Dcm_ThreadContext[threadId];
  }

  return pContext;
}
#if (DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagIsEnabledInActiveVariants()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(boolean, DCM_CODE) Dcm_DiagIsEnabledInActiveVariants(
  Dcm_CfgStateRefOptType cfgVariantRef
  )
{
  return Dcm_VarMgrIsEnabledInActiveVariants(Dcm_PbCfgDiagVariantFilter[cfgVariantRef]);                                                             /* SBSW_DCM_POINTER_FORWARD_GLOBAL */
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagVariantLookUpFilter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(sint16_least, DCM_CODE) Dcm_DiagVariantLookUpFilter(
  Dcm_Uint8ConstDataPtrType lookUpTable,
  Dcm_VarRefMemPtrType lookUpFilterTable,
  uint8 value
  )
{
  sint16_least lLookUpResult = Dcm_UtiLookUpUint8(lookUpTable, value);                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */

  DCM_IGNORE_UNREF_PARAM(lookUpFilterTable);                                                                                                         /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

#if (DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
  if (lLookUpResult >= 0)
  {
    if (Dcm_DiagIsEnabledInActiveVariants(lookUpFilterTable[lLookUpResult]) == FALSE)                                                                /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
    {
      lLookUpResult = -1; /* override result */
    }
  }
#endif

  return lLookUpResult;
}

/**********************************************************************************************************************
 *  Dcm_ExternalProcessingDone()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_ExternalProcessingDone(
  Dcm_MsgContextPtrType pMsgContext                                                                                                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_ProcessingDone(pMsgContext->threadId);
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_EXT_PROCESSINGDONE, lErrorId);
}

/**********************************************************************************************************************
 *  Dcm_ExternalSetNegResponse()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_ExternalSetNegResponse(
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodeType errorCode
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_SetNegResponse(errorCode, pMsgContext->threadId);
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_EXT_SETNEGRESPONSE, lErrorId);
}

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ProvideRecoveryStates()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_ProvideRecoveryStates(
  P2VAR(Dcm_RecoveryInfoType, AUTOMATIC, DCM_APPL_DATA) RecoveryInfo
  )
{
  Std_ReturnType  lResult  = DCM_E_NOT_OK;
  uint8           lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_DebugDetectError(RecoveryInfo == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_DiagProvideRecoveryStates(RecoveryInfo);                                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
    lResult = DCM_E_OK;
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_PROVIDERECOVERYSTATES, lErrorId);

  return lResult;
}
#endif

#if (DCM_DIAG_SPECIFIC_CAUSE_CODE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_SetSpecificCauseCode()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_SetSpecificCauseCode(
  Dcm_SpecificCauseCodeType specificCauseCode
  )
{
  Std_ReturnType lResult  = DCM_E_NOT_OK;
  uint8          lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_DiagSetSpecificCauseCode(specificCauseCode);
    lResult = DCM_E_OK;
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_SETSPECIFICCAUSECODE, lErrorId);

  return lResult;
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagGetDemClientId()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(uint8, DCM_CODE) Dcm_DiagGetDemClientId(Dcm_ReadOnlyMsgContextPtrType pMsgContext)
{
  return (Dcm_NetGetProtObjOfProtId(Dcm_NetGetProtIdOfMsgContext(pMsgContext))->DemClientId);
}

/**********************************************************************************************************************
 *  Dcm_CfgDiagServiceInfoGetEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_CfgDiagServiceInfoGetEntry(
  uint8_least SidIndex,
  CONSTP2VAR(Dcm_CfgDiagServiceInfoPtrType, AUTOMATIC, AUTOMATIC) pServiceInfo,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lResult;

  if (Dcm_DebugDetectRuntimeError(SidIndex >= DCM_CFGDIAGSERVICEINFO_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);

    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_NOT_OK;
  }
  else
  {
    *pServiceInfo = &Dcm_CfgDiagServiceInfo[SidIndex];                                                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
    lResult = DCM_E_OK;
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_DiagGetCancelFunc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Dcm_DiagSvcCancelFuncType, DCM_CODE) Dcm_DiagGetCancelFunc(
  uint8_least index
  )
{
  Dcm_DiagSvcCancelFuncType lResult;

  if(Dcm_DebugDetectRuntimeError(index >= DCM_CFGDIAGSVCCANCELLERS_SIZE))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    lResult = Dcm_CfgDiagSvcCancellers[0];
  }
  else
  {
    lResult = Dcm_CfgDiagSvcCancellers[index];
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_DiagSvcWithOnlySubFuncReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_DiagSvcWithOnlySubFuncReqLengthGetter(
  Dcm_DiagSubServiceRefOptType sfRef
  )
{
  DCM_IGNORE_UNREF_PARAM(sfRef);                                                                                                                     /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return 1u;
}

/**********************************************************************************************************************
 *  Dcm_DiagNoSequenceChecker()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagNoSequenceChecker(
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_DiagSubServiceRefOptType subSvcRef,
  Dcm_NegativeResponseCodePtrType ErrorCode                                                                                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  DCM_IGNORE_UNREF_PARAM(subSvcRef);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return DCM_E_OK;
}

/**********************************************************************************************************************
 *  Dcm_DiagVerifyServiceWithSubFunction()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagVerifyServiceWithSubFunction(
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_Uint8ConstDataPtrType lookUpTable,
  Dcm_VarRefMemPtrType lookUpFilterTable,
  Dcm_DiagServiceLengthGetterFuncType svcLengthGetter,
  Dcm_DiagSubFuncSequenceCheckerFuncType subFuncSequenceChecker,
  Dcm_DiagSubServiceRefOptPtrType pSubSvcRef,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;
  sint16_least   lLookUpResult;
  uint8          sfID = Dcm_UtiGetReqDataAsU8(pMsgContext);                                                                                          /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */

  *pSubSvcRef = 0;                                                                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */

  /* Min Length already checked in DiagDispatcher and expected to be 1 !!! */
  Dcm_DebugAssert((pMsgContext->reqDataLen > 0u), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                            /* COV_DCM_RTM_DEV_DEBUG XF */

  lLookUpResult = Dcm_DiagLookUpFilter(pMsgContext
                                      ,lookUpTable
                                      ,lookUpFilterTable
                                      ,sfID
                                      ,DCM_DIAG_CHK_LVL_SUBFUNC
                                      ,ErrorCode);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lLookUpResult >= 0)
  {
    /* Mark found position in any case if found */
    *pSubSvcRef = (Dcm_DiagSubServiceRefOptType)lLookUpResult;                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */

    /* Check security, sequence, and mode */
    lStdResult = Dcm_DiagSvcWithSubFuncStateCheck(pMsgContext
                                                 ,lookUpFilterTable[lLookUpResult]
                                                 ,subFuncSequenceChecker
                                                 ,*pSubSvcRef
                                                 ,ErrorCode);                                                                                        /* SBSW_DCM_COMB_PTR_FORWARD */


    if(lStdResult == DCM_E_OK)                                                                                                                       /* PRQA S 2991, 2995 */ /* MD_Dcm_ConstExpr, MD_Dcm_ConstExpr */
    {
      Dcm_DiagSubServiceLengthType expectedLength;
      expectedLength = svcLengthGetter(*pSubSvcRef);                                                                                                 /* SBSW_DCM_PARAM_FUNCPTR_CALL */

      if( (expectedLength != 0u) /* dynamic length */
        &&(expectedLength != pMsgContext->reqDataLen) ) /* SF + data */
      {
        *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
        lStdResult = DCM_E_NOT_OK;
      }
    }
    /* Extract SF in any case if supported */
    Dcm_UtiConsumeReqData(pMsgContext, 1u);                                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_UtiProvideResDataAsU8(pMsgContext, sfID);                                                                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */

    Dcm_DiagSetNewReqBaseToCurProgress(pMsgContext);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
    Dcm_DiagSetNewResBaseToCurProgress(pMsgContext);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
  else
  {
    /* else - ErrorCode is already set */
    lStdResult = DCM_E_NOT_OK;
  }
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6050, 6060 */ /* MD_MSR_STCAL, MD_MSR_STPAR */

/**********************************************************************************************************************
 *  Dcm_DiagTaskRx()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_DiagTaskRx(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_NetTransportObjectPtrType pQueuedTObj;

  pQueuedTObj = Dcm_DiagGetQueuedTranspObj(pContext);

  /* If new request received: */
  if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_RX_NEW_REQ))
  {
    /* Initialize related objects */
    pQueuedTObj->State = DCM_NET_TOBJ_STATE_READY;                                                                                                   /* SBSW_DCM_POINTER_WRITE_QUEUEDTOBJ */
    Dcm_DiagResetRcrRpLimiter(pContext);                                                                                                             /* SBSW_DCM_PARAM_PTR_WRITE */
    /* Synchronize with diagnostic job processing task */
    Dcm_TskSetEventByThread(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_NEW_REQ, pContext->ThreadId);
  }

  /* If P2 timeout detected: */
  if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_RX_TMR_P2_TO))
  {
    /* Pre-processing a P2 timeout in oder to cancel the working thread in time (on non-split task configuration) */
#if (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
    /* If RCR-RP limit reached: */
    if(Dcm_DiagGetRcrRpLimiter(pContext) == 0u)
    {
      /* Reset any RCR-RP related states and notify worker task to initiate job cancellation */
      Dcm_DiagRcrRpTxFinished(pQueuedTObj, DCM_E_NOT_OK);                                                                                            /* SBSW_DCM_POINTER_WRITE_QUEUEDTOBJ */

      /*
       * Signal cancellation to the worker. If worker gets interrupted by this high priority task,
       * while already called "processing done", the cancellation signal will be lost and
       * the final response will be sent at next worker task call.
       */
      Dcm_TskSetEventByThread(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_CANCEL_OP, pContext->ThreadId);

      /*
       * Do not send RCR-RP and restart the P2 timer again since the limit has been reached and the worker will
       * finalize the job, once the cancel signal is received.
       */
    }
    else
#endif
    {
#if (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
      /* Otherwise - update RCR-RP limiter */
      Dcm_DiagDecrementRcrRpLimiter(pContext);                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
#endif
      /* Notify diagnostic transmission task to initiate RCR-RP transmission */
      pQueuedTObj->Flags |= DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ;                                                                                          /* SBSW_DCM_POINTER_WRITE_QUEUEDTOBJ */
      Dcm_TskSetEventByThread(DCM_TSK_ID_DIAG_TX, DCM_TSK_EV_DIAG_TX_SEND_RCRRP, pContext->ThreadId);
    }
  }
}

/**********************************************************************************************************************
 *  Dcm_DiagTaskWorker()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_DiagTaskWorker(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  )
{
  /* Important: this event is a synchronization event between high- and low-priority tasks.
   * Never move this event processing into another task than the one that initiates the new request processing (DCM_TSK_EV_DIAG_WORK_NEW_REQ).
   * Otherwise the clean-up jobs from DCM_TSK_EV_DIAG_WORK_KILL_JOBS event may be performed AFTER the new request processing has been started.
   * This will lead to out of sync of services post- and main-processing!
  */
  if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_KILL_JOBS))
  {
    Dcm_DiagWorkerDoCancelProcessing(pContext, pEventContext);                                                                                       /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_TX_END_FINAL))
  {
    Dcm_DiagWorkerDoPostProcessing(pContext);                                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_EXT_SET2DEF))
  {
    Dcm_DiagWorkerSetDefSessionExtern(pContext, pEventContext);                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_INT_SET2DEF))
  {
    Dcm_StateSetSession(0);
  }

#if (DCM_STATE_AUTHENTICATION_ENABLED == STD_ON)
  if (Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_IDLE_CONN))
  {
    Dcm_AuthMgrDeauthenticateIdleConn();
  }
#endif

#if (DCM_AUTHMGR_SET_DEAUTH_ROLE_ENABLED == STD_ON)
  if (Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_EXT_SETROLE))
  {
    Dcm_AuthMgrSetDeauthenticatedRole(pContext, pEventContext);                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
#endif

#if (DCM_STATE_SECURITY_BYPASS_ENABLED == STD_ON)
  if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_EXT_SETSECBYPASS))
  {
    Dcm_DiagWorkerSetSecurityBypass(pContext, pEventContext);                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
#endif

  if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_NEW_REQ))
  {
    Dcm_DiagWorkerProcessNewRequest(pContext, pEventContext);                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_TX_END_RCRRP))
  {
    Dcm_DiagWorkerProcessRcrRpTxEnd(pContext, pEventContext);                                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON) && \
    (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
  if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_CANCEL_OP))
  {
    Dcm_DiagWorkerCancelOperation(pContext, pEventContext);                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
#endif

  if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_WORK_REPEAT))
  {
    Dcm_DiagWorkerDoRepeat(pContext, pEventContext);                                                                                                 /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
}                                                                                                                                                    /* PRQA S 6010, 6050 */ /* MD_MSR_STPTH, MD_MSR_STCAL */

/**********************************************************************************************************************
 *  Dcm_DiagTaskTx()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_DiagTaskTx(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  )
{
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
  if (Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_TX_SEND_PAGED))
  {
    Dcm_DiagTxPostponeFinalPagedResponse(pContext, pEventContext);                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
#endif

  if (Dcm_TskIsLocalEventSet(pEventContext->Ev, (DCM_TSK_EV_DIAG_TX_SEND_PAGED | DCM_TSK_EV_DIAG_TX_SEND_LINEAR)))
  {
    Dcm_DiagTxStartFinalResponse(pContext, pEventContext);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  if (Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_TX_SEND_RCRRP))
  {
    Dcm_DiagTxStartRcrRpResponse(pContext);                                                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
}

#if (DCM_TSK_NUM_DIAG_RECOVERY > 0u)
/**********************************************************************************************************************
 *  Dcm_DiagTaskRecovery()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_DiagTaskRecovery(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext
  )
{
  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if (Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_RECOVERY_GETSTATE))
  {
    Std_ReturnType lResult;

    /* Retrieve the recovery information from the application */
    lResult = Dcm_GetRecoveryStates(&Dcm_SingletonContext.Recovery.RecoveryInfo);                                                                    /* SBSW_DCM_POINTER_FORWARD_GLOBAL */

    switch(lResult)
    {
    case DCM_E_OK:
      Dcm_TskSetLocalEvent(pEventContext->Ev, DCM_TSK_EV_DIAG_RECOVERY_PROCESS);                                                                     /* SBSW_DCM_PARAM_PTR_WRITE */
      Dcm_SingletonContext.Recovery.OpStatus = DCM_INITIAL;
      break;
    case DCM_E_PENDING:
      /* Retry next time */
      Dcm_TskSetLocalEvent(pEventContext->PostEv, DCM_TSK_EV_DIAG_RECOVERY_GETSTATE);                                                                /* SBSW_DCM_PARAM_PTR_WRITE */
      break;
    default:
      Dcm_DebugAssert((lResult == DCM_E_NOT_OK), DCM_SID_GETRECOVERYSTATES, DCM_E_INTERFACE_RETURN_VALUE);                                           /* COV_DCM_RTM_DEV_DEBUG XF */
      /* Abort recovering */
      Dcm_TskSetLocalEvent(pEventContext->Ev, DCM_TSK_EV_DIAG_RECOVERY_FINISH);                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      break;
    }
  }

  if (Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_RECOVERY_PROCESS))
  {
    Std_ReturnType   lResult;
    lResult = Dcm_DiagSafeProcessRecoveryInfo(&Dcm_SingletonContext.Recovery.RecoveryInfo
                                             ,Dcm_SingletonContext.Recovery.OpStatus);                                                               /* SBSW_DCM_POINTER_FORWARD_GLOBAL */

    switch(lResult)
    {
    case DCM_E_OK:
      Dcm_TskSetLocalEvent(pEventContext->Ev, DCM_TSK_EV_DIAG_RECOVERY_FINISH);                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      break;
    case DCM_E_PENDING:
      /* Retry next time */
      Dcm_SingletonContext.Recovery.OpStatus = DCM_PENDING;
      Dcm_TskSetLocalEvent(pEventContext->PostEv, DCM_TSK_EV_DIAG_RECOVERY_PROCESS);                                                                 /* SBSW_DCM_PARAM_PTR_WRITE */
      break;
    default: /* DCM_E_NOT_OK */
      /* Abort recovering */
      Dcm_TskSetLocalEvent(pEventContext->Ev, DCM_TSK_EV_DIAG_RECOVERY_FINISH);                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      break;
    }
  }

  if (Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_RECOVERY_FINISH))
  {
# if (DCM_DIDMGR_DYNDID_CLR_ON_STATE_CHG_ENABLED == STD_ON) && \
     (DCM_SVC_2C_NVRAM_SUPPORT_ENABLED == STD_ON)
    Dcm_Svc2COnStateChanged();
# endif
    Dcm_SingletonContext.Network.RxAllowed = TRUE;
  }
}
#endif

#if (DCM_TSK_NUM_DIAG_GARB_COL > 0u)
/**********************************************************************************************************************
 *  Dcm_DiagTaskGarbageCollector()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_DiagTaskGarbageCollector(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_TskTaskEvOptType        lEv = pEventContext->Ev;
  Dcm_CfgNetTObjHandleOptType lTObjCntr;

  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Cleanup or reject all transport objects that never succeeded and are now canceled */
  lTObjCntr = 0;
  DCM_TSK_EVENT_SCAN_LOOP(lEv)
  {
    /* Check who shall be removed */
    if (Dcm_TskIsLocalEventSet(lEv, 0x01u))
    {
      Dcm_NetTransportObjectPtrType pTranspObj;

      pTranspObj = Dcm_NetGetTransportObject(lTObjCntr);
      /* Always unregister ComM activity here, since CANCELED flag will not clean it up!
       * If no RCR-RP on transmission: everything has to be cleaned up here!
       */
      Dcm_NetUnRegisterComMActivity(pTranspObj->ConnHdl);

      /* If just requested, then only this TObject could be the trigger for P2 timer - avoid any RCR-RP transmission */
      if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ) != 0u)
      {
        Dcm_TskClrEventByThread(DCM_TSK_ID_DIAG_TX, DCM_TSK_EV_DIAG_TX_SEND_RCRRP, Dcm_NetGetThreadIdOfTranspObj(pTranspObj));
      }

      Dcm_UtiEnterCriticalSection();
      /*=================================*
       BEGIN CRITICAL SECTION
       *=================================*/
      /* Check if any RCR-RP for this object is on Tx (DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ is excluded since the high-prio
       * Dcm_DiagTaskTx() shall already have switched to ON_TX!) */
      if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_RCRRP_ON_TX) != 0u)
      {
        pTranspObj->Flags |= DCM_NET_TOBJ_FLAG_CANCELED; /* isolate this connection */                                                               /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */

        /* Try cancel any ongoing response. The return value does not matter:
         * OK -> there will be a confirmation for this cancellation
         * N_OK -> request rejected, but there will be a confirmation due to the ongoing transmission
         */
        (void)PduR_DcmCancelTransmit(Dcm_PbCfgNetConnectionInfo[pTranspObj->ConnHdl].TxPduIdMain);
        /* Any RCR-RP will just end with releasing the connection assigned to the tObject!
         * No confirmation post-processing will be performed! */
      }
      else
      {
        Dcm_NetBufferContextPtrType pBufferContext;

        pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);
        Dcm_NetBufferRelease(pBufferContext); /* the buffer is free now */                                                                           /* PRQA S 3387 */ /* MD_Dcm_OptimizedInlineCode_3387 */ /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
        Dcm_NetUnRegisterActiveConnection(pTranspObj); /* no further processing needed */                                                            /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      }
      /*=================================*
       END CRITICAL SECTION
       *=================================*/
      Dcm_UtiLeaveCriticalSection();
    }
    ++lTObjCntr;
  }
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0u)
/**********************************************************************************************************************
 *  Dcm_DiagTaskFblRes()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_DiagTaskFblRes(
  Dcm_ContextPtrType pContext,
  Dcm_TskEventContextPtrType pEventContext
  )
{
  /* Check for eventual FBL final response request */
  if (Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_FBLRES_SEND))
  {
    Dcm_DiagFblResDoGetProgCond(pContext, pEventContext);                                                                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* If final response required, wait for ComM before sending the response */
  if (Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_FBLRES_WAITTXCOMM))
  {
    Dcm_DiagFblResDoWaitTxComm(pContext, pEventContext);                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* Once final FBL response request processed, reset all flags to prevent from a new response at next power-on/reset */
  if (Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_FBLRES_RSTFLAGS))
  {
    Dcm_DiagFblResDoResetFlags(pContext, pEventContext);                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* If any FBL final response confirmation received, do the designated job (e.g. session transition) */
  if (Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_DIAG_FBLRES_TXCONF))
  {
    Dcm_DiagFblResDoProcessTxConfirmation(pContext, pEventContext);                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
}
#endif
#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VsgSetSingle()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_VsgSetSingle(
  Dcm_VsgIdentifierType VsgId,
  Dcm_VsgStateType State
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  uint8          lErrorId   = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if (Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if (Dcm_DebugDetectError( (VsgId >= DCM_VARMGR_NUM_CFG_VARIANTS)
                               ||(VsgId == 0u) ))
  {
    lErrorId = DCM_E_PARAM;
  }
  else if (Dcm_DebugDetectError( (State != DCM_VSG_ENABLED)
                               &&(State != DCM_VSG_DISABLED) ))
  {
    lErrorId = DCM_E_PARAM;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    lStdResult = DCM_E_OK;

    Dcm_VarMgrVsgSetSingle(VsgId, State);
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_VSGSETSINGLE, lErrorId);

  return lStdResult;
}
#endif

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VsgIsActive()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_VsgIsActive(
  Dcm_VsgIdentifierType VsgId,
  P2VAR(Dcm_VsgStateType, AUTOMATIC, DCM_APPL_DATA) State
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  uint8          lErrorId   = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ------------------------------------- */
  if (Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if (Dcm_DebugDetectError( (VsgId >= DCM_VARMGR_NUM_CFG_VARIANTS)
                               ||(VsgId == 0u) ))
  {
    lErrorId = DCM_E_PARAM;
  }
  else if (Dcm_DebugDetectError(State == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    lStdResult = DCM_E_OK;

    Dcm_VarMgrVsgIsActive(VsgId, State);                                                                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_VSGISACTIVE, lErrorId);

  return lStdResult;
}
#endif

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VsgSetMultiple()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_VsgSetMultiple(
  P2CONST(Dcm_VsgIdentifierType, AUTOMATIC, DCM_APPL_DATA) VsgIdList,
  uint16 VsgListSize,
  Dcm_VsgStateType State
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  uint8          lErrorId   = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if (Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if (Dcm_DebugDetectError(VsgIdList == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if (Dcm_DebugDetectError( (VsgListSize > DCM_VARMGR_NUM_CFG_VARIANTS)
                               ||(VsgListSize == 0u) ))
  {
    lErrorId = DCM_E_PARAM;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_VsgIdentifierType lVsgIter;

    /* Iterate over all passed VSGs */
    for (lVsgIter = 0; lVsgIter < VsgListSize; ++lVsgIter)
    {
      lStdResult = Dcm_VsgSetSingle(VsgIdList[lVsgIter], State);

      if(lStdResult == DCM_E_NOT_OK)
      {
        break;
      }
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_VSGSETMULTIPLE, lErrorId);

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VsgIsActiveAnyOf()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_VsgIsActiveAnyOf(
  P2CONST(Dcm_VsgIdentifierType, AUTOMATIC, DCM_APPL_DATA) VsgIdList,
  uint16 VsgListSize,
  P2VAR(Dcm_VsgStateType, AUTOMATIC, DCM_APPL_DATA) State
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  uint8          lErrorId   = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if (Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if (Dcm_DebugDetectError(VsgIdList == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if (Dcm_DebugDetectError( (VsgListSize > DCM_VARMGR_NUM_CFG_VARIANTS)
                               ||(VsgListSize == 0u) ))
  {
    lErrorId = DCM_E_PARAM;
  }
  else if (Dcm_DebugDetectError(State == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_VsgIdentifierType lVsgIter;

    /* Iterate over all passed VSGs */
    for (lVsgIter = 0; lVsgIter < VsgListSize; ++lVsgIter)
    {
      lStdResult = Dcm_VsgIsActive(VsgIdList[lVsgIter], State);                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */

      if( (lStdResult == DCM_E_NOT_OK)
        ||(*State == DCM_VSG_ENABLED) )
      {
        break;
      }
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_VSGISACTIVEANY, lErrorId);

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif
#if (DCM_SVC_29_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_29_APCE_INTERNAL == STD_ON) || (DCM_SVC_29_04_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_KeyMAsyncCertificateVerifyFinished()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_KeyMAsyncCertificateVerifyFinished(
  KeyM_CertificateIdType CertId,
  KeyM_CertificateStatusType Result
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_DebugDetectError(Dcm_Svc29GetPendingKeyMCertId() != CertId))
  {
    lErrorId = DCM_E_PARAM;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_UtiEnterCriticalSection();
    /*=================================*
    BEGIN CRITICAL SECTION
    *=================================*/
    if(Dcm_Svc29IsAsyncKeyMJobActive())
    {
      Dcm_SingletonContext.Diag.Services.Svc29.KeyMCbkResult = Result;
      Dcm_Svc29SetNextCbkProcessingState();
    }
    else if(Dcm_Svc29IsCbkStateActive(DCM_SVC29_CBK_PROC_STATE_KEYM_CANCELLED))
    {
      /* Reset callback processing state */
      Dcm_Svc29SetCbkProcessingState(DCM_SVC29_CBK_PROC_STATE_IDLE);
    }
    else
    {
      /* Callback is not expected */
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);
    }
    /*=================================*
    END CRITICAL SECTION
    *=================================*/
    Dcm_UtiLeaveCriticalSection();
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_KEYMASYNCCERTIFICATEVERIFYFINISHED, lErrorId);
  return DCM_E_OK;
}
# endif

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
/**********************************************************************************************************************
 *  Dcm_CsmAsyncJobFinished()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_CsmAsyncJobFinished(
  P2CONST(Crypto_JobType, AUTOMATIC, DCM_APPL_DATA) job,
  Crypto_ResultType result
  )
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(!Dcm_DebugIsModuleInitialized()))
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Dcm_DebugDetectError(Dcm_Svc29GetPendingCsmJobId() != job->jobId))
  {
    lErrorId = DCM_E_PARAM;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    Dcm_UtiEnterCriticalSection();
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/
    switch(Dcm_Svc29GetCbkProcessingState())
    {
    case DCM_SVC29_CBK_PROC_STATE_GENERATE_CHALLENGE:
    case DCM_SVC29_CBK_PROC_STATE_SIGN_CHALLENGE:
    case DCM_SVC29_CBK_PROC_STATE_VERIFY_POOW:
      Dcm_SingletonContext.Diag.Services.Svc29.CsmCbkResult = result;
      Dcm_Svc29SetNextCbkProcessingState();
      break;
    case DCM_SVC29_CBK_PROC_STATE_CSM_CANCELLED:
      /* Remove service 0x29 as user of the buffer since the Csm callback is triggered and released the buffer */
      Dcm_NetBufferUsageLeave(Dcm_NetGetBufferContext(Dcm_Svc29GetBufferHdl()));                                                                     /* PRQA S 2840, 3387 */ /* MD_Dcm_DerefInvalidPointer, MD_Dcm_OptimizedInlineCode_3387 */ /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
      /* Reset callback processing state */
      Dcm_Svc29SetCbkProcessingState(DCM_SVC29_CBK_PROC_STATE_IDLE);
      break;
    default:                                                                                                                                         /* PRQA S 2016 */ /* MD_MSR_EmptyClause */
      /* Callback is not expected */
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);
      break;
    }
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    Dcm_UtiLeaveCriticalSection();
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_CSMASYNCJOBFINISHED, lErrorId);
}
# endif
#endif /* (DCM_SVC_29_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2ATaskSchdProcess()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_Svc2ATaskSchdProcess(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext
  )
{
  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

# if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
  /* scheduler timer update is done in a dedicated task to achieve maximum timing accuracy */
# else
  if (Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_SVC2A_SCHEDULER_TMR_UPD))
  {
    boolean doActivateProcessorTask;

    if(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries != 0u)
    {
      doActivateProcessorTask = Dcm_Svc2ASchdUpdateTimers();
      if(doActivateProcessorTask == TRUE)
      {
        Dcm_TskSetLocalEvent(pEventContext->Ev, DCM_TSK_EV_SVC2A_SCHEDULER_PROCESS);/* let's check which did is in a timeout */                      /* SBSW_DCM_PARAM_PTR_WRITE */
      }
      /* still something to do - keep timer updater alive */
      Dcm_TskSetLocalEvent(pEventContext->PostEv, DCM_TSK_EV_SVC2A_SCHEDULER_TMR_UPD);                                                               /* SBSW_DCM_PARAM_PTR_WRITE */
    }
  }

  if (Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_SVC2A_SCHEDULER_PROCESS))
# endif
  {
    Dcm_Svc2ASchdItemHandleOptType lSchdIter;

    /* loop over all scheduled items (maximum once per task activation) */
    for(lSchdIter = 0; lSchdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++lSchdIter)
    {
      Dcm_Svc2ASchdEntryPtrType pSchedTableEntry =
        Dcm_Svc2ASchdGetEntry(Dcm_SingletonContext.Diag.Services.Svc2A.Scheduler.CurrentEntryIndex);

      if( (pSchedTableEntry->Timer == 0u)
        &&( (pSchedTableEntry->Rate & DCM_SVC2A_RATE_TYPE_STOPPED) == 0u) )
      {
        Std_ReturnType lStdReturn;

        lStdReturn = Dcm_Svc2ASchdProcessEntry(pSchedTableEntry);                                                                                    /* SBSW_DCM_POINTER_WRITE_2ASCHEDULERENTRY */
        if(lStdReturn == DCM_E_PENDING)
        {
          Dcm_TskSetLocalEvent(pEventContext->PostEv, DCM_TSK_EV_SVC2A_SCHEDULER_PROCESS);                                                           /* SBSW_DCM_PARAM_PTR_WRITE */
          break; /* leave the loop and the task */
        }
      }
      /* next entry to be processed */
      Dcm_Svc2ASchdNextEntryIdxInc();
    }
  }
}
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
#include "Dcm_MemMap.h"                                                                                                                              /* PRQA S 5087 */ /* MD_MSR_MemMap */

#define DCM_START_SEC_CODE
#include "Dcm_MemMap.h"                                                                                                                              /* PRQA S 5087 */ /* MD_MSR_MemMap */
#if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetGetActiveComVariant()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Dcm_CfgVarMgrComVariantType, DCM_CODE) Dcm_NetGetActiveComVariant(
  void
  )
{
  return Dcm_SingletonContext.Network.ComVariant;
}
#endif

#if (DCM_NET_RX_BLOCKING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetSetRxAllowed()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_NetSetRxAllowed(
  boolean rxAllowed
  )
{
  Dcm_SingletonContext.Network.RxAllowed = rxAllowed;
}
#endif

/**********************************************************************************************************************
 *  Dcm_PbCfgNetGetConnectionInfo()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 */
FUNC(Dcm_CfgNetConnectionInfoType, DCM_CODE) Dcm_PbCfgNetGetConnectionInfo(
  uint8_least index
  )
{
  return Dcm_PbCfgNetConnectionInfo[index];
}

/**********************************************************************************************************************
 *  Dcm_PbCfgNetGetConnComMChannelMap()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Dcm_CfgNetNetIdRefMemType, DCM_CODE) Dcm_PbCfgNetGetConnComMChannelMap(
  uint8_least index
  )
{
  return Dcm_PbCfgNetConnComMChannelMap[index];
}

#if (DCM_NET_COMCTRL_ALLNET_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PbCfgNetGetComCtrlChannelListAll()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Dcm_CfgNetNetIdRefMemType, DCM_CODE) Dcm_PbCfgNetGetComCtrlChannelListAll(
  uint8_least index
  )
{
  return Dcm_PbCfgNetComCtrlChannelListAll[index];
}
#endif

/**********************************************************************************************************************
 *  Dcm_PbCfgNetGetNumAllComMChannels()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(NetworkHandleType, DCM_CODE) Dcm_PbCfgNetGetNumAllComMChannels(
  void
  )
{
  return Dcm_PbCfgNetNumAllComMChannels;
}

#if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PbRamNetGetComCtrlChannels()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Dcm_CommunicationModeType, DCM_CODE) Dcm_PbRamNetGetComCtrlChannels(
  uint8_least index
  )
{
  return Dcm_PbRamNetComCtrlChannels[index];
}
#endif

#if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PbCfgNetAllComMChannelMapGetEntry()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 */
FUNC(NetworkHandleType, DCM_CODE) Dcm_PbCfgNetAllComMChannelMapGetEntry(
  Dcm_CfgNetNetIdRefOptType index
  )
{
  return Dcm_PbCfgNetAllComMChannelMap[index];
}
#endif

#if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON) || \
    (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetGetHasRespPendOnBoot()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 */
FUNC(boolean, DCM_CODE) Dcm_NetGetHasRespPendOnBoot(
  Dcm_ContextPtrType pContext                                                                                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  return Dcm_NetGetProtObjOfTranspObj(Dcm_DiagGetTranspObj(pContext))->HasRespPendOnBoot;
}
#endif

/**********************************************************************************************************************
 *  Dcm_NetGetTransportObject()
 *********************************************************************************************************************/
 /*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Dcm_NetTransportObjectPtrType, DCM_CODE) Dcm_NetGetTransportObject(
  Dcm_CfgNetTObjHandleOptType index
  )
{
  Dcm_NetTransportObjectPtrType lResult;

  if (Dcm_DebugDetectRuntimeError(index >= Dcm_PbCfgNetNumTransportObjects))
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_CRITICAL_ERROR);
    lResult = &Dcm_PbRamNetTransportObject[0];
  }
  else
  {
    lResult = &Dcm_PbRamNetTransportObject[index];
  }

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_NetGetComState()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(Dcm_NetComMStateType, DCM_CODE) Dcm_NetGetComState(
  PduIdType rxPduId
  )
{
  Dcm_NetComMStateType lResult  = DCM_NET_COMM_STATE_RX_DIS_TX_DIS;                                                                                  /* PRQA S 2981 */ /* MD_Dcm_RetVal */
  uint8                lErrorId = DCM_E_NO_ERROR;

  DCM_IGNORE_UNREF_PARAM(rxPduId);                                                                                                                   /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* ----- Development Error Checks ---------------------------------------- */
  if(Dcm_DebugDetectError(Dcm_NetIsRxPduIdValid(rxPduId) == FALSE))
  {
    lErrorId = DCM_E_PARAM;
  }
  else
  {
    /* ----- Implementation ------------------------------------------------ */
    lResult = Dcm_NetGetComStateByRxPduId(rxPduId);                                                                                                  /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
  }

  /* ----- Development Error Report ---------------------------------------- */
  Dcm_DebugReportError(DCM_SID_INTERNAL, lErrorId);

  return lResult;
}

#if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetRxIndInternal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_NetRxIndInternal(
  PduIdType rxPduId,
  uint16 sourceAddress,
  Dcm_MsgType data,                                                                                                                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  PduLengthType length
  )
{
  Std_ReturnType                              notifResult = DCM_NET_ARENV_NTFRSLT_NOT_OK;
  BufReq_ReturnType                           bufReq;
  PduLengthType                               bufferSize;
  P2CONST(PduInfoType, AUTOMATIC, AUTOMATIC)  pInfo;
# if (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
  uint8                                     lMetaData[DCM_NET_METADATA_LENGTH];
  PduInfoType                               lInfo;
# endif

  DCM_IGNORE_UNREF_PARAM(sourceAddress);                                                                                                             /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

# if (DCM_NET_GENERIC_CONNECTION_ENABLED == STD_ON)
  if(Dcm_NetIsGenericConnection(Dcm_NetGetConnHdlOfRxPduId(rxPduId)))
  {
    lMetaData[DCM_NET_METADATA_SA_OFFSET] = (uint8)sourceAddress;                                                                                    /* SBSW_DCM_LOCAL_ARRAY_WRITE */
    lMetaData[DCM_NET_METADATA_TA_OFFSET] = Dcm_NetGetNodeAddress(Dcm_NetGetConnHdlOfRxPduId(rxPduId));                                              /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_LOCAL_ARRAY_WRITE */
    lInfo.SduDataPtr = lMetaData;
    lInfo.SduLength = DCM_NET_METADATA_LENGTH;
    pInfo = &lInfo;
  }
  else
# endif
  {
    pInfo = NULL_PTR;
  }

# if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
  Dcm_DebugAssert((Dcm_NetGetConnHdlOfRxPduId(rxPduId) < Dcm_PbCfgNetNumConnections), DCM_SID_INTERNAL, DCM_E_PARAM);                                /* COV_DCM_RTM_DEV_DEBUG XF */
# endif

  /* start virtual request; */
  Dcm_UtiEnterCriticalSection();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  /* Initiate reception for the required RxPduID. Mark this reception as an internal one in order to get correct
   * ComM management.
   */
  bufReq = Dcm_NetStartOfReception(rxPduId, pInfo, length, &bufferSize, DCM_NET_TOBJ_FLAG_INTERNAL);                                                 /* SBSW_DCM_POINTER_FORWARD_STACK */
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiLeaveCriticalSection();

  /* If reception accepted: */
  if(bufReq == BUFREQ_OK)
  {
    Dcm_NetTransportObjectPtrType pTranspObj;
    bufReq = Dcm_NetGetTranspObjOfConnection(Dcm_NetGetConnHdlOfRxPduId(rxPduId), &pTranspObj);                                                      /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */ /* SBSW_DCM_POINTER_FORWARD_STACK */

    if(bufReq == BUFREQ_OK)                                                                                                                          /* COV_DCM_RTM_UNREACHABLE XF */
    {
# if (DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
      /* If not a pseudo parallel request */
      if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_BUSY) == 0u)
# endif
      {
        PduInfoType pduInfo;

        pduInfo.SduDataPtr = data;
        pduInfo.SduLength = length;

        /* Copy received data */
        bufReq = Dcm_CopyRxData(rxPduId, &pduInfo, &bufferSize);                                                                                     /* SBSW_DCM_POINTER_FORWARD_STACK */
        /* If data copy succeeded: */
        if(bufReq == BUFREQ_OK)                                                                                                                      /* COV_DCM_RTM_UNREACHABLE TX */
        {
          /* Notify DCM about successful reception */
          notifResult = DCM_NET_ARENV_NTFRSLT_OK;
        }/* else - Dcm_CopyRxData failed -> exit with Dcm_TpRxIndication(failed) */
      }/* else - a pseudo parallel request will not be processed over an internal request */
    }
    else
    {
      /* Check for valid call state */
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);
    }
    /* Notify DCM about reception accomplishment only in case the reception was accepted */
    Dcm_TpRxIndication(rxPduId, notifResult);
  }/* else - no reception possible exit with fail */
  /* Return the operation result to the caller */
  return notifResult;
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif

#if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetTaskTaMonitor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_NetTaskTaMonitor(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_CfgNetTObjHandleOptType lTObjCntr;
  Dcm_TskTaskEvOptType        lEv = pEventContext->Ev;

  /* Check whether any request which has to be canceled is in progress */
  if(((DCM_DIAG_QUEUE_FLAG_IS_ACTIVE | DCM_DIAG_QUEUE_FLAG_IS_WAITING) & pContext->Diag.QueuedSet.Flags) != 0u)
  {

    /* Enter critical section (Reason: the transport object may not be modified from outside) */
    Dcm_UtiEnterCriticalSection();
    /*=================================*
      BEGIN CRITICAL SECTION
     *=================================*/

    /* If a request is in progress */
    if((DCM_DIAG_QUEUE_FLAG_IS_ACTIVE & pContext->Diag.QueuedSet.Flags) != 0u)
    {
      Dcm_TskTaskEvMemType tObjEv = Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvOptType, Dcm_DiagGetTranspObj(pContext)->Handle);

      /* If the ongoing request is from the same tester as the new request with the foreign N_TA */
      if (Dcm_TskIsLocalEventSet(lEv, tObjEv))
      {
        /* Cancel the request processing */
        Dcm_DiagCancelProcessing(Dcm_DiagGetTranspObj(pContext));                                                                                    /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      }/* else - post processing or idle are to be handled in a normal way */
    }

    /* If a waiting new request is in the queue */
    if((DCM_DIAG_QUEUE_FLAG_IS_WAITING & pContext->Diag.QueuedSet.Flags) != 0u)
    {
       Dcm_TskTaskEvMemType tObjEv = Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvOptType, Dcm_DiagGetQueuedTranspObj(pContext)->Handle);

       /* If the queued request is from the same tester as the new request with the foreign N_TA */
       if (Dcm_TskIsLocalEventSet(lEv, tObjEv))
       {
         /* Cancel the queued request in the next task cycle */
         pEventContext->PostEv = tObjEv;/* retry later */                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
       }
    }
    /*=================================*
      END CRITICAL SECTION
     *=================================*/
    /* Leave critical section */
    Dcm_UtiLeaveCriticalSection();
  }

  /* Scan all affected transport objects */
  lTObjCntr = 0u;
  DCM_TSK_EVENT_SCAN_LOOP(lEv)
  {
    if (Dcm_TskIsLocalEventSet(lEv, 0x01u))
    {
      Dcm_NetTransportObjectPtrType pTranspObj = Dcm_NetGetTransportObject(lTObjCntr);

      /* If a received but not yet processed request was interrupted by another request with a foreign N_TA */
      if( ( pTranspObj->State == DCM_NET_TOBJ_STATE_RX_END)
        &&((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_OBSOLETE) != 0u ) ) /* This is still the original transport object marked to be canceled in the Dcm_OnRequestIndication */
      {
        Dcm_NetBufferContextPtrType pBufferContext = Dcm_NetGetBufferContext(pTranspObj->BufferHdl);

        /* Prevent the processing of the received but not yet processed request */
        Dcm_TskClrEvent(DCM_TSK_ID_NET_RX, Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, pTranspObj->Handle));

        /* Deallocate the transport object and free the connection */
        Dcm_NetUnRegisterComMActivity(pTranspObj->ConnHdl); /* Deallocate transport object */
        Dcm_NetBufferRelease(pBufferContext); /* The buffer is free now */                                                                           /* PRQA S 3387 */ /* MD_Dcm_OptimizedInlineCode_3387 */ /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
        Dcm_NetUnRegisterActiveConnection(pTranspObj); /* No further processing needed */                                                            /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
      } /* Otherwise, connection is not obsolete or will be canceled during service processing (already in state
         * DCM_NET_TOBJ_STATE_READY) */
    }
    ++lTObjCntr;
  }
}                                                                                                                                                    /* PRQA S 6030, 6050 */ /* MD_MSR_STCYC, MD_MSR_STCAL */
#endif


/**********************************************************************************************************************
 *  Dcm_NetTaskRx()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_NetTaskRx(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_TskTaskEvMemType          lBusyEvents;
  Dcm_CfgNetTObjHandleOptType   lTranspObjWinnerId;
  Dcm_NetTransportObjectPtrType pTranspObj;

  lTranspObjWinnerId = Dcm_NetRxPrioritisationFindWinner(pEventContext->Ev, &lBusyEvents);                                                           /* SBSW_DCM_POINTER_FORWARD_STACK */

  pTranspObj = Dcm_NetGetTransportObject(lTranspObjWinnerId);

#if (DCM_NET_PROTOCOL_PARALLELISATION_ENABLED == STD_ON)
  /* If this is a request which can be handled in parallel */
  if(pContext->ThreadId != DCM_THREAD_ID_BASIC)
  {
    Dcm_NetProcessStartProtocol(pTranspObj);                                                                                                         /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
  }
  else
#endif
  {
    Dcm_NetRxPrioritisationProcessWinner(pContext, pTranspObj, &lBusyEvents);                                                                        /* SBSW_DCM_COMB_PTR_FORWARD */
    Dcm_NetRxPrioritisationProcessLoosers(lBusyEvents);
  }
}

/**********************************************************************************************************************
 *  Dcm_NetTaskTx()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_NetTaskTx(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if (Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_NET_TX_SEND_USDT))
  {
    {
      Dcm_CfgNetTObjHandleOptType lTObjIter;

      /* find candidate for NRC 0x21 or final response */
      for (lTObjIter = 0; lTObjIter < Dcm_PbCfgNetNumTransportObjects; ++lTObjIter)
      {
        Dcm_NetTransportObjectPtrType pTranspObj;
        pTranspObj = Dcm_NetGetTransportObject(lTObjIter);

#if (DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
        if ((pTranspObj->State == DCM_NET_TOBJ_STATE_RX_END) /* Completely received ... */
          && ((DCM_NET_TOBJ_FLAG_BUSY & pTranspObj->Flags) != 0u))/* ... a parallel request */
        {
          /* Send NRC 0x21 response */
          Dcm_NetComposeAddNegResponse(pTranspObj, DCM_NET_TOBJ_RESTYPE_SIMPLE, DCM_E_BUSYREPEATREQUEST);                                            /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
        }
#endif

        if (pTranspObj->State == DCM_NET_TOBJ_STATE_PREPTX)
        {
          Dcm_NetTransmitUsdtResponse(pTranspObj);                                                                                                   /* SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT */
        }
      }
    }
  }

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
  if (Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_NET_TX_SEND_UUDT))
  {
    Dcm_CfgNetPTxObjHandleOptType lPerTxObjIter;

    for (lPerTxObjIter = 0; lPerTxObjIter < Dcm_NetPeriodicMsgGetNextMsgHdl(); lPerTxObjIter++)
    {
      if (Dcm_NetGetPeriodicTxObject(lPerTxObjIter)->State == DCM_NET_PERIODIC_TX_STATE_QUEUED)
      {
        Dcm_NetPeriodicMsgTransmitTxObj(lPerTxObjIter);
      }
    }
  }
#endif
}
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateCheckDID()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_StateCheckDID(
  Dcm_NetConnRefMemType connHdl,
  uint16 did,
  Dcm_DidOpType didOpMask,
  Dcm_CfgStateRefOptType stateRef,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdReturn;

  /* Get the precondition package for the related diagnostic entity */
  CONSTP2CONST(Dcm_CfgStateDiagStateInfoType, AUTOMATIC, DCM_CONST) pStatePreconditions = &Dcm_StateGetPreconditionStates(stateRef);

  /* First verify the diagnostic session pre-condition (UDS verification order) */
  if(!Dcm_StateIsSupportedInSession(*pStatePreconditions))                                                                                           /* COV_DCM_RTM_DESIGN_LOWER_LAYER XF */
  {
    /* If not met, return appropriate to UDS NRC for the evaluated diagnostic entity (i.e. NRC 0x7F for services, 0x7E for sub-functions etc.) */
    *ErrorCode = Dcm_StateSessionNrcs[DCM_DIAG_CHK_LVL_PARAMETER];                                                                                   /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
  /* Otherwise, if supported, verify the authentication requirement (UDS verification order) */
# if (DCM_STATE_AUTHENTICATION_ENABLED == STD_ON)
  if(Dcm_AuthMgrCheckDid(connHdl, did, didOpMask, stateRef) == DCM_E_NOT_OK)
  {
    /* If not met, do return NRC 0x34 */
    *ErrorCode = DCM_E_AUTHENTICATIONREQUIRED;                                                                                                       /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
# endif
  /* Otherwise, if supported, verify the security access level pre-condition (UDS verification order) */
# if (DCM_STATE_SECURITY_ENABLED == STD_ON)
  if(!Dcm_StateIsSupportedInSecurityLevel(*pStatePreconditions))
  {
    /* If not met, do return NRC 0x33 (UDS) */
    *ErrorCode = DCM_E_SECURITYACCESSDENIED;                                                                                                         /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
# endif
  {
# if (DCM_MODEMGR_CHECK_SUPPORT_ENABLED == STD_ON)
    /* Otherwise, if supported, get the the mode-related pre-condition expression(s) result */
    lStdReturn = Dcm_ModeCheck(Dcm_CfgStatePreconditions[stateRef].ModeRuleRef, ErrorCode);                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
# else
    /* Otherwise, everything fine - return positive response code */
    lStdReturn = DCM_E_OK;
# endif
  }

  DCM_IGNORE_UNREF_PARAM(did);                                                                                                                       /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(didOpMask);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(connHdl);                                                                                                                   /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  return lStdReturn;
}
#endif
/**********************************************************************************************************************
 *  Dcm_TmrSetTimerByThread()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_TmrSetTimerByThread(
  Dcm_TmrTimerIdOptType timerId,
  Dcm_TmrTimerCntrMemType timeTicks,
  Dcm_ThreadIdOptType threadId
  )
{
  Dcm_TmrTimerIdOptType      lTimerContextId;
  Dcm_TmrTimerContextPtrType pTimerContext;

  lTimerContextId = (Dcm_TmrTimerIdOptType)(Dcm_TmrGetTimerInfo(timerId)->TimerContextRef + threadId);
  pTimerContext   = Dcm_TmrGetTimerContext(lTimerContextId);

  /* Update the corresponding timer counter */
  pTimerContext->Timer = timeTicks;                                                                                                                  /* SBSW_DCM_POINTER_WRITE_TIMERCONTEXT */
}

/**********************************************************************************************************************
 *  Dcm_TmrStartTimerByThread()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_TmrStartTimerByThread(
  Dcm_TmrTimerIdOptType timerId,
  Dcm_TmrTimerCntrMemType timeTicks,
  Dcm_ThreadIdOptType threadId
  )
{
  if (timeTicks != 0u)
  {
    Dcm_TmrTimerIdOptType      lTimerContextId;
    Dcm_TmrTimerContextPtrType pTimerContext;

    lTimerContextId = (Dcm_TmrTimerIdOptType)(Dcm_TmrGetTimerInfo(timerId)->TimerContextRef + threadId);
    pTimerContext = Dcm_TmrGetTimerContext(lTimerContextId);

    /* Enter critical section (Reason: A timer can be modified from an ISR or higher priority task) */
    Dcm_UtiEnterCriticalSection();
    /*=================================*
      BEGIN CRITICAL SECTION
      *=================================*/
    /* Update the corresponding timer counter */
    pTimerContext->Timer = timeTicks;                                                                                                                /* SBSW_DCM_POINTER_WRITE_TIMERCONTEXT */

    /* Mark timer as running */
    Dcm_TmrSetTimerRunning(lTimerContextId);
    /*=================================*
      END CRITICAL SECTION
      *=================================*/
    Dcm_UtiLeaveCriticalSection();
    /* Signal the Dcm_TmrTaskTimer() that at least one timer is active */
    Dcm_TskSetEvent(DCM_TSK_ID_TIMER, DCM_TSK_EV_TIMER_ACTIVE);
  }
}

/**********************************************************************************************************************
 *  Dcm_TmrStopTimerByThread()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_TmrStopTimerByThread(
  Dcm_TmrTimerIdOptType timerId,
  Dcm_ThreadIdOptType threadId
  )
{
  Dcm_TmrTimerIdOptType lTimerContextId;

  lTimerContextId = (Dcm_TmrTimerIdOptType)(Dcm_TmrGetTimerInfo(timerId)->TimerContextRef + threadId);

  /* Enter critical section (Reason: A timer can be modified from an ISR or higher priority task) */
  Dcm_UtiEnterCriticalSection();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  /* Mark timer as not running */
  Dcm_TmrSetTimerStopped(lTimerContextId);
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiLeaveCriticalSection();
}

/**********************************************************************************************************************
 *  Dcm_TmrResumeTimerByThread()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_TmrResumeTimerByThread(
  Dcm_TmrTimerIdOptType timerId,
  Dcm_ThreadIdOptType threadId
  )
{
  Dcm_TmrTimerIdOptType           lTimerContextId;
  Dcm_TmrTimerContextConstPtrType pTimerContext;

  lTimerContextId = (Dcm_TmrTimerIdOptType)(Dcm_TmrGetTimerInfo(timerId)->TimerContextRef + threadId);
  pTimerContext   = Dcm_TmrGetTimerContext(lTimerContextId);

  /* Enter critical section (Reason: A timer can be modified from an ISR or higher priority task) */
  Dcm_UtiEnterCriticalSection();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  if(pTimerContext->Timer != 0u)
  {
    /* Mark timer as running */
    Dcm_TmrSetTimerRunning(lTimerContextId);
  }
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiLeaveCriticalSection();
  /* Signal the Dcm_TmrTaskTimer() that at least one timer is active */
  Dcm_TskSetEvent(DCM_TSK_ID_TIMER, DCM_TSK_EV_TIMER_ACTIVE);
}

/**********************************************************************************************************************
 *  Dcm_TmrTaskTimer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_TmrTaskTimer(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext
  )
{
  Dcm_TmrMaskOptType    expiredTimers = 0u;
  Dcm_TmrTimerIdOptType timerIter;

  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* The only event here is the DCM_TSK_EV_TIMER_ACTIVE. If not set, this task will not be called -> no additional event check is necessary */

  /* Enter critical section (Reason: A timer can be modified from an ISR or higher priority task) */
  Dcm_UtiEnterCriticalSection();
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  /* Iterate over all system timers: */
  for(timerIter = 0; timerIter < DCM_TMR_NUM_TIMER_CONTEXTS_CASTED; ++timerIter)
  {
    Dcm_TmrTimerContextPtrType pTimerContext = Dcm_TmrGetTimerContext(timerIter);

    expiredTimers <<=1; /* next timer */
    /* If a timer is active (not yet expired or stopped), update its counter (decrement by one) */
    if(Dcm_TmrIsTimerRunning(timerIter))
    {
      pTimerContext->Timer--;                                                                                                                        /* PRQA S 3387 */ /* MD_Dcm_OptimizedInlineCode_3387 */ /* SBSW_DCM_POINTER_WRITE_TIMERCONTEXT */

      if(pTimerContext->Timer == 0u)
      {
        /* If the concrete timer did expire with the above step, register the timerId for later processing */
        expiredTimers |= 0x01u;
        Dcm_TmrSetTimerStopped(timerIter);
      }
      else
      {
        /* Otherwise, signal reactivation of this task again at next main-function cycle, since at least one timer still active */
        pEventContext->PostEv |= DCM_TSK_EV_TIMER_ACTIVE;                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
      }
    }
  }
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  /* Leave critical section */
  Dcm_UtiLeaveCriticalSection();

  /* Iterate over all expired timers only: */
  DCM_UTI_LOOP_BIT_SCAN(expiredTimers)
  {
    --timerIter; /* pre-decrement since the iterator equals at first DCM_TMR_NUM_TIMERS_CASTED */
    if(Dcm_UtiBitOpTest(Dcm_TmrMaskOptType, expiredTimers, 0x01u))
    {
      Dcm_TmrTimerIdOptType   lTimerInfoId;
      Dcm_TmrTimerInfoPtrType lTimerInfo;

      lTimerInfoId = Dcm_TmrGetTimerContext(timerIter)->TimerInfoRef;
      lTimerInfo   = Dcm_TmrGetTimerInfo(lTimerInfoId);

      {
        /* Invoke the associated with the timer "Dcm_OnTimeout*" handler function */
        Dcm_TmrTimerCntrMemType reloadTicks = lTimerInfo->OnTimeoutFunc((Dcm_ThreadIdMemType)(timerIter - lTimerInfo->TimerContextRef));             /* SBSW_DCM_CALL_FUNCPTR_TIMERINFO */
        if(reloadTicks != 0u)                                                                                                                        /* COV_DCM_RTM_DESIGN_LOWER_LAYER XF */
        {
          /* If the handler requires an immediate reload of the timer, activate the timer immediately */
          Dcm_TmrStartTimerByThread(lTimerInfoId, reloadTicks, (Dcm_ThreadIdMemType)(timerIter - lTimerInfo->TimerContextRef));
        }
      }
    }
  }
}
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27Init()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_Service27Init(
  void
  )
{
  uint8_least lSecLvlIter;
  Dcm_Svc27ResetSequence();

  /* For each security level: */
  for(lSecLvlIter = 0; lSecLvlIter < DCM_STATE_SECURITY_NUM_LEVELS; ++lSecLvlIter)
  {
    /* Initialize the security timer and counter */
    Dcm_Svc27TimerReset(lSecLvlIter);
    Dcm_Svc27CounterReset(lSecLvlIter);

# if (DCM_STATE_SEC_DELAY_ON_BOOT_ENABLED == STD_ON)
    /* If a delay time on boot is supported: */
    if(Dcm_CfgStateSecurityInfo[lSecLvlIter].DelayTimeOnBoot != 0u)                                                                                  /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
    {
      /* Start the appropriate security timer */
      Dcm_Svc27TimerStart(lSecLvlIter, Dcm_CfgStateSecurityInfo[lSecLvlIter].DelayTimeOnBoot);                                                       /* PRQA S 2841 */ /* MD_Dcm_DerefInvalidPointer */
    }
# endif
  }

  /* Initialize the bit masks related to Get- and Set-AttemptCounter APIs */
# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  Dcm_SingletonContext.Diag.Services.Svc27.GetAttCntrEventMask = DCM_SVC_27_LEVEL_MASK;
  Dcm_SingletonContext.Diag.Services.Svc27.SetAttCntrEventMask = 0u;
  Dcm_SingletonContext.Diag.Services.Svc27.ReloadMask = 0u;
  Dcm_SingletonContext.Diag.Services.Svc27.GetAttOpStatus = DCM_INITIAL;
  Dcm_SingletonContext.Diag.Services.Svc27.SetAttOpStatus = DCM_INITIAL;

  /* Trigger the reading of the attempt counter values */
  Dcm_TskSetEvent(DCM_TSK_ID_SVC27, DCM_TSK_EV_SVC_27_ATTEMPT_CNTR_READ);
# endif
}
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_29_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service29Init()
*********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_Service29Init(
  void
  )
{
  Dcm_Svc29ResetSequence();
# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
  Dcm_Svc29SetCbkProcessingState(DCM_SVC29_CBK_PROC_STATE_IDLE);
# endif
  }
#endif /* (DCM_SVC_29_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service2AInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_Service2AInit(
  void
  )
{
  Dcm_Service2ASchedulerInit();
}
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrRead()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrRead(
  Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle,
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext
  )
{
  Std_ReturnType lStdReturn;
  Dcm_OpStatusType lOpStatus = opStatus;

  /* The DDDID shall be a defined one! */
  Dcm_DebugAssert((Dcm_Svc2CIsDynDidDefined(dynDidHandle)), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                  /* COV_DCM_RTM_DEV_DEBUG XF */

  lStdReturn = Dcm_Svc2CDefMgrReadCheckAccessAndInit(dynDidHandle, &lOpStatus);                                                                      /* SBSW_DCM_POINTER_FORWARD_STACK */

  if(lStdReturn == DCM_E_OK)
  {
    Dcm_Svc2CDynDidProcessContextPtrType pProcessContext;

    pProcessContext = Dcm_Svc2CGetDDDidProcessContext(DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED);

    if(lOpStatus == DCM_INITIAL)
    {
      Dcm_SingletonContext.Diag.Services.Svc2C.DynDidAccessContext.DynDidHandleInUse = dynDidHandle;
      pProcessContext->ItemInProgress = Dcm_DidMgrGetDynDidSrcItemStartRef(dynDidHandle);                                                            /* SBSW_DCM_POINTER_WRITE_2CPROCESSCONTEXT */
      pProcessContext->ItemToStop = (Dcm_CfgDidMgrDynDidSrcItemIdxMemType)(pProcessContext->ItemInProgress + Dcm_Svc2CGetItem(dynDidHandle)->Count); /* SBSW_DCM_POINTER_WRITE_2CPROCESSCONTEXT */
    }

    /* Process source items */
    lStdReturn = Dcm_Svc2CDefMgrReadSrcItems(lOpStatus, pDataContext, pProcessContext);                                                              /* SBSW_DCM_POINTER_FORWARD_STACK */
  }

  if(lStdReturn != DCM_E_PENDING)
  {
    /* Release resource */
    Dcm_SingletonContext.Diag.Services.Svc2C.DynDidAccessContext.DynDidHandleInUse = DCM_SVC2C_INVALID_DYNDID_HDL;
  }
  return lStdReturn;
}

# if (DCM_DIDMGR_DYNDID_SRCITEM_CHECK_COND_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrConditionCheckRead()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrConditionCheckRead(
  Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle,
  Dcm_OpStatusType opStatus,
  Dcm_NegativeResponseCodePtrType errorCode
  )
{
  Std_ReturnType lStdResult = DCM_E_OK; /* if the DynDID does not contain any DID sources -> always OK */
  Dcm_Svc2CDynDidProcessContextPtrType pProcessContext;
  Dcm_OpStatusType lOpStatus = opStatus;

  /* The DDDID shall be a defined one! */
  Dcm_DebugAssert((Dcm_Svc2CIsDynDidDefined(dynDidHandle)), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                  /* COV_DCM_RTM_DEV_DEBUG XF */

  pProcessContext = Dcm_Svc2CGetDDDidProcessContext(DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY);

  if(lOpStatus == DCM_INITIAL)
  {
    pProcessContext->ItemInProgress = Dcm_DidMgrGetDynDidSrcItemStartRef(dynDidHandle);                                                              /* SBSW_DCM_POINTER_WRITE_2CPROCESSCONTEXT */
    pProcessContext->ItemToStop = (Dcm_CfgDidMgrDynDidSrcItemIdxMemType)(pProcessContext->ItemInProgress
                                                                         + Dcm_Svc2CGetItem(dynDidHandle)->Count);                                   /* SBSW_DCM_POINTER_WRITE_2CPROCESSCONTEXT */
  }

  for(; pProcessContext->ItemInProgress < pProcessContext->ItemToStop; ++pProcessContext->ItemInProgress)                                            /* SBSW_DCM_PARAM_PTR_WRITE */
  {
    if(Dcm_Svc2CIsDidSrcItem(pProcessContext->ItemInProgress))
    {
      Dcm_Svc2CInitDidInfoFromDidInfoIdx(Dcm_Svc2CGetSrcItem(pProcessContext->ItemInProgress)->DidDescriptor.DidInfoIdx
                                         ,&(pProcessContext->SrcDidContext));                                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */

      if(Dcm_DidMgrIsOpTypeSupported(Dcm_CfgDidMgrGetDidOpInfo(&(pProcessContext->SrcDidContext))                                                    /* SBSW_DCM_POINTER_WRITE_2CPROCESSCONTEXT */
                                    ,DCM_DIDMGR_OPTYPE_READCHKCOND))
      {
        Dcm_DidMgrInitOpClassInfo(&(pProcessContext->SrcDidContext)                                                                                  /* SBSW_DCM_POINTER_WRITE_2CPROCESSCONTEXT */
                                 ,DCM_DIDMGR_OPTYPE_READCHKCOND);

        lStdResult = Dcm_DidMgrReadCheckCond(lOpStatus
                                            ,&(pProcessContext->SrcDidContext)
                                            ,&(pProcessContext->DidOpTypeContext)
                                            ,errorCode);                                                                                             /* SBSW_DCM_COMB_PTR_FORWARD */
        if(lStdResult == DCM_E_OK)
        {
          /* prepare for next item */
          lOpStatus = DCM_INITIAL;
        }
        else
        {
          break; /* just delegate the return value */                                                                                                /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
        }
      } /* else - no check condition supported by this signal */
    } /* else - memory ranges cannot be checked in advance! */
  }
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrReadDataLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrReadDataLength(
  Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle,
  Dcm_DidMgrDidLengthPtrType dataLength
  )
{
  *dataLength = Dcm_Svc2CGetItem(dynDidHandle)->Length;                                                                                              /* SBSW_DCM_PARAM_PTR_WRITE */
  return DCM_E_OK;
}

# if (DCM_DIDMGR_DYNDID_SRCITEM_CHECK_STATE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CStateCheckSrcItems()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CStateCheckSrcItems(
  Dcm_NetConnRefMemType connHdl,
  Dcm_CfgDidMgrDynDidHandleOptType dynDidHandle,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult = DCM_E_OK;
  Dcm_CfgDidMgrDynDidSrcItemIdxOptType currItem;
  Dcm_CfgDidMgrDynDidSrcItemIdxOptType endItem;

  DCM_IGNORE_UNREF_PARAM(connHdl);                                                                                                                   /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  currItem = Dcm_DidMgrGetDynDidSrcItemStartRef(dynDidHandle);
  endItem = (Dcm_CfgDidMgrDynDidSrcItemIdxOptType)(currItem + Dcm_Svc2CGetItem(dynDidHandle)->Count);

  Dcm_DebugAssert((currItem < endItem), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);                                                                      /* COV_DCM_RTM_DEV_DEBUG XF */

  for(; currItem < endItem; currItem++)
  {
    if(Dcm_Svc2CIsDidSrcItem(currItem))
    {
#  if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
      Dcm_DidMgrDidInfoContextType lDidInfoContext;

      Dcm_Svc2CInitDidInfoFromDidInfoIdx(Dcm_Svc2CGetSrcItem(currItem)->DidDescriptor.DidInfoIdx, &lDidInfoContext);                                 /* SBSW_DCM_POINTER_FORWARD_STACK */

      lStdResult = Dcm_StateCheckDID(connHdl
                                    ,lDidInfoContext.Did
                                    ,DCM_DIDMGR_OP_READ
                                    ,Dcm_CfgDidMgrGetDidOpInfo(&lDidInfoContext)->ExecCondRef                                                        /* PRQA S 2962 */ /* MD_Dcm_2962 */
                                    ,ErrorCode);                                                                                                     /* SBSW_DCM_COMB_PTR_FORWARD */
#  endif
    }
    else
    {
#  if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
      lStdResult = Dcm_MemMgrCheckMemBlock(&(Dcm_Svc2CGetSrcItem(currItem)->MemDescriptor.MemBlock)
                                          ,DCM_MEMMGR_OP_READ
                                          ,ErrorCode);                                                                                               /* SBSW_DCM_COMB_PTR_FORWARD */
#  endif
    }
    if (lStdResult != DCM_E_OK)
    {
      break;
    }
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2CIsDidDefined()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(boolean, DCM_CODE) Dcm_Svc2CIsDidDefined(
  Dcm_CfgDidMgrDidInfoConstPtrType pDidInfo
  )
{
  return ((!Dcm_DidMgrIsOpSupported(pDidInfo, DCM_DIDMGR_OP_DEFINE))
          || Dcm_Svc2CIsDynDidDefined((Dcm_CfgDidMgrDynDidHandleMemType)(pDidInfo->OpRef)));                                                         /* PRQA S 3415 */ /* MD_Dcm_Rule13.5 */
}
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service2CInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_Service2CInit(
  void
  )
{
  Dcm_Svc2CDefMgrInit();
}
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service2FInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_Service2FInit(
  void
  )
{
# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
  Dcm_CfgDidMgrIoDidHandleOptType ioDidIter;

  Dcm_SingletonContext.Diag.Services.Svc2F.HasAnyActiveIoDid = FALSE;
  for(ioDidIter = 0; ioDidIter < Dcm_UtiGenericBitSetCalcSize(DCM_NUM_IODIDS); ++ioDidIter)
  {
    Dcm_UtiBitSetBasePtrType pActiveIoDids = Dcm_Svc2FGetActiveIoDids(ioDidIter);
    *pActiveIoDids = 0u;                                                                                                                             /* SBSW_DCM_POINTER_WRITE_2FACTIVEIODIDS */
  }
# endif
}
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service86Init()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_Service86Init(
  void
  )
{
  Dcm_ExtService86Init();/* delegate to the extension */
}
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
#include "Dcm_MemMap.h"                                                                                                                              /* PRQA S 5087 */ /* MD_MSR_MemMap */

#define DCM_START_SEC_CALLOUT_CODE
#include "Dcm_MemMap.h"                                                                                                                              /* PRQA S 5087 */ /* MD_MSR_MemMap */
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferDataPadding()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_PagedBufferDataPadding(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode                                                                                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Check for remaining parts to be padded */
  Dcm_UtiMemSetUintX(Dcm_UtiGetDataContextBuffer(pDataContext), Dcm_MsgItemType, 0x00u, pDataContext->AvailLen);                                     /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_POINTER_WRITE_DATA_CONTEXT */
  /* Signalize that all requested data are provided */
  Dcm_UtiCommitData(pDataContext, pDataContext->AvailLen);                                                                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
  /* Enforce transmission of the current part */
  return DCM_E_BUFFERTOOLOW;
}
#endif
/**********************************************************************************************************************
 *  Dcm_Service10Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service10Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  Dcm_Svc10RepeaterProxyContextPtrType pRepContext = &pContext->Repeater.Context.Svc10;

  switch(Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc10Handler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC10_PROGRESS_CHECK_ACCESS:
    lStdResult = Dcm_Svc10CheckAccess(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                      /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
#if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
  case DCM_SVC10_PROGRESS_TRIGGER_RESET:
    lStdResult = Dcm_Svc10_TriggerReset(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                    /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC10_PROGRESS_WAIT_RESET_ACK:
    lStdResult = Dcm_Svc10_WaitForResetAck(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                 /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC10_PROGRESS_WAIT_RCRRP_ACK:
    lStdResult = Dcm_Svc10_WaitForRcrRpAck(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                 /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC10_PROGRESS_SET_PRGCOND:
    lStdResult = Dcm_Svc10_SetProgConditions(opStatus, pMsgContext, ErrorCode, pRepContext);                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
#endif
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);
    break;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service10FastPostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service10FastPostProcessor(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_ConfirmationStatusType status
  )
{
  if(status == DCM_RES_POS_OK)
  {
    Dcm_DiagSetP2Timings(pContext->Repeater.Context.Svc10.SesStateIdx
                        ,Dcm_NetGetProtIdOfActiveProtocol()
                        ,pContext->ThreadId);

#if (DCM_SVC_10_RESET_AFTER_RESPONSE == STD_ON)
    if(pContext->Repeater.Context.Svc10.ResetMode != RTE_MODE_DcmEcuReset_NONE)
    {
      Dcm_SingletonContext.Network.RxAllowed = FALSE; /* lock any further communication while the ECU is getting reset */
    }
#endif
  }
}

/**********************************************************************************************************************
 *  Dcm_Service10PostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service10PostProcessor(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_ConfirmationStatusType status
  )
{
  if(status == DCM_RES_POS_OK)
  {
    /* execute transition */
    Dcm_StateSetSession(pContext->Repeater.Context.Svc10.SesStateIdx);
#if (DCM_SVC_10_RESET_AFTER_RESPONSE == STD_ON)
    if(pContext->Repeater.Context.Svc10.ResetMode != RTE_MODE_DcmEcuReset_NONE)
    {
      /* fire and forget - if failed - no chance to send any NRC from here */
      (void)Dcm_ModeSwitchEcuReset(RTE_MODE_DcmEcuReset_EXECUTE);
    }
#endif
  }
  else
  {
    /* on the way of changing a session */
    if(0u == ( Dcm_SingletonContext.StateMgr.Preconditions.Session
            & Dcm_SingletonContext.StateMgr.PendingSession) )
    {
      /* undo pending session expectation */
#if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
      Dcm_UtiEnterCriticalSection();/* avoid interrupt from the Dcm_NetTaskRx || Dcm_NetStartOfReception() */
#else
      Dcm_SplitTaskEnterCS();/* avoid interrupt from the Dcm_NetTaskRx */
#endif
      /*=================================*
        BEGIN CRITICAL SECTION
       *=================================*/
      Dcm_StateSyncPendingSession();/* synchronize with the currently active session */
      /*=================================*
        END CRITICAL SECTION
       *=================================*/
#if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
      Dcm_UtiLeaveCriticalSection();
#else
      Dcm_SplitTaskLeaveCS();
#endif
    }/* else - nothing to undo */
  }
}
#if (DCM_SVC_22_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service22Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service22Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  Dcm_Svc22RepeaterProxyContextPtrType pRepContext = &pContext->Repeater.Context.Svc22;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc22Handler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC22_PROGRESS_DIDLOOKUP:
    lStdResult = Dcm_Svc22DidLookUp(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                        /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC22_PROGRESS_CHECKCONDITION:
    lStdResult = Dcm_Svc22CheckCondition(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                   /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC22_PROGRESS_GETLENGTH:
    lStdResult = Dcm_Svc22GetLength(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                        /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC22_PROGRESS_READDATA:
    lStdResult = Dcm_Svc22ReadData(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                   /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE XX */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);
    break;
  }

  return lStdResult;
}

# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service22Updater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service22Updater(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_OpStatusType opStatus,
  Dcm_DiagDataContextPtrType pDataContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Dcm_Svc22RepeaterProxyContextPtrType pRepContext = &pContext->Repeater.Context.Svc22;

  return Dcm_Svc22UtiReadData(opStatus, pDataContext, ErrorCode, pRepContext);                                                                       /* SBSW_DCM_COMB_PTR_FORWARD */
}
# endif

/**********************************************************************************************************************
 *  Dcm_Service22Cancel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service22Cancel(
  Dcm_ContextPtrType pContext                                                                                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
# if (DCM_DIDMGR_PAGED_SUPPORT_ENABLED == STD_ON)
  if(pContext->PagedBuffer.State != DCM_PAGEDBUFFER_STATE_INACTIVE)
  {
    Dcm_NegativeResponseCodeType         lNrc;
    Dcm_DiagDataContextType              lDataContext;
    Dcm_PbCfgNetBufferInfoPtrType        lBufferInfo;
    Dcm_Svc22RepeaterProxyContextPtrType pRepContext = &pContext->Repeater.Context.Svc22;

    /* Initialize the data context */
    lBufferInfo = Dcm_NetGetBufferInfo(Dcm_DiagGetTranspObj(pContext)->BufferHdl);

    Dcm_UtiInitDataContext(&lDataContext, lBufferInfo->BufferPtr, lBufferInfo->Size);                                                                /* SBSW_DCM_POINTER_INIT_DATA_CONTEXT */

    /* Notify the application about the cancellation */
    (void)Dcm_Svc22UtiReadData(DCM_CANCEL, &lDataContext, &lNrc, pRepContext);                                                                       /* SBSW_DCM_COMB_PTR_FORWARD */
  }
# endif

  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  Dcm_RsrcMgrReleaseDidLock(DCM_RSRCMGR_DIDLOCK_OWNER_SID22);
}
#endif /* (DCM_SVC_22_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_24_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service24Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service24Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  Dcm_Svc24RepeaterProxyContextPtrType pRepContext = &pContext->Repeater.Context.Svc24;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc24Handler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC24_PROGRESS_DIDLOOKUP:
    lStdResult = Dcm_Svc24DidLookUp(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                        /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC24_PROGRESS_EXECUTEOP:
    lStdResult = Dcm_Svc24ExecuteOp(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                  /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_24_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service27Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  Dcm_Svc27RepeaterProxyContextPtrType pRepContext = &pContext->Repeater.Context.Svc27;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Service27Handler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                      /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC27_PROGRESS_SEEDPROCESSOR:
    lStdResult = Dcm_Service27SeedProcessor(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC27_PROGRESS_KEYPROCESSOR:
    lStdResult = Dcm_Service27KeyProcessor(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                 /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  case DCM_SVC27_PROGRESS_SETATTEMPTCNTR:
    lStdResult = Dcm_Service27SetAttemptCntrRepeater(opStatus, pMsgContext, ErrorCode, pRepContext);                                                 /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
  case DCM_SVC27_PROGRESS_SEEDREPEATER:
    lStdResult = Dcm_Service27SeedRepeater(opStatus, pMsgContext, ErrorCode, pRepContext);                                                           /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC27_PROGRESS_KEYREPEATER:
    lStdResult = Dcm_Service27KeyRepeater(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                  /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC27_PROGRESS_CHECKATTEMPTSEXCEEDED:
    lStdResult = Dcm_Service27CheckAttemptsExceededRepeater(opStatus, pMsgContext, ErrorCode, pRepContext);                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);
    break;
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */

/**********************************************************************************************************************
 *  Dcm_Service27PostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service27PostProcessor(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_ConfirmationStatusType status
  )
{
  Dcm_Svc27RepeaterProxyContextConstPtrType pRepContext = &pContext->Repeater.Context.Svc27;

  /* If a positive response was successfully sent */
  if(status == DCM_RES_POS_OK)
  {
    /* If it was a compare key request: */
    if(Dcm_Svc27IsKeyRequest(pRepContext->SubSvcRef) == TRUE)                                                                                        /* PRQA S 4304 */ /* MD_MSR_AutosarBoolean */
    {
      /* Apply the new security state and reset sequence */
      Dcm_StateSetSecurity((Dcm_StateIndexOptType)(Dcm_Svc27GetSecLvlRef(pRepContext->SubSvcRef)) + 1u); /* locked = 0x00 -> level 1 = 0x01, etc */

      /* Set IdsM security event */
      Dcm_DebugReportSecurityEvent(pContext->ThreadId, DCM_DEBUG_SEV_ECU_UNLOCK_SUCCESSFUL);
    }
    else
    {
      /* If this was no zero seed response: */
      if(pRepContext->IsZeroSeed == FALSE)
      {
        /* Prepare for key acceptance */
        Dcm_SingletonContext.Diag.Services.Svc27.SeedLevel = Dcm_CfgStateSecurityInfo[(Dcm_Svc27GetSecLvlRef(pRepContext->SubSvcRef))].Value;
      }
      else
      {
        /* Otherwise, there is no key expected in that case after zero seed */
        Dcm_Svc27ResetSequence();
      }
    }
  }
  else if((DCM_DIAG_RES_NEG_ANY & status) != 0u) /* Otherwise, if any negative response was sent: */
  {
    /* Reset the key-seed-sequence */
    Dcm_Svc27ResetSequence();
  }
  else /* POS_NOK */
  {
    /*
     * Otherwise no change required:
     *   - on SeedReq: the client shall retry the seed request or send another one
     *                 -> do not move to expect key for a certain level
     *   - on KeyReq:  the client may retry the key request to get a response
     *                 -> do not invalidate expect key for this level
     */
  }
}

# if (DCM_TSK_NUM_SVC27 > 0u)
/**********************************************************************************************************************
 *  Dcm_Svc27Task()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_Svc27Task(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_TskEventContextPtrType pEventContext                                                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* If the attempt counters should be restored: */
  if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_SVC_27_ATTEMPT_CNTR_READ))
  {
    /* Process attempt counter reading */
    Dcm_Svc27ReadAttemptCounter(pEventContext);                                                                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  /* If the attempt counters should be stored: */
  if(Dcm_TskIsLocalEventSet(pEventContext->Ev, DCM_TSK_EV_SVC_27_ATTEMPT_CNTR_WRITE))
  {
    /* Process attempt counter writing */
    Dcm_Svc27WriteAttemptCounter(pEventContext);                                                                                                     /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
}
# endif
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_29_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service29_00Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service29_00Processor(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode                                                                                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext = &pContext->Repeater.Context.Svc29;

  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Set connection state to deauthenticated */
  pRepContext->ConnContext.AuthState = DCM_DEAUTHENTICATED;                                                                                          /* SBSW_DCM_GLOBAL_PTR_WRITE */
  pRepContext->ConnContext.ActiveRole = DCM_AUTHMGR_DEAUTHENTICATED_ROLE;                                                                            /* SBSW_DCM_GLOBAL_PTR_WRITE */

  /* Set the authenticationReturnParameter of the response to DeAuthentication successful */
  Dcm_UtiProvideResDataAsU8(pMsgContext, DCM_SVC29_DEAUTH_SUCCESSFUL);                                                                               /* SBSW_DCM_PARAM_PTR_FORWARD */
  Dcm_RepeaterNextStep(pContext, DCM_SVC29_PROGRESS_PERSIST_AUTHENTICATION);                                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */

  return DCM_E_LOOP;
}
# endif

# if (DCM_SVC_29_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service29_01Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service29_01Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  boolean        lIsReqLenValid = FALSE;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Check that request contains COCO(1Byte) and length field for client certificate */
  if(pMsgContext->reqDataLen > (1u + DCM_SVC29_REQ_LENGTH_FIELD_BYTELEN))
  {
    uint8 lCocoField;
    uint16 lClientCertLength;

    Dcm_UtiConsumeReqDataAsU8(pMsgContext, &lCocoField);                                                                                             /* SBSW_DCM_COMB_PTR_FORWARD */
    Dcm_UtiConsumeReqDataAsU16(pMsgContext, &lClientCertLength);                                                                                     /* SBSW_DCM_COMB_PTR_FORWARD */

    /* Check that request contains length field for client challenge */
    if( (lClientCertLength > 0u)
      &&(pMsgContext->reqDataLen == (lClientCertLength + DCM_SVC29_REQ_LENGTH_FIELD_BYTELEN)) )
    {
      uint16 lChallengeClientLength = Dcm_UtiGetReqDataAsU16Rel(pMsgContext, lClientCertLength);                                                     /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */

      /* Check if length of challenge client is 0 */
      if(lChallengeClientLength == 0u)
      {
        lIsReqLenValid = TRUE;

        /* If COCO field equals 0x00 start request processing */
        if (lCocoField == 0u)
        {
          uint16 lClientCertId = Dcm_CfgAuthMgrNetConnInfo[pContext->Repeater.Context.Svc29.AuthInfoHdl].ConnectionCertificateId;
          lStdResult = Dcm_Svc29CertificateStoreVerify(lClientCertId, lClientCertLength, pContext, pMsgContext, ErrorCode);                          /* SBSW_DCM_PARAM_PTR_FORWARD */
        }
        /* If COCO field doesnt equal 0x00 send NRC 0x31 and stop looping */
        else
        {
          *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
        }
      }
    }
  }

  if(lIsReqLenValid == FALSE)
  {
    *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
  }

  return lStdResult;
}
# endif

# if (DCM_SVC_29_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service29_02Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service29_02Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  boolean        lIsReqLenValid = FALSE;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Check that request contains COCO(1Byte) and length field for client certificate */
  if(pMsgContext->reqDataLen > (1u + DCM_SVC29_REQ_LENGTH_FIELD_BYTELEN))
  {
    uint8  lCocoField;
    uint16 lClientCertLength;

    Dcm_UtiConsumeReqDataAsU8(pMsgContext, &lCocoField);                                                                                             /* SBSW_DCM_COMB_PTR_FORWARD */
    Dcm_UtiConsumeReqDataAsU16(pMsgContext, &lClientCertLength);                                                                                     /* SBSW_DCM_COMB_PTR_FORWARD */

    /* Check that request contains length field for client challenge */
    if( (lClientCertLength > 0u)
      &&(pMsgContext->reqDataLen > (lClientCertLength + DCM_SVC29_REQ_LENGTH_FIELD_BYTELEN)) )
    {
      uint16 lChallengeClientLength = Dcm_UtiGetReqDataAsU16Rel(pMsgContext, lClientCertLength);                                                     /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */

      /* Check if challenge client is valid and the request length is as expected */
      if( (lChallengeClientLength > 0u)
        &&(lChallengeClientLength <= DCM_AUTHMGR_CHALLENGE_MAX_SIZE)
        &&(pMsgContext->reqDataLen == (lClientCertLength + DCM_SVC29_REQ_LENGTH_FIELD_BYTELEN + lChallengeClientLength)) )
      {
        lIsReqLenValid = TRUE;

        /* Copy client challenge in the special buffer */
        Dcm_UtiMemCopySafe(Dcm_UtiGetReqDataRel(pMsgContext, lClientCertLength + DCM_SVC29_REQ_LENGTH_FIELD_BYTELEN)
                          ,Dcm_SingletonContext.Diag.Services.Svc29.ChallengeSwapBuffer
                          ,0
                          ,DCM_AUTHMGR_CHALLENGE_MAX_SIZE
                          ,lChallengeClientLength);                                                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */ /* SBSW_DCM_POINTER_WRITE_CHALLENGE_SWAP_BUFFER */

        Dcm_Svc29SetLengthChallengeSwapBuffer(lChallengeClientLength);

        /* If COCO field equals 0x00 start request processing */
        if (lCocoField == 0u)
        {
          uint16 lClientCertId = Dcm_CfgAuthMgrNetConnInfo[pContext->Repeater.Context.Svc29.AuthInfoHdl].ConnectionCertificateId;
          lStdResult = Dcm_Svc29CertificateStoreVerify(lClientCertId, lClientCertLength, pContext, pMsgContext, ErrorCode);                          /* SBSW_DCM_PARAM_PTR_FORWARD */
        }
        /* If COCO field doesnt equal 0x00 send NRC 0x31 and stop looping */
        else
        {
          *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdResult = DCM_E_NOT_OK;
        }
      }
    }
  }

  if(lIsReqLenValid == FALSE)
  {
    *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
  }

  return lStdResult;
}
# endif

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service29_03Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service29_03Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  boolean lIsReqLenValid = FALSE;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Check that request contains length field for proof of ownership */
  if(pMsgContext->reqDataLen > DCM_SVC29_REQ_LENGTH_FIELD_BYTELEN)
  {
    uint16 lProofOfOwnershipLength;
    Dcm_UtiConsumeReqDataAsU16(pMsgContext, &lProofOfOwnershipLength);                                                                               /* SBSW_DCM_COMB_PTR_FORWARD */

    /* Check that request contains length field for the ephemeral public key */
    if( (lProofOfOwnershipLength > 0u)
      &&(pMsgContext->reqDataLen == (lProofOfOwnershipLength + DCM_SVC29_REQ_LENGTH_FIELD_BYTELEN)) )
    {
      uint16 lLengthEPK = Dcm_UtiGetReqDataAsU16Rel(pMsgContext, lProofOfOwnershipLength);                                                           /* PRQA S 2985 */ /* MD_Dcm_Redundant_2985 */

      /* Only an ephemeral public key length of 0 is supported */
      if(lLengthEPK == 0u)
      {
        lIsReqLenValid = TRUE;
        lStdResult = Dcm_Svc29VerifySignature(lProofOfOwnershipLength, pContext, pMsgContext, ErrorCode);                                            /* SBSW_DCM_PARAM_PTR_FORWARD */
      }
    }
  }

  if(lIsReqLenValid == FALSE)
  {
    *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
  }

  return lStdResult;
}
# endif

# if (DCM_SVC_29_04_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service29_04Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service29_04Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType  lStdResult = DCM_E_NOT_OK;
  boolean         lIsReqLenValid = FALSE;
  boolean         lIsCertificateEvaluationIdValid = FALSE;
  uint16          lClientCertLength = 0;
  uint16          lClientCertIdIdx = 0;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  if (pMsgContext->reqDataLen >= (5u))
  {
    uint16        lCertificateEvaluationId = 0;
    sint16_least  lResult;

    Dcm_UtiConsumeReqDataAsU16(pMsgContext, &lCertificateEvaluationId);                                                                              /* SBSW_DCM_COMB_PTR_FORWARD */
    Dcm_UtiConsumeReqDataAsU16(pMsgContext, &lClientCertLength);                                                                                     /* SBSW_DCM_COMB_PTR_FORWARD */

    /* Check that request contains supported certificateEvaluationId(2Byte) */
    lResult = Dcm_UtiLookUpUint16(Dcm_CfgAuthMgrEvaluationIdLookUpTable, lCertificateEvaluationId);                                                  /* SBSW_DCM_POINTER_FORWARD_GLOBAL */

    if (lResult >= 0)
    {
      lClientCertIdIdx = (uint16)lResult;
      lIsCertificateEvaluationIdValid = TRUE;                                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    }

    /* Check that request contains complete certificate */
    if (pMsgContext->reqDataLen == lClientCertLength)
    {
      lIsReqLenValid = TRUE;
    }
  }

  if (lIsReqLenValid == FALSE)
  {
    *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else if (lIsCertificateEvaluationIdValid == FALSE)
  {
    *ErrorCode = DCM_E_REQUESTOUTOFRANGE;                                                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */
  }
  else
  {
    uint16 lClientCertId = Dcm_CfgAuthMgrTransmitCertificateInfo[lClientCertIdIdx];
    lStdResult = Dcm_Svc29CertificateStoreVerify(lClientCertId, lClientCertLength, pContext, pMsgContext, ErrorCode);                                /* SBSW_DCM_PARAM_PTR_FORWARD */
  }

  return lStdResult;
}
# endif

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service29_08Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service29_08Processor(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode                                                                                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(ErrorCode);                                                                                                                 /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Set the authenticationReturnParameter of the response to Authentication Configuration APCE */
  Dcm_UtiProvideResDataAsU8(pMsgContext, DCM_SVC29_AUTH_CONFIG_APCE);                                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */

  return DCM_E_OK;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Service29Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service29Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;
  Dcm_Svc29RepeaterProxyContextPtrType pRepContext = &pContext->Repeater.Context.Svc29;

  /* Proccess according to stage */
  switch (Dcm_RepeaterGetProgress(pContext))
  {
    /* Verifies subfunction validity e.g length and sequence */
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc29Handler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
    /* Calls initial subfunction processor function */
  case DCM_SVC29_PROGRESS_SUBFUNCTION:
    lStdResult = Dcm_Svc29SubFuncHandler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                   /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# if (DCM_SVC_29_APCE_INTERNAL == STD_ON) || (DCM_SVC_29_04_SUPPORT_ENABLED == STD_ON)
    /* Evaluates certificate verification result if positive starts challenge generation common to 0x01 and 0x02 */
  case DCM_SVC29_PROGRESS_CERTVERIFIED:
    lStdResult = Dcm_Svc29CertificateVerificationDoneHandler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                               /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
    /* Evaluate challenge generation result if positive starts signing of client challenge for subfunction 0x02 */
  case DCM_SVC29_PROGRESS_CHALLENGEGEN:
    lStdResult = Dcm_Svc29ChallengeGenerationDoneHandler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                   /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
#  if (DCM_SVC_29_02_SUPPORT_ENABLED == STD_ON)
    /* Evaluates challenge signing result if positive sends response for subfunction 0x02 */
  case DCM_SVC29_PROGRESS_SUBFUNC02_CHALLENGESIGNED:
    lStdResult = Dcm_Svc29_02ChallengeSigningDoneHandler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                   /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
#  endif
  case DCM_SVC29_PROGRESS_SUBFUNC03_ROLEREAD:
    lStdResult = Dcm_Svc29_03RoleRead(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                      /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC29_PROGRESS_SUBFUNC03_SERVICEWHITELISTREAD:
    lStdResult = Dcm_Svc29_03ServiceWL(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                     /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC29_PROGRESS_SUBFUNC03_DIDWHITELISTREAD:
    lStdResult = Dcm_Svc29_03DidWL(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC29_PROGRESS_SUBFUNC03_RIDWHITELISTREAD:
    lStdResult = Dcm_Svc29_03RidWL(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC29_PROGRESS_SUBFUNC03_MEMWHITELISTREAD:
    lStdResult = Dcm_Svc29_03MemWL(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                         /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC29_PROGRESS_PERSIST_AUTHENTICATION:
    lStdResult = Dcm_Svc29_03PersistAuthentication(opStatus, pMsgContext, ErrorCode, pRepContext);                                                   /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
    /* On pending stages just loop */
  case DCM_SVC29_PROGRESS_SUBFUNC03_WAITSIGVERIFY:
  case DCM_SVC29_PROGRESS_WAITCHALLENGEGEN:
#  if (DCM_SVC_29_02_SUPPORT_ENABLED == STD_ON)
  case DCM_SVC29_PROGRESS_SUBFUNC02_WAITCHALLENGESIGNED:
#  endif
# endif
# if (DCM_SVC_29_APCE_INTERNAL == STD_ON) || (DCM_SVC_29_04_SUPPORT_ENABLED == STD_ON)
  case DCM_SVC29_PROGRESS_WAITCERTVERIFY:
    lStdResult = Dcm_Svc29CbkResultDispatcher(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                              /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
# endif
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);
    break;
  }

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
  /* If processing result is a fail */
  if(lStdResult == DCM_E_NOT_OK)
  {
    /* Check if NRC is a Certificate Verification Failed NRC and change to General NRC if mode rule allows it */
    Dcm_Svc29GeneralNrcCheck(pContext, ErrorCode);                                                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
  }
# endif
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6030, 6050 */ /* MD_MSR_STCYC, MD_MSR_STCAL */

/**********************************************************************************************************************
 *  Dcm_Service29PostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service29PostProcessor(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_ConfirmationStatusType status
  )
{
  Dcm_Svc29RepeaterProxyContextConstPtrType pRepContext = &pContext->Repeater.Context.Svc29;

 /* If a positive response was successfully sent */
  if(status == DCM_RES_POS_OK)
  {
    /* If it was a unidirectional or bidirectional verify request: */
    if( (pRepContext->SubSvcId == DCM_SVC29_SUBFUNC_VERIFY_CERT_UNIDIR)
      ||(pRepContext->SubSvcId == DCM_SVC29_SUBFUNC_VERIFY_CERT_BIDIR) )
    {
      /* Set sequence flag for request 0x03 */
      Dcm_Svc29SetOwnershipRequestExpected();
    }
  }
  else if((DCM_DIAG_RES_NEG_ANY & status) != 0u) /* Otherwise, if any negative response was sent: */
  {
    /* Reset the sequence */
    Dcm_Svc29ResetSequence();
  }
  else /* POS_NOK */
  {
    /* Otherwise no change required */
  }

# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
  /* Only set state back to idle if request processing is not cancelled */
  if( (!Dcm_Svc29IsCbkStateActive(DCM_SVC29_CBK_PROC_STATE_CSM_CANCELLED))
    &&(!Dcm_Svc29IsCbkStateActive(DCM_SVC29_CBK_PROC_STATE_KEYM_CANCELLED)) )
  {
    /* Set callback processing state to idle */
    Dcm_Svc29SetCbkProcessingState(DCM_SVC29_CBK_PROC_STATE_IDLE);
  }
# endif
}

/**********************************************************************************************************************
 *  Dcm_Service29Cancel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CODE) Dcm_Service29Cancel(
  Dcm_ContextPtrType pContext                                                                                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
# if (DCM_SVC_29_APCE_INTERNAL == STD_ON)
  Std_ReturnType lStdResult = DCM_E_OK;

  if(Dcm_Svc29IsAsyncCsmJobActive())
  {
    lStdResult = Csm_CancelJob(Dcm_Svc29GetPendingCsmJobId(), CRYPTO_OPERATIONMODE_SINGLECALL);
  }

  Dcm_UtiEnterCriticalSection();
  /*=================================*
  BEGIN CRITICAL SECTION
  *=================================*/
  if(lStdResult == DCM_E_OK)
  {
    if(Dcm_Svc29IsAsyncKeyMJobActive())
    {
      /* No user to the buffer needs to be added, since buffer is not locked by KeyM */
      Dcm_Svc29SetCbkProcessingState(DCM_SVC29_CBK_PROC_STATE_KEYM_CANCELLED);
    }
    else
    {
      /* Csm job is cancelled, reset the callback processing state to idle */
      Dcm_Svc29SetCbkProcessingState(DCM_SVC29_CBK_PROC_STATE_IDLE);
    }
  }
  else
  {
    /* Recheck if any Csm job is still active to assure that the callback is not triggered in the meantime */
    if(Dcm_Svc29IsAsyncCsmJobActive())
    {
      /* Cancellation of Csm job not possible, wait for callback */
      Dcm_Svc29SetCbkProcessingState(DCM_SVC29_CBK_PROC_STATE_CSM_CANCELLED);
      /* Add service 0x29 as user of the buffer to prevent releasing of the buffer since asynchronous Csm job has still locked the buffer */
      Dcm_NetBufferUsageEnter(Dcm_NetGetBufferContext(Dcm_Svc29GetBufferHdl()));                                                                     /* PRQA S 2840, 3387 */ /* MD_Dcm_DerefInvalidPointer, MD_Dcm_OptimizedInlineCode_3387 */ /* SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT */
    }
    else
    {
      /* Callback is triggered in the meantime, reset the callback processing state to idle */
      Dcm_Svc29SetCbkProcessingState(DCM_SVC29_CBK_PROC_STATE_IDLE);
    }
  }
  /*=================================*
  END CRITICAL SECTION
  *=================================*/
  Dcm_UtiLeaveCriticalSection();
# endif
  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  /* Reset request sequence */
  Dcm_Svc29ResetSequence();
}
#endif /* (DCM_SVC_29_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service2AProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2AProcessor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  Dcm_Svc2ARepeaterProxyContextPtrType pRepContext = &pContext->Repeater.Context.Svc2A;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc2AHandler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC2A_PROGRESS_SCHEDULEDDID_LOOKUP:
    lStdResult = Dcm_Svc2AScheduledDidLookUp(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                               /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC2A_PROGRESS_DID_CHECKCONDITION:
    lStdResult = Dcm_Svc2ADidCheckCondition(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC2A_PROGRESS_DID_GETLENGTH:
    lStdResult = Dcm_Svc2ADidGetLength(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                     /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC2A_PROGRESS_STOPPED_DID_LOOKUP:
    lStdResult = Dcm_Svc2AStoppedDidLookUp(opStatus, pMsgContext, ErrorCode, pRepContext);                                                           /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);
    break;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service2APostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service2APostProcessor(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  Dcm_ConfirmationStatusType status
  )
{
  if(pContext->Repeater.Context.Svc2A.UdsRate != DCM_SVC_2A_STOP_SENDING)
  {
    if(status == DCM_RES_POS_OK)
    {
      Dcm_Svc2ASchdCommit(Dcm_Svc2AMakeSchdRateFromUdsRate(pContext->Repeater.Context.Svc2A.UdsRate));
      Dcm_NetPeriodicMsgSetConnection(pContext->Repeater.Context.Svc2A.ConnHdl);
      Dcm_NetPeriodicMsgSetClientSrcAddr(Dcm_DiagGetTranspObj(pContext)->ClientSrcAddr);
    }
    else
    {
      Dcm_Svc2ASchdDiscard();
    }
  }/* else - nothing */
}
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service2C_01Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2C_01Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdReturn;

  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext = &pContext->Repeater.Context.Svc2C;

  lStdReturn = Dcm_Svc2CParseAndCheckDynDid(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lStdReturn == DCM_E_OK)
  {
    /* there shall be an iteration (+[4Byte]) */
    if( (pMsgContext->reqDataLen > 0u)
      &&( (pMsgContext->reqDataLen % 4u) == 0u) )
    {
      Dcm_MsgLenType lNumReqItems = pMsgContext->reqDataLen / 4u; /* calculate number of source items to be processed */

      /* check DynDID capacity */
      lStdReturn = Dcm_Svc2CCheckAndSetNumOfItems(lNumReqItems, ErrorCode, pRepContext);                                                             /* SBSW_DCM_PARAM_PTR_FORWARD */
      if(lStdReturn == DCM_E_OK)
      {
        Dcm_RepeaterNextStep(pContext, DCM_SVC2C_PROGRESS_01SRC_DIDLOOKUP);                                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
        lStdReturn = DCM_E_LOOP; /* speed up processing */
      } /* else - Nrc and return value already set */
    }
    else
    {
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK;
    }
  } /* else - just return the value: DCM_E_PENDING, DCM_E_NOT_OK (ErrorCode already set) */

  return lStdReturn;
}
# endif

# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service2C_02Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2C_02Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdReturn;
  uint8          lAlfid;
  uint8          lBlockLength;

  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext = &pContext->Repeater.Context.Svc2C;

  lStdReturn = Dcm_Svc2CParseAndCheckDynDid(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                /* SBSW_DCM_PARAM_PTR_FORWARD */

  if(lStdReturn == DCM_E_OK)
  {
    /* Check, whether the ALFID is available */
    if (pMsgContext->reqDataLen != 0u)
    {
      /* the ALFID availability is checked within next call */
      lStdReturn = Dcm_MemMgrValidateAndGetAlfid(pMsgContext, &lAlfid, &lBlockLength, ErrorCode);                                                    /* SBSW_DCM_PARAM_PTR_FORWARD */
      if (lStdReturn == DCM_E_OK)
      {
        /* pMsgContext->reqDataLen cannot be zero! */
        if((pMsgContext->reqDataLen % lBlockLength) == 0u) /* the remained request length shall be a multiple of the memory address and size request block */
        {
          Dcm_MsgLenType lNumReqItems = pMsgContext->reqDataLen / lBlockLength; /* calculate number of source items to be processed */

          /* check DynDID capacity */
          lStdReturn = Dcm_Svc2CCheckAndSetNumOfItems(lNumReqItems, ErrorCode, pRepContext);                                                         /* SBSW_DCM_PARAM_PTR_FORWARD */
          if (lStdReturn == DCM_E_OK)
          {
            lStdReturn = Dcm_Svc2C02SrcItemsGetLength(lAlfid, pMsgContext, ErrorCode, pRepContext);                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
          } /* else - ErrorCode and return value already set */
        }
        else
        {
          /* else - ErrorCode set to 0x13 */
          *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                  /* SBSW_DCM_PARAM_PTR_WRITE */
          lStdReturn = DCM_E_NOT_OK;
        }
      } /* else - DCM_E_NOT_OK (ErrorCode already set) */
    }
    else
    {
      *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                      /* SBSW_DCM_PARAM_PTR_WRITE */
      lStdReturn = DCM_E_NOT_OK;
    }
  } /* else - DCM_E_NOT_OK (ErrorCode already set) */

  return lStdReturn;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_SVC_2C_03_SUPPORT_ENABLED == STD_ON)                                                                                                       /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_Service2C_03Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2C_03Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,                                                                                                                 /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdReturn;

  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext = &pContext->Repeater.Context.Svc2C;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  pRepContext->DynDidItemCount = 0u; /* prepare for a successful clear */                                                                            /* SBSW_DCM_PARAM_PTR_WRITE */

  if(pMsgContext->reqDataLen == 0u)
  {
    /* clear all DynDID definitions */
    Dcm_CfgDidMgrDynDidHandleOptType dynDidIter;
    for(dynDidIter = 0; dynDidIter < DCM_NUM_DYNDIDS; ++dynDidIter)
    {
      Dcm_Svc2CDefMgrClear((Dcm_CfgDidMgrDynDidHandleMemType)dynDidIter);
    }
    lStdReturn = DCM_E_OK;
  }
  else if (pMsgContext->reqDataLen == 2u)
  {
    Dcm_RepeaterNextStep(pContext, DCM_SVC2C_PROGRESS_03_DIDLOOKUP); /* next job */                                                                  /* SBSW_DCM_PARAM_PTR_FORWARD */
    lStdReturn = DCM_E_LOOP; /* speed up processing */
  }
  else
  {
    *ErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;                                                                                        /* SBSW_DCM_PARAM_PTR_WRITE */
    lStdReturn = DCM_E_NOT_OK;
  }
  return lStdReturn;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Service2CProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2CProcessor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  Dcm_Svc2CRepeaterProxyContextPtrType pRepContext = &pContext->Repeater.Context.Svc2C;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc2CHandler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_SVC2C_PROGRESS_SUBFUNCTION:
    lStdResult = Dcm_Svc2CSubFuncHandler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
  case DCM_SVC2C_PROGRESS_01SRC_DIDLOOKUP:
    lStdResult = Dcm_Svc2C01SrcDidLookUp(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_SVC2C_PROGRESS_01SRC_DIDCHECKCONDITIONS:
    lStdResult = Dcm_Svc2C01SrcDidCheckCondition(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                           /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_SVC2C_PROGRESS_01SRC_DIDGETLENGTH:
    lStdResult = Dcm_Svc2C01SrcDidGetLength(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
# endif
# if (DCM_SVC_2C_03_SUPPORT_ENABLED == STD_ON)                                                                                                       /* COV_DCM_SUPPORT_ALWAYS TX */
  case DCM_SVC2C_PROGRESS_03_DIDLOOKUP:
    lStdResult = Dcm_Svc2C03DidLookUp(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
# endif
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);
    break;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service2CPostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service2CPostProcessor(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  Dcm_ConfirmationStatusType status
  )
{
  if(status == DCM_RES_POS_OK)
  {
    Dcm_Svc2CRepeaterProxyContextConstPtrType pRepContext = &pContext->Repeater.Context.Svc2C;

    if(pRepContext->DynDidItemCount != 0u) /* this is a definition service , not the clear one */
    {
      Dcm_Svc2CDynDidItemPtrType pItem;

# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
      uint16 lDid = Dcm_DidMgrGetDynDidIdFromHandle(pRepContext->DynDidHandle);
      /* Kill any still not finished read periodic DID jobs to avoid inconsistent response data/length ! */
      Dcm_Svc2ASchdCancelReadByDid(lDid);
# endif
      /* Commit DynDID definition immediately */
      pItem = Dcm_Svc2CGetItem(pRepContext->DynDidHandle);
      pItem->Length = pRepContext->DynDidLength;                                                                                                     /* SBSW_DCM_POINTER_WRITE_2CITEM */
      pItem->Count  = pRepContext->DynDidItemCount;                                                                                                  /* SBSW_DCM_POINTER_WRITE_2CITEM */
    } /* else - the dynDid has been already cleared */

# if (DCM_SVC_2C_NVRAM_SUPPORT_ENABLED == STD_ON)
    Dcm_UtiNvMSetRamBlockStatus((uint16)DCM_SVC_2C_NVRAM_BLOCKID);
# endif
  } /* else - the dynDid list properties will not be changed - all prepared data will be discarded */
}
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service2EProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2EProcessor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  Dcm_Svc2ERepeaterProxyContextPtrType pRepContext = &pContext->Repeater.Context.Svc2E;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc2EHandler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC2E_PROGRESS_CHECKACCESS:
    lStdResult = Dcm_Svc2ECheckAccess(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                      /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC2E_PROGRESS_WRITEDATA:
    lStdResult = Dcm_Svc2EWriteData(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                  /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);
    break;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service2ECancel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service2ECancel(
  Dcm_ContextPtrType pContext                                                                                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  Dcm_RsrcMgrReleaseDidLock(DCM_RSRCMGR_DIDLOCK_OWNER_SID2E);
}
#endif /* (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service2FProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2FProcessor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  Dcm_Svc2FRepeaterProxyContextPtrType pRepContext = &pContext->Repeater.Context.Svc2F;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc2FHandler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_SVC2F_PROGRESS_CHECKACCESS:
    lStdResult = Dcm_Svc2FCheckAccess(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                      /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_SVC2F_PROGRESS_EXECUTEOP:
    lStdResult = Dcm_Svc2FExecuteOp(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_SVC2F_PROGRESS_GETLENGTH:
    lStdResult = Dcm_Svc2FGetLength(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                        /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  case DCM_SVC2F_PROGRESS_READDATA:
    lStdResult = Dcm_Svc2FReadData(opStatus, pMsgContext, ErrorCode, pRepContext);                                                                   /* SBSW_DCM_PARAM_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);
    break;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service2FPostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service2FPostProcessor(
  Dcm_ContextPtrType pContext,                                                                                                                       /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
  Dcm_ConfirmationStatusType status
  )
{
  DCM_IGNORE_UNREF_PARAM(status);                                                                                                                    /* PRQA S 3112 */ /* MD_MSR_DummyStmt */
  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  Dcm_RsrcMgrReleaseDidLock(DCM_RSRCMGR_DIDLOCK_OWNER_SID2F);
}

/**********************************************************************************************************************
 *  Dcm_Service2FCancel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service2FCancel(
  Dcm_ContextPtrType pContext                                                                                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
  )
{
  DCM_IGNORE_UNREF_PARAM(pContext);                                                                                                                  /* PRQA S 3112 */ /* MD_MSR_DummyStmt */

  Dcm_RsrcMgrReleaseDidLock(DCM_RSRCMGR_DIDLOCK_OWNER_SID2F);
}
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service86Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service86Processor(
  Dcm_ContextPtrType pContext,
  Dcm_OpStatusType opStatus,
  Dcm_MsgContextPtrType pMsgContext,
  Dcm_NegativeResponseCodePtrType ErrorCode
  )
{
  Std_ReturnType lStdResult;

  Dcm_Svc86RepeaterProxyContextPtrType pRepContext = &pContext->Repeater.Context.Svc86;

  switch (Dcm_RepeaterGetProgress(pContext))
  {
  case DCM_REPEATER_PROGRESS_INITIAL:
    lStdResult = Dcm_Svc86Handler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                          /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  case DCM_SVC86_PROGRESS_SUBFUNCTION:
    lStdResult = Dcm_Svc86SubFuncHandler(pContext, opStatus, pMsgContext, ErrorCode, pRepContext);                                                   /* SBSW_DCM_COMB_PTR_FORWARD */
    break;
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE X */
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_PANIC_NRC;                                                                                                                    /* SBSW_DCM_PARAM_PTR_WRITE */
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE);
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CALLOUT_CODE
#include "Dcm_MemMap.h"                                                                                                                              /* PRQA S 5087 */ /* MD_MSR_MemMap */

/**********************************************************************************************************************
 *  COMPONENT DETAILED DESIGN OF GENERATED FUNCTIONS
 *********************************************************************************************************************/
/**********************************************************************************************************************
 *  Dcm_Cfg<Unit>Get<XXX>()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/**********************************************************************************************************************
 *  Dcm_ModeRule<XXX>()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_ModeCondGet_<XXX>()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_ModeOnComControlModeChange()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/**********************************************************************************************************************
 *  Dcm_DidMgr<XXX>ReadData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_DidMgr<DynDID>Read<XXX>()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_DidMgr<XXX>WriteData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_DidMgr<OBD_AID>ReadData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_DidMgr<MID>ReadData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_DidMgr_<Data>_Write_IOControlRequest_ControlState()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_DidMgr_DeadEnd_Write_IOControlRequest_ControlState()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_DidMgr_<Data>_Write_IOControlRequest_IOOperationRequest()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_DidMgr_<Data>_Read_IOControlRequest_UnderControl()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_DidMgr_<Data>_Write_IOControlRequest_UnderControl()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_DidMgr_<DID>_IoControlOperation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_DidMgr_<DID>_ReturnControlToECU()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_DidMgr_<SupportedID>_ReadData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_DidMgr_<SupportedID>_ReadDataLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_DidMgr<NvMDID>Read()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_DidMgr<NvMDID>Write()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_DidMgr<Internal>ReadData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/**********************************************************************************************************************
 *  Dcm_RidMgr<XXX>()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_RidMgr_<XXX>_OBD_AID()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_RidMgr_<XXX>_OBD_TID()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/**********************************************************************************************************************
 *  Dcm_SvcWrapper_<XXX>()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_SubSvcWrapper_<XXX>()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_ServiceNoPostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_ServiceNoUpdater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_ServiceNoCancel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
/**********************************************************************************************************************
 *  Dcm_Svc27_Dummy_GetSecurityAttemptCounter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */

/**********************************************************************************************************************
 *  Dcm_Svc27_Dummy_SetSecurityAttemptCounter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
/**********************************************************************************************************************
 *  MISRA JUSTIFICATIONS
 *********************************************************************************************************************/
/* Following markers are only used in generated or extension files, thus "unused marker" warnings can be ignored.*/
                                                                                                                                                     /* PRQA S 0310 */ /* MD_Dcm_DifferentPointerType_0310 */
                                                                                                                                                     /* PRQA S 2982 */ /* MD_Dcm_Redundant_2982 */
                                                                                                                                                     /* PRQA S 1330 */ /* MD_Dcm_RteSpecific_1330 */
                                                                                                                                                     /* PRQA S 1514 */ /* MD_Dcm_ObjectOnlyAccessedOnce */
                                                                                                                                                     /* PRQA S 0612 */ /* MD_Dcm_0612 */

                                                                                                                                                     /* module specific MISRA deviations:

   MD_Dcm_DifferentPointerType_0310:
     Description: Rule 11.3
                  A cast shall not be performed between a pointer to object type and a pointer to a different object type.
     Reason:      To optimize access without the need of local variable, pointers to data types of the same size (uint8, sint8)
                  will be casted to the corresponding target pointer type.
     Risk:        Compile error/warnings.
     Prevention:  Compiler compatibility is tested during integration.

   MD_Dcm_0313:
     Description: Rule 11.1
                  Conversions shall not be performed between a pointer to a function and any other type.
     Reason:      No efficient dynamic-cast operation available in ANSI-C.
     Risk:        Data corruption due to miscast.
     Prevention:  Covered by descriptive pointer types and code review for correct usage.

   MD_Dcm_Rule19.2:
     Description: Rule 19.2
                  The union keyword should not be used.
     Reason:      Data without shared lifetime is stored in union for efficiency.
     Risk:        None due to no shared lifetime.
     Prevention:  None.

   MD_Dcm_Optimize_0771:
     Description: Rule 15.4
                  There should be no more than one break or goto statement used to terminate any iteration statement.
     Reason:      The loop needs multiple exit points since error conditions cannot be verified prior to the loop.
     Risk:        None.
     Prevention:  None.

   MD_Dcm_Rule1.2_1039:
    Description: Rule 1.2
                 Treating array of length one as potentially flexible member.
    Reason:      In a special configurations, a struct type has only one memeber of an array type with a size of one.
    Risk:        Some compilers would consider the array as a flexible memeber.
    Prevention:  Testing the code under several compilers.

   MD_Dcm_RteSpecific_1330:
     Description: Rule 8.3
                  All declarations of an object or function shall use the same names and type qualifiers.
     Reason:      The function declaration generated by the RTE are RTE-implementation specific and unknown at
                  the DCM development time.
     Risk:        None.
     Prevention:  None.

   MD_Dcm_ObjectOnlyAccessedOnce:
    Description: Rule 8.9
                 An object should be defined at block scope if its identifier only appears in a single function.
    Reason:      Autosar rules or OEM requirements mandate this implementation.
    Risk:        None.
    Prevention : None.

   MD_Dcm_Optimize_2003:
     Description: Rule 16.3
                  An unconditional break statement shall terminate every switch-clause Enforcement.
     Reason:      To use optimal design small switch-case dispatchers use fall-through cases.
     Risk:        None, since documented as an explicit fall-through case.
     Prevention:  None.

   MD_Dcm_Redundant_2982:
    Description: Rule 2.2
                 This assignment is redundant. The value of this object is never used before being modified.
    Reason:      Initializing global variables.
    Risk:        None.
    Prevention:  None.

   MD_Dcm_Redundant_2983:
    Description: Rule 2.2
                 This assignment is redundant. The value of this object is never subsequently used.
    Reason:      In the last iteration of an iterative structure, a statement might be executed but not used.
    Risk:        None.
    Prevention:  None.

   MD_Dcm_Redundant_2985:
    Description: Rule 2.2
                 This operation is redundant. The value of the result is always that of the left-hand operand.
    Reason:      Apparent redundant-like operations are needed for better code readability.
    Risk:        None.
    Prevention:  None.

   MD_Dcm_Redundant_2986:
    Description: Rule 2.2
                 This operation is redundant. The value of the result is always that of the right-hand operand.
    Reason:      Apparent redundant-like operations are needed for better code readability.
    Risk:        None.
    Prevention:  None.

   MD_Dcm_Optimize_2889:
     Description: Rule 15.5
                  A function should have a single point of exit at the end.
     Reason:      For code run-time/ROM usage reason this function terminates immediately.
     Risk:        None.
     Prevention:  None.

   MD_Dcm_ConstExpr:
    Description: Rule 2.2
                 Controlling expressions shall not be invariant.
    Reason:      A configuration dependent situation could lead to a constant logical expression.
    Risk:        None.
    Prevention:  None.

   MD_Dcm_CodingRule_3218:
     Description: Rule 8.9
                  An object should be defined at block scope if its identifier only appears in a single function.
     Reason:      Vector style guide prevents usage of static variables/constant objects in function scope.
     Risk:        None.
     Prevention:  None.

   MD_Dcm_Rule13.5:
     Description: Rule 13.5
                  The right hand operand of a logical && or || operator shall not contain persistent side effects.
     Reason:      The function called on the right hand side has no side effects.
     Risk:        The function may introduce side effects at a later time.
     Prevention:  None.

   MD_Dcm_UnknownSize_3684:
     Description: Rule 8.11
                  When an array with external linkage is declared, its size should be explicitly specified.
     Reason:      Array declared with unknown size to reduce number of variants and therefore complexity.
                  The user of that array does not need the size of the array.
     Risk:        None.
     Prevention:  None.

   MD_Dcm_APIStd_3673:
     Description: Rule 8.13
                  A pointer should point to a const-qualified type whenever possible.
     Reason:      The API is defined by the AUTOSAR standardization.
     Risk:        None.
     Prevention:  None.

   MD_Dcm_Design_3673:
     Description: Rule 8.13
                  A pointer should point to a const-qualified type whenever possible.
     Reason:      The API has to be compatible to a common prototype, defined by module's design to serve generic purposes.
     Risk:        None.
     Prevention:  None.

   MD_Dcm_BitNegation_4399:
     Description: Rule 10.8
                  An expression which is the result of a ~ or << operation has been cast to a wider type.
     Reason:      Using the ~ operator avoids errors in manually typed bit masks.
     Risk:        May generate compiler warnings although explicit casts are used.
     Prevention:  None.

   MD_Dcm_2987:
     Description: Rule 2.2
                  This function call produces no side effects and is redundant.
     Reason:      The functions produces side effects, but only in specific configurations.
     Risk:        None.
     Prevention:  None.

  MD_Dcm_RetVal:
     Description: Rule 2.2
                  This initialization is redundant. The value of this object is never used before being modified.
     Reason:      Without this initialization some not so smart compilers will erroneously complain about use of uninitialized variable.
     Risk:        The redundant initialization code might be confusing.
     Prevention:  None.

  MD_Dcm_0612:
     Description: Rule 1.1
                  Size of object exceeds 32767 bytes - program does not conform strictly to ISO:C90.
     Reason:      A DCM buffer was configured with a size greater than 32767 bytes.
     Risk:        Decreased code portability.
     Prevention:  None.

  MD_Dcm_DerefInvalidPointer:
     Description: Rule 18.1
                  Dereference of an invalid pointer value.
     Reason:      This is a false positive and a known PRQA issue.
     Risk:        None.
     Prevention:  None.

  MD_Dcm_ComputingInvalidPointer:
     Description: Rule 18.1
                  Computing an invalid pointer value.
     Reason:      This is a false positive and a known PRQA issue.
     Risk:        None.
     Prevention:  None.

  MD_Dcm_8.5_Rte:
     Description: Rule 8.5
                  Multiple declarations of external object or function.
     Reason:      MICROSAR Rte generates prototypes for callbacks. Some callbacks are also contained in a replacement
                  header in case no Rte is used. This leads to duplicate definitions.
     Risk:        None.
     Prevention:  None.

  MD_Dcm_OptimizedInlineCode_3387:
     Description: Rule 13.3
                  A full expression containing an increment (++) or decrement (--) operator should have no other
                  potential side effects other than that caused by the increment or decrement operator
     Reason:      This kind of operator is used only in case of function-like macros where also a return value is expected.
                  Needed for maximum inlining efficiency and less other MISRA deviations.
     Risk:        The risks are at minimum since the affected locations are simple expressions.
     Prevention:  These code sections are thoroughly tested by dedicated unit tests.

  MD_Dcm_Design_3679:
     Description: Rule 8.13
                  The object referenced is not modified through it, so the object could be declared with type const*.
     Reason:      The API has to be compatible to a common prototype, defined by module's design to serve generic purposes.
     Risk:        None.
     Prevention:  None.
     
  MD_Dcm_2962:
     Description: Rule 9.1
                  The value of an object with automatic storage duration shall not be read before it has been set.
     Reason:      The variable is initialized in a function call before the variable is used. It is ensured that the variable
                  is initialized in the function call, because a check whether the DID exists is already done earlier. 
     Risk:        None.
     Prevention:  None.

  MD_Dcm_2822:
     Description: Rule 21.1
                  Arithmetic operation on NULL pointer.
     Reason:      This is a false positive.
     Risk:        None.
     Prevention:  None.
     
*/
/**********************************************************************************************************************
 *  COVERAGE JUSTIFICATIONS
 *********************************************************************************************************************/
/* COV_JUSTIFICATION_BEGIN

\ID COV_DCM_MACRO_OVERRIDE
  \ACCEPT TX
  \ACCEPT XF
  \REASON The value of a macro may be overridden by user config for test purposes. Since this is not officially
          supported, it is not covered by the test suite.

\ID COV_DCM_UNSUPPORTED
  \REASON [COV_MSR_UNSUPPORTED]

\ID COV_DCM_SUPPORT_PARTIALLY
  \REASON [COV_MSR_UNSUPPORTED]

\ID COV_DCM_SUPPORT_ALWAYS
  \REASON This configuration switch is always on, but the code is enclosed in a pre-processor precondition for consistency reasons and safe future changes.

\ID COV_DCM_SUPPORT_RESTRICTED
  \REASON This configuration switch is always on/off, due to feature range limitation.

\ID COV_DCM_SUPPORT_XOR
  \REASON Disjunction of configuration switches that are mutually exclusive and one of them is always true.

\ID COV_DCM_SUPPORT_WITH_MSR_DEM
  \REASON This configuration switch is always on as long as MSR4 DEM is used (required for SafeBSW context).

\ID COV_DCM_REQUIRED_BY_SAFEBSW
  \REASON This configuration switch is always on as required by SafeBSW context.

\ID COV_DCM_DEPENDS_ON_UNSUPPORTED
  \REASON This configuration switch is always on/off due to a justified expression it is involved in.

\ID COV_DCM_DEV_DEBUG
  \REASON The justified object is uncovered, since it is only used during component development to ease the detection of errors!

\ID COV_DCM_UNSUPPORTED_ERROR_DETECTION
  \REASON The justified object is uncovered, since it is only used to ease the detection of configuration errors!

\ID COV_DCM_NOUNIT
  \REASON The justified object is always undefined, since it is only used during component unit testing.

\ID COV_DCM_RTM_NO_RCR_RP_TX
  \ACCEPT XX
  \REASON The justified object is unreachable, since the configuration does not support any feature that could use it.
          A complete encapsulation of all use-cases where no RCR-RP will be sent would be too complex and risky.

\ID COV_DCM_RTM_DEV_DEBUG
  \REASON [COV_DCM_DEV_DEBUG]

\ID COV_DCM_RTM_UNREACHABLE
  \REASON The justified object is uncovered, since it is not intended to be reached! It just exists because of other reasons like MISRA (default case in a switch)
          or because of added debug assert monitoring for development purposes (see COV_DCM_RTM_DEV_DEBUG).

\ID COV_DCM_RTM_UNREACHABLE_COMPLEXITY
  \REASON The justified object is uncovered, since it can be reached only in very rare situations (i.e. interrupt, multiple events in a specific sequence, etc.)!
          But at the same time it is part of the (sub-)component design and cannot be removed.

\ID COV_DCM_RTM_DESIGN_LOWER_LAYER
  \REASON The justified object is uncovered, since it is a basic (lower layer) functionality and is designed to behave in different situations.
          These situations are not necessarily supported by all configurations. Due to the high complexity of dependent functionalities
          the concrete usage of the uncovered functionality is left to the upper layers in DCM!

\ID COV_DCM_RTM_RUNTIME_CHECK
  \REASON This condition depends on a runtime check for an uninitialized pointer or remaining buffer size check.

\ID COV_DCM_RTM_DEPENDS_ON_UNSUPPORTED
  \REASON The justified object is uncovered, since it can vary only if a specific (non supported in SafeBSW context) configuration is activated.

\ID COV_DCM_RTM_DEPENDS_ON_CFG
  \ACCEPT TX
  \ACCEPT XF
  \REASON The justified expression evaluates always depending on the configuration either to true or false.

\ID COV_DCM_RTM_UNIT_TEST
  \REASON This condition is covered on unit test level.

COV_JUSTIFICATION_END */
/**********************************************************************************************************************
 *  SILENTBSW JUSTIFICATIONS
 *********************************************************************************************************************/
/* SBSW_JUSTIFICATION_BEGIN

\ID SBSW_DCM_PARAM_PTR_WRITE
  \DESCRIPTION    In a function, data is written through a pointer passed as function argument.
  \COUNTERMEASURE \N [CM_DCM_N_PASS_PARAM_PTR]

\ID SBSW_DCM_LOCAL_ARRAY_WRITE
  \DESCRIPTION    In a function, data written to an array.
  \COUNTERMEASURE \N [CM_DCM_N_ARRAY_INDEX_WRITE]

\ID SBSW_DCM_GEN_PARAM_PTR_WRITE
  \DESCRIPTION    In a generated function, called only by DCM static code, data is written through a
                  pointer passed as function argument.
  \COUNTERMEASURE \S [CM_DCM_S_GEN_PARAM_PTR_WRITE]

\ID SBSW_DCM_PARAM_PTR_FORWARD
  \DESCRIPTION    A pointer received in a function is passed to a function expecting a valid pointer.
  \COUNTERMEASURE \N [CM_DCM_N_PASS_PARAM_PTR]

\ID SBSW_DCM_GEN_PARAM_PTR_FORWARD
  \DESCRIPTION    A pointer received in a generated function, called only by DCM static code, is passed to
                  a function expecting a valid pointer.
  \COUNTERMEASURE \S [CM_DCM_S_GEN_PARAM_PTR_FORWARD]

\ID SBSW_DCM_PARAM_FUNCPTR_CALL
  \DESCRIPTION    In a function, a function pointer passed as function argument is called.
  \COUNTERMEASURE \N [CM_DCM_N_CALL_PARAM_FUNCPTR]

\ID SBSW_DCM_GLOBAL_PTR_WRITE
  \DESCRIPTION    In a function, data is written through a pointer taken from a global variable.
  \COUNTERMEASURE \N The pointer is taken from a global variable, as such it is always valid.

\ID SBSW_DCM_POINTER_FORWARD_STACK
  \DESCRIPTION    A pointer is passed to a function expecting a valid pointer. The called function does not store its
                  pointer parameter(s).
  \COUNTERMEASURE \N The pointer is taken from a local variable, as such it is always valid.

\ID SBSW_DCM_GEN_POINTER_FORWARD_STACK
  \DESCRIPTION    A pointer is passed to a function expecting a valid pointer (i.e. to return data through it).
                  The called function does not store its pointer parameter(s) for deferred writing.
  \COUNTERMEASURE \S [CM_DCM_S_GEN_POINTER_FORWARD_STACK]

\ID SBSW_DCM_POINTER_FORWARD_GLOBAL
  \DESCRIPTION    A pointer is passed to a function expecting a valid pointer. The called function does not store its
                  pointer parameters.
  \COUNTERMEASURE \N The pointer is taken from a global variable, as such it is always valid.

\ID SBSW_DCM_COMB_PTR_FORWARD
  \DESCRIPTION    A combination of pointers is passed to a function expecting valid pointers. The called function does
                  not store its pointer parameters.The pointer is taken from one of the following locations:
                     - global variable;
                     - local (stack) variable;
                     - is an argument of the caller function (refer also to CM_DCM_N_PASS_PARAM_PTR);
                     - is a pointer initialized with one of the following associated initialization function that
                       returns always a valid Pointer: Dcm_UtiGetDataContextBuffer(),
                                                       Dcm_UtiGetResData(),
                                                       Dcm_UtiGetResDataAt(),
                                                       Dcm_UtiInitDataContext(),
                                                       Dcm_DiagInitMsgContextBufferInfo(),
                                                       Dcm_DiagInitiateServiceProcessing(),
                                                       Dcm_NetGetBufferInfos(),
                                                       Dcm_NetGetTransportObject(),
                                                       Dcm_NetGetPeriodicTxObject(),
                                                       Dcm_Svc22GetDidInfoContext(),
                                                       Dcm_Svc2ASchdGetEntry(),
                                                       Dcm_Svc2CGetSrcItem(),
                                                       Dcm_GetThreadContext(),
                                                       Dcm_Svc31RedirectMsgContext(),
                                                       Dcm_Svc86_03GetDidRecord(),
                                                       Dcm_Svc86_07GetDidRecord()
                     as such it is always valid.
\COUNTERMEASURE \M [CM_DCM_M_SIZEOF_BUFFERINFO]
                \R [CM_DCM_R_GET_BUFFERINFO]
                \R [CM_DCM_R_SET_DATA_CONTEXT_USAGE]

\ID SBSW_DCM_GEN_COMB_PARAM_PTR_FORWARD
  \DESCRIPTION    A combination of pointers is passed to a function expecting valid pointers. The called function does
                  not store its pointer parameters.The pointer is taken from one of the following locations:
                     - local (stack) variable;
                     - is an argument of the caller function (refer also to CM_DCM_S_GEN_PARAM_PTR_FORWARD);
                     - is a pointer initialized with one of the following associated initialization function that
                       returns always a valid Pointer: Dcm_UtiGetResDataAt()
                     as such it is always valid.
\COUNTERMEASURE \R [CM_DCM_R_SET_MESSAGE_CONTEXT_REQBUFFER]
                \R [CM_DCM_R_SET_MESSAGE_CONTEXT_RESBUFFER]
                \S [CM_DCM_S_ROUTINE_OP_FUNC_SIGNATURE]
                \S [CM_DCM_S_ROUTINE_OP_FUNC_WRITE_DATA_LENGTH]
                \S [CM_DCM_S_ROUTINE_WRAPPER_WRITE_DATA_LENGTH]

\ID SBSW_DCM_GEN_RID_WRAPPER
  \DESCRIPTION    In a generated function, a pointer to a uint8/sint8 array routine signal is passed to a function
                  expecting a valid pointer.
  \COUNTERMEASURE \S [CM_DCM_S_ROUTINE_OP_FUNC_SIGNATURE]
                  \S [CM_DCM_S_ROUTINE_OP_FUNC_WRITE_DATA_LENGTH]
                  \S [CM_DCM_S_ROUTINE_WRAPPER_WRITE_DATA_LENGTH]

\ID SBSW_DCM_GEN_DID_WRAPPER
  \DESCRIPTION    In a generated function, a pointer to a uint8 array DID signal is passed to a function
                  expecting a valid pointer.
  \COUNTERMEASURE \S [CM_DCM_S_DID_WRAPPER_WRITE_DATA_LENGTH]
                  \S [CM_DCM_S_DID_WRAPPER_NV_BLOCK_ID_READ]
                  \S [CM_DCM_S_DID_WRAPPER_NV_BLOCK_ID_WRITE]

\ID SBSW_DCM_ROE_NV_ACCESS
  \DESCRIPTION    In a function, a pointer to a NvM data structure is passed to a function expecting valid pointers.
  \COUNTERMEASURE \S [CM_DCM_S_ROE_NV_BLOCK_ID_ACCESS]

\ID SBSW_DCM_SVC29_NV_ACCESS
  \DESCRIPTION    In a function, a pointer to a NvM data structure is passed to a function expecting valid pointers.
  \COUNTERMEASURE \S [CM_DCM_S_SVC29_NV_BLOCK_ID_ACCESS]

\ID SBSW_DCM_POINTER_WRITE_BUFFERINFO
  \DESCRIPTION    In an internal function, data is written through a pointer to a buffer info element, or the
                  pointer is passed to a function expecting a valid reference to a buffer info element.
                  The memory entry pointer is initialized by Dcm_NetGetBufferInfos() which will always return a
                  pointer to a valid memory entry.
  \COUNTERMEASURE \M [CM_DCM_M_CONSISTENCY_BUFFERINFO]
                  \M [CM_DCM_M_SIZEOF_BUFFERINFO]
                  \R [CM_DCM_R_GET_BUFFERINFO]

\ID SBSW_DCM_POINTER_WRITE_COMMCONTEXT
  \DESCRIPTION    In an internal function, data is written through a pointer to a ComM context element, or the
                  pointer is passed to a function expecting a valid reference to a ComM context element.
                  The memory entry pointer is initialized by Dcm_NetGetComMContext() which will always return a
                  pointer to a valid memory entry.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_COMMCONTEXT]
                  \R [CM_DCM_R_GET_COMMCONTEXT]

\ID SBSW_DCM_POINTER_WRITE_BUFFERCONTEXT
  \DESCRIPTION    In an internal function, data is written through a pointer to a buffer context element, or the
                  pointer is passed to a function expecting a valid reference to a buffer context element.
                  The memory entry pointer is initialized by Dcm_NetGetBufferContext() which will always return a
                  pointer to a valid memory entry.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_BUFFERCONTEXT]
                  \R [CM_DCM_R_GET_BUFFERCONTEXT]

\ID SBSW_DCM_POINTER_WRITE_TRANSPORTOBJECT
  \DESCRIPTION    In an internal function, data is written through a pointer to a transport object, or the
                  pointer is passed to a function expecting a valid reference to a transport object.
                  The memory entry pointer is initialized by Dcm_NetGetTransportObject() which will always return a
                  pointer to a valid memory entry.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_TRANSPORTOBJECT]
                  \R [CM_DCM_R_GET_TRANSPORTOBJECT]

\ID SBSW_DCM_POINTER_WRITE_TIMERCONTEXT
  \DESCRIPTION    In an internal function, data is written through a pointer to a timer context, or the
                  pointer is passed to a function expecting a valid reference to a timer context.
                  The memory entry pointer is initialized by Dcm_TmrGetTimerContext() which will always return a
                  pointer to a valid memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_TIMERCONTEXT]

\ID SBSW_DCM_POINTER_WRITE_THREADCONTEXT
  \DESCRIPTION    In an internal function, data is written through a pointer to a thread context, or the
                  pointer is passed to a function expecting a valid reference to a thread context.
                  The memory entry pointer is initialized by Dcm_GetThreadContext() which will always return a
                  pointer to a valid memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_THREADCONTEXT]

\ID SBSW_DCM_POINTER_WRITE_DEBUGTHREADCONTEXT
  \DESCRIPTION    In an internal function, data is written through a pointer to a debug thread context, or the
                  pointer is passed to a function expecting a valid reference to a debug thread context.
                  The memory entry pointer is initialized by Dcm_DebugGetThreadContext() which will always return a
                  pointer to a valid memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_DEBUGTHREADCONTEXT]

\ID SBSW_DCM_POINTER_WRITE_SVC31THREADCONTEXT
  \DESCRIPTION    In an internal function, data is written through a pointer to a Svc31 thread context, or the
                  pointer is passed to a function expecting a valid reference to a Svc31 thread context.
                  The memory entry pointer is initialized by Dcm_SVC31GetThreadContext() which will always return a
                  pointer to a valid memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_SVC31THREADCONTEXT]

\ID SBSW_DCM_POINTER_WRITE_QUEUEDTOBJ
  \DESCRIPTION    In an internal function, data is written through a pointer to a transport object, or the
                  pointer is passed to a function expecting a valid reference to a transport object.
                  The memory entry pointer is initialized by Dcm_DiagGetQueuedTranspObj() which will always return a
                  pointer to a valid memory entry.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_TRANSPORTOBJECT]
                  \R [CM_DCM_R_GET_TRANSPORTOBJECT]

\ID SBSW_DCM_POINTER_WRITE_TOBJ_OF_CONNECTION
  \DESCRIPTION    In an internal function, data is written through a pointer to a transport object, or the
                  pointer is passed to a function expecting a valid reference to a transport object.
                  The memory entry pointer is initialized by Dcm_NetGetTranspObjOfConnection().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_TRANSPORTOBJECT]
                  \R [CM_DCM_R_GET_TRANSPORTOBJECT]
                  \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_POINTER_WRITE_ALLOCATEDTOBJ
  \DESCRIPTION    In an internal function, data is written through a pointer to a transport object, or the
                  pointer is passed to a function expecting a valid reference to a transport object.
                  The memory entry pointer is initialized by Dcm_NetAllocateOrGetTranspObject().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_TRANSPORTOBJECT]
                  \R [CM_DCM_R_GET_TRANSPORTOBJECT]
                  \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_POINTER_WRITE_RESERVEDTOBJ
  \DESCRIPTION    In an internal function, data is written through a pointer to a transport object, or the
                  pointer is passed to a function expecting a valid reference to a transport object.
                  The memory entry pointer is initialized by Dcm_NetLockConnection().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_TRANSPORTOBJECT]
                  \R [CM_DCM_R_GET_TRANSPORTOBJECT]
                  \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_POINTER_WRITE_PERTXOBJ
  \DESCRIPTION    In an internal function, data is written through a pointer to a periodic transport ojbect, or the
                  pointer is passed to a function expecting a valid reference to a transport object.
                  The memory entry pointer is initialized by Dcm_NetGetPeriodicTxObject() which will always
                  return a pointer to a valid memory entry.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_PERTXOBJ]
                  \R [CM_DCM_R_SET_PERTXOBJ]

\ID SBSW_DCM_POINTER_WRITE_TASKCONTEXT
  \DESCRIPTION    In an internal function, data is written through a pointer to a task context object.
                  The memory entry pointer is initialized by Dcm_TskGetTaskContext().
  \COUNTERMEASURE \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_POINTER_WRITE_SCHEDULERCONTEXT
  \DESCRIPTION    In an internal function, data is written through a pointer to a scheduler context object.
                  The memory entry pointer is initialized by Dcm_TskGetSchedulerContext().
  \COUNTERMEASURE \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_POINTER_WRITE_BITSET
  \DESCRIPTION    In an internal function, data is written to an array representing a bitset. The index within the
                  array is calculated by Dcm_UtiBitSetGetRowIdxSafe() which will always return a valid index within
                  the given bitset.
  \COUNTERMEASURE \R [CM_DCM_R_GET_BITSETROWINDEX]
                  \R [CM_DCM_R_BITSET_BASETYPE]

\ID SBSW_DCM_POINTER_WRITE_2ASCHEDULERENTRY
  \DESCRIPTION    In an internal function, data is written through a pointer to a service 0x2A scheduler table entry, or
                  the pointer is passed to a function expecting a valid reference to a service 0x2A scheduler table
                  entry. The memory entry pointer is initialized by Dcm_Svc2ASchdGetEntry() which will always return a
                  pointer to a valid memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_2ASCHEDULERENTRY]

\ID SBSW_DCM_POINTER_WRITE_2CSRCITEM
  \DESCRIPTION    In an internal function, data is written through a pointer to a service 0x2C source item, or the
                  pointer is passed to a function expecting a valid reference to a service 0x2C source item. The memory
                  entry pointer is initialized by Dcm_Svc2CGetSrcItem() which will always return a pointer to a valid
                  memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_2CSRCITEM]

\ID SBSW_DCM_POINTER_WRITE_2CITEM
  \DESCRIPTION    In an internal function, data is written through a pointer to a service 0x2C item, or the pointer is
                  passed to a function expecting a valid reference to a service 0x2C item. The memory entry pointer is
                  initialized by Dcm_Svc2CGetItem() which will always return a pointer to a valid memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_2CITEM]

\ID SBSW_DCM_POINTER_WRITE_2CPROCESSCONTEXT
  \DESCRIPTION    In an internal function, data is written through a pointer to a process context of a DID, or the
                  pointer is passed to a function expecting a valid reference to a process context. The memory entry
                  pointer is initialized by Dcm_Svc2CGetDDDidProcessContext() which will always return a pointer to a
                  valid memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_2CPROCESSCONTEXT]

\ID SBSW_DCM_POINTER_WRITE_2FACTIVEIODIDS
  \DESCRIPTION    In an internal function, data is written through a pointer to a bitmask of active IODIDs, or the
                  pointer is passed to a function expecting a valid reference to a bitmask of active IODIDs. The memory
                  entry pointer is initialized by Dcm_Svc2FGetActiveIoDids() which will always return a pointer to a
                  valid memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_2FACTIVEIODIDS]

\ID SBSW_DCM_POINTER_READ_86DTCRECORD
  \DESCRIPTION    In a function, a pointer to array Dcm_Svc86CurrentSession.EventRecord.OnDtcChange.DtcRecord.STRT[] and its size
                  descriptor Dcm_Svc86CurrentSession.EventRecord.OnDtcChange.DtcRecord.STRTLength is passed to a function expecting
                  a valid pointer to an array and a size descriptor which does not exceed the size of the passed array.
  \COUNTERMEASURE \N The pointer is only used for reading and taken from a global variable, as such it is always valid.

\ID SBSW_DCM_POINTER_WRITE_86DIDRECORD
  \DESCRIPTION    In an internal function, data is written through a pointer to a service 0x86 DID record, or the
                  pointer is passed to a function expecting a valid reference to a service 0x86 DID record. The memory
                  entry pointer is initialized by Dcm_Svc86_03GetDidRecord() or Dcm_Svc86_07GetDidRecord() which will 
                  always return a pointer to a valid memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_86DIDRECORD]

\ID SBSW_DCM_POINTER_WRITE_VSGACTIVECFGVARIANTS
  \DESCRIPTION    In an internal function, data is written to the array Dcm_VarMgrSingletonContext.ActiveCfgVariants[]
                  using an iterator.
  \COUNTERMEASURE \R [CM_DCM_R_GET_VSGACTIVECFGVARIANTS]

\ID SBSW_DCM_POINTER_WRITE_PERIODICTXBUFFER
  \DESCRIPTION    In an internal function, data is written through a pointer to the tx buffer of a periodic message, or
                  the pointer is passed to a function expecting a valid reference to the tx buffer of a periodic
                  message. The memory entry pointer is initialized by Dcm_NetPeriodicMsgGetTxBuffer() which will always
                  return a pointer to a valid memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_PERIODICTXBUFFER]

\ID SBSW_DCM_POINTER_WRITE_RXPDUINFO
  \DESCRIPTION    In an internal function, data is written through a pointer to a Rx-PduInfo, or the
                  pointer is passed to a function expecting a valid reference to a Rx-PduInfo element.
                  The memory entry pointer is initialized by Dcm_NetProvideRxBuffer() which will always return a
                  pointer to a valid memory entry if the return values is BUFREQ_OK.
  \COUNTERMEASURE \R [CM_DCM_R_GET_RXPDUINFO]

\ID SBSW_DCM_POINTER_WRITE_DIDINFOCONTEXT
  \DESCRIPTION    In an internal function, data is written through a pointer to a Did info context, or the
                  pointer is passed to a function expecting a valid reference to a Did info context.
                  The memory entry pointer is initialized by Dcm_Svc22GetDidInfoContext() which will always return a
                  pointer to a valid memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_DIDINFOCONTEXT]

\ID SBSW_DCM_POINTER_INIT_MESSAGE_CONTEXT
  \DESCRIPTION    The global message context variable is passed to Dcm_DiagInitMsgContextBufferInfo() for
                  initialization. That initalization function ensures that all pointer members are pointing to valid
                  memory entry pointer and the corresponding buffer size members are matching to the pointed memory
                  entry sizes.
  \COUNTERMEASURE \N The pointer is taken from a global variable, as such it is always valid.

\ID SBSW_DCM_POINTER_WRITE_MESSAGE_CONTEXT_REQBUFFER
  \DESCRIPTION    In an internal function, data is written through a pointer to a message context request buffer,
                  or the pointer is passed to a function expecting a valid reference to a message context
                  request buffer. The caller ensures that the reqData member points to a valid memory entry pointer
                  and the reqBufSize member matches to the pointed memory entry size.
  \COUNTERMEASURE \R [CM_DCM_R_SET_MESSAGE_CONTEXT_REQBUFFER]

\ID SBSW_DCM_POINTER_WRITE_MESSAGE_CONTEXT_RESBUFFER
  \DESCRIPTION    In an internal function, data is written through a pointer to a message context response buffer,
                  or the pointer is passed to a function expecting a valid reference to a message context
                  response buffer. The caller ensures that the resData member points to a valid memory entry pointer
                  and the resBufSize member matches to the pointed memory entry size.
  \COUNTERMEASURE \R [CM_DCM_R_SET_MESSAGE_CONTEXT_RESBUFFER]

\ID SBSW_DCM_POINTER_WRITE_IO_CTRL_CEMR_SESSION_MASK
  \DESCRIPTION    In an internal function, data is written through a pointer to an IO control CEMR session mask, or the
                  pointer is passed to a function expecting a valid reference to an IO control CEMR session mask.
  \COUNTERMEASURE \R [CM_DCM_R_WRITE_IO_CTRL_CEMR_SESSION_MASK]

\ID SBSW_DCM_POINTER_WRITE_RECOVERYINFOCOMMCHANNELSTATE
  \DESCRIPTION    In an internal function, data is written through a pointer to a ComM channel state of the recovery
                  info, or the pointer is passed to a function expecting a valid reference to a ComM channel state of
                  the recovery info. The memory entry pointer is initialized by
                  Dcm_DiagGetRecoveryInfoComMChannelState() which will always return a pointer to a valid memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_RECOVERYINFOCOMMCHANNELSTATE]

\ID SBSW_DCM_POINTER_WRITE_RECOVERYINFOCOMMCONTROLSTATE
  \DESCRIPTION    In an internal function, data is written through a pointer to the communication state of a ComM
                  channel of the recovery info, or the pointer is passed to a function expecting a valid reference to
                  the communication state of a ComM channel of the recovery info. The memory entry pointer is
                  initialized by Dcm_DiagGetRecoveryInfoCommControlState() which will always return a pointer to a
                  valid memory entry.
  \COUNTERMEASURE \R [CM_DCM_R_GET_RECOVERYINFOCOMMCONTROLSTATE]

\ID SBSW_DCM_POINTER_INIT_DATA_CONTEXT
  \DESCRIPTION    The data context pointer is locally allocated and passed to Dcm_UtiInitDataContext() for
                  initialization. The caller ensures that the passed buffer pointer points to a valid memory entry
                  pointer and the passed buffer size matches to the pointed memory entry size.
  \COUNTERMEASURE \N The pointer is taken from a local variable, as such it is always valid.

\ID SBSW_DCM_POINTER_WRITE_DATA_CONTEXT
  \DESCRIPTION    In an internal function, data is written through a pointer to a data context, or the
                  pointer is passed to a function expecting a valid reference to a data context.
                  The pointer is initialized by Dcm_UtiInitDataContext(), which will always initialize it to point
                  to a valid memory entry. A data context ensures that the sum of Usage and AvailLen member is always
                  equal to or smaller than the referenced buffer size.
  \COUNTERMEASURE \R [CM_DCM_R_SET_DATA_CONTEXT_BUFFER]
                  \R [CM_DCM_R_SET_DATA_CONTEXT_USAGE]

\ID SBSW_DCM_POINTER_MEMCPY_BUFFER
  \DESCRIPTION    In an internal function, data is copied into a buffer through a pointer using memcpy, or the
                  buffer pointer with the appropriate buffer size are passed to a function expecting a valid pair
                  of buffer pointer and buffer size.
  \COUNTERMEASURE \R [CM_DCM_R_MEMCPY_PASS_BUFFER]
                  \R [CM_DCM_R_MEMCPY_WRITE]

\ID SBSW_DCM_CALL_FUNCPTR_TASKINFO
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_TskGetTaskInfo().
  \COUNTERMEASURE \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_CALL_FUNCPTR_TIMERINFO
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_TmrGetTimerInfo() which will always return a valid function pointer.
  \COUNTERMEASURE \R [CM_DCM_R_GET_TIMERINFO]

\ID SBSW_DCM_CALL_FUNCPTR_SVCPOSTPROCESSORS
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_DiagGetPostProcessorFunc() which will always return a valid function pointer.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVCPOSTPROCESSORS]
                  \R [CM_DCM_R_GET_SVCPOSTPROCESSORS]

\ID SBSW_DCM_CALL_FUNCPTR_SVCUPDATERS
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_DiagGetUpdateFunc() which will always return a valid function pointer.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVCUPDATERS]
                  \R [CM_DCM_R_GET_SVCUPDATERS]

\ID SBSW_DCM_CALL_FUNCPTR_SVCCANCELLERS
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_DiagGetCancelFunc() which will always return a valid function pointer.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVCCANCELLERS]
                  \R [CM_DCM_R_GET_SVCCANCELLERS]

\ID SBSW_DCM_CALL_FUNCPTR_MODEMGRRULES
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgWrapModeMgrRulesGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_MODEMGRRULES]
                  \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_CALL_FUNCPTR_TERMINATED_LIST
  \DESCRIPTION    In an internal function, iteration over all elements of a given table is done.
                  Each element is a function pointer or a structure containing only function pointer members.
                  The end of iteration is marked by NULL_PTR.
  \COUNTERMEASURE \M [CM_DCM_M_TERMINATED_LIST]
                  \R [CM_DCM_R_TERMINATED_LIST]

\ID SBSW_DCM_LOOP
  \DESCRIPTION    In an internal function, iteration over all elements of a given context member is done.
  \COUNTERMEASURE \R [CM_DCM_R_LOOP]

\ID SBSW_DCM_POINTER_WRITE_TOBJ_ADDBUFFER
  \DESCRIPTION    In an internal function, data is written to array AddBuffer[] of a specific transport object using a
                  function argument as index.
  \COUNTERMEASURE \R [CM_DCM_R_SET_TOBJ_ADDBUFFER]

\ID SBSW_DCM_POINTER_WRITE_COMCONTROLCHANNEL
  \DESCRIPTION    In an internal function, data is written to array Dcm_PbRamNetComCtrlChannels[] using a
                  function argument as index.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_COMCONTROLCHANNEL]
                  \R [CM_DCM_R_SET_COMCONTROLCHANNEL]

\ID SBSW_DCM_POINTER_WRITE_AUTHNVMDATA
  \DESCRIPTION    In an internal function, data is written to array Dcm_AuthMgrNvMData[] using a
                  function argument as index.
                  Alternatively, data is written to that array through a pointer.
                  In the latter case the memory entry pointer is initialized by Dcm_AuthMgrGetWLContext().
  \COUNTERMEASURE \R [CM_DCM_R_SET_AUTHNVMDATA]

\ID SBSW_DCM_ARRAY_WRITE_PENDINGROLEDATA
  \DESCRIPTION    In an external API, data is written to array Dcm_SingletonContext.AuthMgr.PendingData.Role[].
  \COUNTERMEASURE \R [CM_DCM_R_SET_PENDINGROLEDATA]

\ID SBSW_DCM_POINTER_WRITE_SERVICE_WL_ELEMENT
  \DESCRIPTION    In an internal function, data is written through a pointer to array WLServiceContext.WLServiceElement[]
                  of a connection white list context, or the pointer is passed to a function expecting a valid reference
                  to a connection white list context.
                  The memory entry pointer is either initialized by Dcm_AuthMgrWLContextGetEntry(),
                  or is taken from global variable repeater context, and a loop iterator is used as index.
                  The caller ensures that the element length matches to the pointed memory entry size.
  \COUNTERMEASURE \R [CM_DCM_R_GET_VALID_POINTER]
                  \R [CM_DCM_R_SET_WLSERVICEELEMENT]

\ID SBSW_DCM_POINTER_WRITE_DID_WL_ELEMENT
  \DESCRIPTION    In an internal function, data is written through a pointer to array WLDidContext.WLDidElement[]
                  of a connection white list context.
                  The memory entry pointer is either initialized by Dcm_AuthMgrWLContextGetEntry(),
                  or is taken from global variable repeater context, and a loop iterator is used as index.
  \COUNTERMEASURE \R [CM_DCM_R_GET_VALID_POINTER]
                  \R [CM_DCM_R_SET_WLDIDELEMENT]

\ID SBSW_DCM_POINTER_WRITE_RID_WL_ELEMENT
  \DESCRIPTION    In an internal function, data is written through a pointer to array WLRidContext.WLRidElement[]
                  of a connection white list context.
                  The memory entry pointer is either initialized by Dcm_AuthMgrWLContextGetEntry(),
                  or is taken from global variable repeater context, and a loop iterator is used as index.
  \COUNTERMEASURE \R [CM_DCM_R_GET_VALID_POINTER]
                  \R [CM_DCM_R_SET_WLRIDELEMENT]

\ID SBSW_DCM_POINTER_WRITE_MEM_WL_ELEMENT
  \DESCRIPTION    In an internal function, data is written through a pointer to array WLMemContext.WLMemElement[]
                  of a connection white list context.
                  The memory entry pointer is either initialized by Dcm_AuthMgrWLContextGetEntry(),
                  or is taken from global variable repeater context, and a loop iterator is used as index.
  \COUNTERMEASURE \R [CM_DCM_R_GET_VALID_POINTER]
                  \R [CM_DCM_R_SET_WLMEMELEMENT]

\ID SBSW_DCM_POINTER_WRITE_WL_ELEMENT
  \DESCRIPTION    The white list element pointer is passed to a function expecting a valid reference to a white list
                  element buffer. The caller ensures that the white list element points to a valid memory pointer and
                  the white list element length matches to the pointed memory entry size.
  \COUNTERMEASURE \N The pointer is taken from a local variable, as such it is always valid.

\ID SBSW_DCM_POINTER_WRITE_CERTIFICATE_DATA
  \DESCRIPTION    In an internal function, data is written through a pointer to a certificate data buffer,
                  or the certificate data pointer is passed to a function expecting a valid reference to a certificate
                  data buffer. The caller ensures that the certData member points to a valid memory entry pointer and
                  the certDataLength member matches to the pointed memory entry size.
  \COUNTERMEASURE \N The pointer is taken from a local variable, as such it is always valid.

\ID SBSW_DCM_POINTER_WRITE_CHALLENGE_SWAP_BUFFER
  \DESCRIPTION    In an internal function, data is written through a pointer to the challenge swap buffer,
                  or the challenge swap buffer pointer is passed to a function expecting a valid reference to
                  the challenge swap buffer. The caller ensures that the challenge swap buffer points to a valid memory
                  pointer and buffer length matches to the pointed memory size.
  \COUNTERMEASURE \N The pointer is taken from a global variable, as such it is always valid.

\ID SBSW_DCM_POINTER_WRITE_CERTIFICATE_ROLE
  \DESCRIPTION    The certificate role pointer is passed to a function expecting a valid reference to a certificate
                  role buffer. The caller ensures that the role element points to a valid memory pointer and
                  the role element length matches to the pointed memory entry size.
  \COUNTERMEASURE \N The pointer is taken from a local variable, as such it is always valid.

\ID SBSW_DCM_POINTER_WRITE_TOBJHANDLE
  \DESCRIPTION    In an internal function, data is written to array Dcm_PbRamNetConnHdl2TObjMap[] using a
                  function argument as index.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_TOBJHANDLE]
                  \R [CM_DCM_R_SET_TOBJHANDLE]

\ID SBSW_DCM_POINTER_WRITE_DELAYTIMER
  \DESCRIPTION    In an internal function, data is written to array
                  Dcm_SingletonContext.Network.PeriodicTxContext.DelayTimer[] using a function argument as index.
  \COUNTERMEASURE \R [CM_DCM_R_SET_DELAYTIMER]

\ID SBSW_DCM_POINTER_WRITE_TIMER
  \DESCRIPTION    In an internal function, data is written to array Dcm_SingletonContext.TimerMgr.Timer[] using a
                  function argument as index.
  \COUNTERMEASURE \R [CM_DCM_R_SET_TIMER]

\ID SBSW_DCM_POINTER_WRITE_START_UP_FBL_RES_BUFFER
  \DESCRIPTION    In an internal function, data is written to array Dcm_SingletonContext.Diag.StartUpFbl.ResBuffer[]
                  using a function argument as index.
  \COUNTERMEASURE \R [CM_DCM_R_SET_START_UP_FBL_RES_BUFFER]

\ID SBSW_DCM_POINTER_WRITE_ATTEMPTCOUNT
  \DESCRIPTION    In an internal function, data is written to array
                  Dcm_SingletonContext.Diag.Services.Svc27.AttemptCount[] using a function argument as index.
  \COUNTERMEASURE \R [CM_DCM_R_SET_ATTEMPTCOUNT]

\ID SBSW_DCM_POINTER_WRITE_DELAYTIME_SEC
  \DESCRIPTION    In an internal function, data is written to array Dcm_SingletonContext.Diag.Services.Svc27.DelayTime[]
                  using a function argument as index.
  \COUNTERMEASURE \R [CM_DCM_R_SET_DELAYTIME_SEC]

\ID SBSW_DCM_POINTER_WRITE_DELAYTIME_AUTH
  \DESCRIPTION    In an internal function, data is written to array Dcm_SingletonContext.AuthMgr.DelayTime[]
                  using a function argument as index.
  \COUNTERMEASURE \R [CM_DCM_R_SET_DELAYTIME_AUTH]

\ID SBSW_DCM_POINTER_WRITE_DIDLOCKLIST
  \DESCRIPTION    In an internal function, data is written to array Dcm_RsrcMgrSingletonContext.DidLockList[] using a
                  loop iterator as index.
  \COUNTERMEASURE \R [CM_DCM_R_SET_DIDLOCKLIST]

\ID SBSW_DCM_POINTER_WRITE_RIDLOCKLIST
  \DESCRIPTION    In an internal function, data is written to array Dcm_RsrcMgrSingletonContext.RidLockList[] using a
                  loop iterator as index.
  \COUNTERMEASURE \R [CM_DCM_R_SET_RIDLOCKLIST]

\ID SBSW_DCM_CALL_FUNCPTR_SVC11SUBFUNC
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgWrapSvc11SubFuncInfoGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC11SUBFUNC]
                  \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_CALL_FUNCPTR_SVC19SUBFUNC
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgWrapSvc19SubFuncInfoGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC19SUBFUNC]
                  \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_CALL_FUNCPTR_DIDMGROPFUNC
  \DESCRIPTION    In an internal function, a function pointer is called.
                  The pointer is initialized by Dcm_CfgWrapDidMgrSignalOpClassInfoGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_DIDMGROPFUNC]
                  \R [CM_DCM_R_GET_VALID_POINTER]
                  \S [CM_DCM_S_DIDMGR_OP_FUNC_SIGNATURE]
                  \S [CM_DCM_S_DIDMGR_OP_FUNC_WRITE_DATA_LENGTH]

\ID SBSW_DCM_CALL_FUNCPTR_IOCTRLSRHANDLER
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgWrapDidMgrIoControlSenderReceiverHandlersGetEntry() which will always return a valid function
                  pointer.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_IOCTRLSRHANDLERS]

\ID SBSW_DCM_CALL_FUNCPTR_SVC27SECLEVEL
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc27SecLevelInfoGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC27SECLEVEL]
                  \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_CALL_FUNCPTR_SVC27GETSEED
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc27SecLevelInfoGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC27SECLEVEL]
                  \R [CM_DCM_R_GET_VALID_POINTER]
                  \S [CM_DCM_S_GET_SEED_FUNC_SIGNATURE]
                  \S [CM_DCM_S_GET_SEED_FUNC_WRITE_DATA_LENGTH]

\ID SBSW_DCM_CALL_FUNCPTR_SVC31OPFUNC
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgWrapRidMgrOpInfoGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC31OPFUNC]
                  \R [CM_DCM_R_GET_VALID_POINTER]
                  \S [CM_DCM_S_ROUTINE_OP_FUNC_SIGNATURE]
                  \S [CM_DCM_S_ROUTINE_OP_FUNC_WRITE_DATA_LENGTH]

\ID SBSW_DCM_CALL_FUNCPTR_SVC28SUBFUNC
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgWrapSvc28SubFuncInfoGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC28SUBFUNC]
                  \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_CALL_FUNCPTR_SVC29SUBFUNC
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc29SubFuncInfoGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC29SUBFUNC]
                  \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_CALL_FUNCPTR_SVC2CSUBFUNC
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc2CSubFuncInfoGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC2CSUBFUNC]
                  \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_CALL_FUNCPTR_SVC85SUBFUNC
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgWrapSvc85SubFuncInfoGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC85SUBFUNC]
                  \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_CALL_FUNCPTR_SVC86SUBFUNC
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgSvc86SubFuncInfoGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC86SUBFUNC]
                  \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_CALL_FUNCPTR_ROEMODESWITCH
  \DESCRIPTION    In an internal function, a function pointer is called. The index to the called function pointer
                  is a function argument.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_ROEEVENTMODESWITCHINFO]
                  \R [CM_DCM_R_GET_ROEEVENTMODESWITCHINFO]

\ID SBSW_DCM_CALL_FUNCPTR_AUTHMODESWITCH
  \DESCRIPTION    In an internal function, a function pointer is called. The index to the called function pointer
                  is a function argument.
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_CFGAUTHMGRNETCONNINFO]
                  \R [CM_DCM_R_GET_CFGAUTHMGRNETCONNINFO]

\ID SBSW_DCM_CALL_FUNCPTR_SERVICEINFO
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgDiagServiceInfoGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SERVICEINFO]
                  \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_CALL_READMEMORY
  \DESCRIPTION    The callout Dcm_ReadMemory uses a write-able pointer of the DCM buffer, which is always valid. The
                  application always writes as many data as the caller expects.
  \COUNTERMEASURE \S [CM_DCM_S_READMEMORY_FUNC_WRITE_DATA_LENGTH]

\ID SBSW_DCM_CALL_FUNCPTR_SVC01SERVICEINFO
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgWrapSvc01ServiceInfoGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC01SERVICEINFO]
                  \R [CM_DCM_R_GET_VALID_POINTER]
                  \S [CM_DCM_S_GET_SVC01SERVICEINFO_WRITE_DATA_LENGTH]

\ID SBSW_DCM_CALL_FUNCPTR_SVC08SERVICEINFO
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgWrapSvc08ServiceInfoGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC08SERVICEINFO]
                  \R [CM_DCM_R_GET_VALID_POINTER]
                  \S [CM_DCM_S_GET_SVC08SERVICEINFO_WRITE_DATA_LENGTH]

\ID SBSW_DCM_CALL_FUNCPTR_SVC09SERVICEINFO
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgWrapSvc09ServiceInfoGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC09SERVICEINFO]
                  \R [CM_DCM_R_GET_VALID_POINTER]
                  \S [CM_DCM_S_GET_SVC09SERVICEINFO_WRITE_DATA_LENGTH]

\ID SBSW_DCM_CALL_FUNCPTR_SVC06MIDTIDINFO
  \DESCRIPTION    In an internal function, a function pointer is called. The pointer is initialized by
                  Dcm_CfgWrapSvc06MidTidInfoGetEntry().
  \COUNTERMEASURE \M [CM_DCM_M_SIZEOF_SVC06MIDTIDINFO]
                  \R [CM_DCM_R_GET_VALID_POINTER]

\ID SBSW_DCM_POINTER_CONVERTTOARRAY
  \DESCRIPTION    In an internal function, data is copied into a buffer through a pointer, or the
                  buffer pointer with the appropriate buffer size are passed to a function expecting a valid pair
                  of buffer pointer and buffer size.
  \COUNTERMEASURE \R [CM_DCM_R_CONVERTTOARRAY_PASS_BUFFER]
                  \R [CM_DCM_R_CONVERTTOARRAY_WRITE]
                  \S [CM_DCM_S_GEN_POINTER_FORWARD_STACK]

\ID SBSW_DCM_CALL_PROCESSREQUESTTRANSFEREXIT
  \DESCRIPTION    The callout Dcm_ProcessRequestTransferExit uses a write-able pointer of the DCM buffer, which 
                  is always valid. The amount of data which can be written is indicated by an function argument 
                  to the application.
  \COUNTERMEASURE \S [CM_DCM_S_PROCESSREQUESTTRANSFEREXIT_FUNC_WRITE_DATA_LENGTH]

\ID SBSW_DCM_POINTER_SVC31_REDIRECT_MESSAGE_CONTEXT
  \DESCRIPTION    A local message context variable is passed to Dcm_Svc31RedirectMsgContext() for
                  initialization. That initalization function ensures that all pointer members are pointing to valid
                  memory entry pointer and the corresponding buffer size members are matching to the pointed memory
                  entry sizes.
  \COUNTERMEASURE \N The pointer is taken from a local variable, as such it is always valid.

SBSW_JUSTIFICATION_END */

/*
\CM CM_DCM_N_PASS_PARAM_PTR
  The caller ensures the pointers passed to this function are valid.

\CM CM_DCM_N_ARRAY_INDEX_WRITE
  The function insures calculating the correct array size and writing in an array index within the array index limit.

\CM CM_DCM_S_GEN_PARAM_PTR_WRITE
  The user of MICROSAR Safe shall verify that none of the generated functions in Dcm_Lcfg.c modifies the pointer
  passed as an argument, but only writes a new value to it.
  SMI-37386

\CM CM_DCM_S_GEN_PARAM_PTR_FORWARD
  The user of MICROSAR Safe shall verify that none of the generated functions in Dcm_Lcfg.c modifies the pointer
  passed as an argument, but only forwards it to another function.
  SMI-37387

\CM CM_DCM_S_GEN_POINTER_FORWARD_STACK
  The user of MICROSAR Safe shall verify that none of the generated functions in Dcm_Lcfg.c modifies the pointer taken
  from a local variable, and that the function receiving those pointer parameter(s) neither stores the addresses after
  return nor writes more data to the addesses than specified by the byte size of the local variable (especially in
  case of local arrays).
  SMI-37388

\CM CM_DCM_S_DIDMGR_OP_FUNC_SIGNATURE
  The user of MICROSAR Safe shall verify that all generated OpFunc functions in table Dcm_CfgDidMgrSignalOpClassInfo
  located in Dcm_Lcfg.c match the signature indicated by the FuncClass setting.
  SMI-106112, SMI-117436, SMI-126353, SMI-163630

\CM CM_DCM_S_GET_SEED_FUNC_SIGNATURE
  The user of MICROSAR Safe shall verify that all generated GetSeedFunc functions in table Dcm_CfgSvc27SecLevelInfo
  located in Dcm_Lcfg.c match the signature indicated by the GetSeedFuncClass setting.
  SMI-40607

\CM CM_DCM_S_GET_SEED_FUNC_WRITE_DATA_LENGTH
  The user of MICROSAR Safe shall verify that for all generated GetSeedFunc functions in table Dcm_CfgSvc27SecLevelInfo
  located in Dcm_Lcfg.c no more data will be written than specified by the corresponding SeedResLength setting.
  SMI-49478

\CM CM_DCM_S_ROUTINE_OP_FUNC_SIGNATURE
  The user of MICROSAR Safe shall verify that all generated OpFunc functions in table Dcm_CfgRidMgrOpInfo located
  in Dcm_Lcfg.c match the signature indicated by the OpType setting.
  SMI-64952

\CM CM_DCM_S_ROUTINE_OP_FUNC_WRITE_DATA_LENGTH
  The user of MICROSAR Safe shall verify that for all generated OpFunc functions in table Dcm_CfgRidMgrOpInfo located
  in Dcm_Lcfg.c no more data will be written than specified by the corresponding ResMaxLength setting.
  SMI-64953

\CM CM_DCM_S_ROUTINE_WRAPPER_WRITE_DATA_LENGTH
  The user of MICROSAR Safe shall verify all generated Dcm_RidMgr_<RID>_<Start|Stop|RequestResults> functions
  implemented in Dcm_Lcfg.c that for each Dcm_UtiGetResDataRel(pMsgContext, *<offset>*) usage on out signals the
  application does not write more data than (ResMaxLength - *<offset>*), specified by the corresponding ResMaxLength
  setting in table Dcm_CfgRidMgrOpInfo located in _Dcm_Lcfg.c.
  SMI-65597

\CM CM_DCM_S_DID_WRAPPER_WRITE_DATA_LENGTH
  The user of MICROSAR Safe shall verify that for all generated OpFunc functions in table
  Dcm_CfgDidMgrSignalOpClassInfo located in Dcm_Lcfg.c with a FuncClass setting of 0x00XX or 0x30XX, that are entirely
  or partially (e.g. through a wrapper function) implemented by the application, no more data will be written than
  specified by the corresponding MaxLength setting.
  SMI-105069

\CM CM_DCM_S_DID_WRAPPER_NV_BLOCK_ID_READ
  The user of MICROSAR Safe shall verify that in the table Dcm_CfgDidMgrSignalOpClassInfo, if OpFunc requires
  Nv Block ID, the Nv Block ID passed to the function Dcm_DidMgrNvMReadSignal() is intended to be used exclusively
  by Dcm.

  This SMI is required to fulfill SMI-22 by NvM.

  The user of MICROSAR Safe shall verify that in the table Dcm_CfgDidMgrSignalOpClassInfo, if OpFunc requires
  Nv Block ID, the Nv Block ID passed to the function Dcm_DidMgrNvMReadSignal() has a size equals to MaxLength.

  This SMI is required to fulfill SMI-23 by NvM.

  OpFunc functions that require Nv Block ID are implemented in Dcm_Lcfg.c both of:
  - with a generic name Dcm_DidMgr_<SignalName>_Read,
  - and the corresponding FuncClass equals to 0x0002.

  The table Dcm_CfgDidMgrSignalOpClassInfo is located in Dcm_Lcfg.c.
  SMI-106815, SMI-106816

\CM CM_DCM_S_DID_WRAPPER_NV_BLOCK_ID_WRITE
  The user of MICROSAR Safe shall verify that in the table Dcm_CfgDidMgrSignalOpClassInfo, if OpFunc requires
  Nv Block ID, the Nv Block ID passed to the function Dcm_DidMgrNvMWriteSignal() is intended to be used exclusively
  by Dcm.

  This SMI is required to fulfill SMI-22 by NvM.

  The user of MICROSAR Safe shall verify that in the table Dcm_CfgDidMgrSignalOpClassInfo, if OpFunc requires
  Nv Block ID, the Nv Block ID passed to the function Dcm_DidMgrNvMWriteSignal() has a size equals to MaxLength.

  This SMI is required to fulfill SMI-23 by NvM.

  OpFunc functions that require Nv Block ID are implemented in Dcm_Lcfg.c both of:
  - with a generic name Dcm_DidMgr_<SignalName>_Write,
  - and the corresponding FuncClass equals to 0x1002.

  The table Dcm_CfgDidMgrSignalOpClassInfo is located in Dcm_Lcfg.c.
  SMI-117437, SMI-117438

\CM CM_DCM_S_ROE_NV_BLOCK_ID_ACCESS
  The user of MICROSAR Safe shall verify that the Nv Block with the ID defined by DCM_EXT_SVC_86_NVRAM_BLOCKID located
  in Dcm_Cfg.h is intended to be used exclusively by Dcm.

  This SMI is required to fulfill SMI-22 by NvM.

  The user of MICROSAR Safe shall verify that the Nv Block with the ID defined by DCM_EXT_SVC_86_NVRAM_BLOCKID located
  in Dcm_Cfg.h has a size equals to the size of the structure data type Dcm_ExtSvc86NvMDataType.

  This SMI is required to fulfill SMI-23 by NvM.
  SMI-163518, SMI-163519

\CM CM_DCM_S_SVC29_NV_BLOCK_ID_ACCESS
  The user of MICROSAR Safe shall verify that each Nv Block, with the ID defined by NvMBlockId setting of table
  Dcm_CfgAuthMgrNetConnInfo located in Dcm_Lcfg.c, is intended to be used exclusively by Dcm.

  This SMI is required to fulfill SMI-22 by NvM.

  The user of MICROSAR Safe shall verify that each Nv Block, with the ID defined by NvMBlockId setting of table
  Dcm_CfgAuthMgrNetConnInfo located in Dcm_Lcfg.c, has a size of the structure data type Dcm_AuthMgrNvMDataType.

  This SMI is required to fulfill SMI-23 by NvM.
  SMI-440519, SMI-440520

\CM CM_DCM_S_READMEMORY_FUNC_WRITE_DATA_LENGTH
  The user of MICROSAR Safe shall verify that the implementation of the call-out function Dcm_ReadMemory() will not
  write more data than specified by the MemorySize parameter.
  SMI-74833

\CM CM_DCM_S_DIDMGR_OP_FUNC_WRITE_DATA_LENGTH
  The user of MICROSAR Safe shall verify that for all generated OpFunc functions in table
  Dcm_CfgDidMgrSignalOpClassInfo located in Dcm_Lcfg.c with a FuncClass setting of 0x00XX or 0x30XX, that are entirely
  or partially (e.g. through a wrapper function) implemented by the application, no more data will be written than
  specified by the corresponding MaxLength setting.

  The user of MICROSAR Safe shall verify that for all generated OpFunc functions in table
  Dcm_CfgDidMgrSignalOpClassInfo located in Dcm_Lcfg.c with a FuncClass setting of 0x0003 no more data will be written
  than specified by DCM_DIDMGR_READ_PAGE_SIZE setting located in Dcm_Cfg.h.
  SMI-105069, SMI-105312

\CM CM_DCM_S_GET_SVC01SERVICEINFO_WRITE_DATA_LENGTH
  The user of MICROSAR Safe shall verify that for all generated OpFunc functions in table Dcm_CfgSvc01ServiceInfoTable
  located in Dcm_Lcfg.c no more data will be written than specified by the corresponding ResLength setting.
  SMI-147940

\CM CM_DCM_S_GET_SVC08SERVICEINFO_WRITE_DATA_LENGTH
  The user of MICROSAR Safe shall verify that for all generated OpFunc functions in table Dcm_CfgSvc08ServiceInfoTable
  located in Dcm_Lcfg.c no more data will be written than specified by the corresponding ResLength setting.
  SMI-143395

\CM CM_DCM_S_GET_SVC09SERVICEINFO_WRITE_DATA_LENGTH
  The user of MICROSAR Safe shall verify that for all generated OpFunc functions in table Dcm_CfgSvc09ServiceInfoTable
  located in Dcm_Lcfg.c no more data will be written than specified by the corresponding ResLength setting.
  SMI-147938

\CM CM_DCM_S_PROCESSREQUESTTRANSFEREXIT_FUNC_WRITE_DATA_LENGTH
  The user of MICROSAR Safe shall verify that the implementation of the call-out function
  Dcm_ProcessRequestTransferExit() will not write more data than specified by the transferResponseParameterRecordSize
  parameter.
  SMI-579281

\CM CM_DCM_N_CALL_PARAM_FUNCPTR
  The caller ensures the pointers passed to this function are valid.

\CM CM_DCM_M_DEV_ERROR_DETECT
  Verify that development error detection is active in the configuration.

\CM CM_DCM_M_CONSISTENCY_BUFFERINFO
  Verify for each element in Dcm_CfgNetBufferInfo[] that the member 'Size' matches to the size of the array the
  member 'BufferPtr' is pointing to.

\CM CM_DCM_M_SIZEOF_BUFFERINFO
  Verify Dcm_PbCfgNetBufferInfo[] is defined for each id in range [0..Dcm_PbCfgNetNumBuffers[.

\CM CM_DCM_M_SIZEOF_COMMCONTEXT
  Verify Dcm_PbRamNetComMContext[] is defined for each id in range [0..Dcm_PbCfgNetNumComMChannels[.

\CM CM_DCM_M_SIZEOF_BUFFERCONTEXT
  Verify Dcm_PbRamNetBufferContext[] is defined for each id in range [0..Dcm_PbCfgNetNumBuffers[.

\CM CM_DCM_M_SIZEOF_TRANSPORTOBJECT
  Verify Dcm_PbRamNetTransportObject[] is defined for each id in range [0..Dcm_PbCfgNetNumTransportObjects[.

\CM CM_DCM_M_SIZEOF_COMCONTROLCHANNEL
  Verify Dcm_PbRamNetComCtrlChannels[] is defined for each id in range [0..Dcm_PbCfgNetNumComMChannels[.

\CM CM_DCM_M_SIZEOF_TOBJHANDLE
  Verify Dcm_PbRamNetConnHdl2TObjMap[] is defined for each id in range [0..Dcm_PbCfgNetNumConnections[.

\CM CM_DCM_M_SIZEOF_PERTXOBJ
  Verify Dcm_PbRamNetPeriodicTxObject[] is defined for each id in range [0..Dcm_PbCfgNetNumPerTxObjects[.

\CM CM_DCM_M_SIZEOF_SVCPOSTPROCESSORS
  Verify Dcm_CfgDiagSvcPostProcessors[] is defined for each id in range [0..DCM_CFGDIAGSVCPOSTPROCESSORS_SIZE[.

\CM CM_DCM_M_SIZEOF_SVCUPDATERS
  Verify Dcm_CfgDiagSvcUpdaters[] is defined for each id in range [0..DCM_CFGDIAGSVCUPDATERS_SIZE[.

\CM CM_DCM_M_SIZEOF_SVCCANCELLERS
  Verify Dcm_CfgDiagSvcCancellers[] is defined for each id in range [0..DCM_CFGDIAGSVCCANCELLERS_SIZE[.

\CM CM_DCM_M_SIZEOF_MODEMGRRULES
  Verify Dcm_CfgModeMgrRules[] is defined for each id in range [0..DCM_CFGMODEMGRRULES_SIZE[.

\CM CM_DCM_M_TERMINATED_LIST
  Verify that the last element of the given table is a NULL_PTR.

\CM CM_DCM_M_SIZEOF_SVC11SUBFUNC
  Verify Dcm_CfgSvc11SubFuncInfo[] is defined for each id in range [0..DCM_CFGSVC11SUBFUNCINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC19SUBFUNC
  Verify Dcm_CfgSvc19SubFuncInfo[] is defined for each id in range [0..DCM_CFGSVC19SUBFUNCINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_DIDMGROPFUNC
  Verify Dcm_CfgDidMgrSignalOpClassInfo[] is defined for each id in range [0..DCM_CFGDIDMGRSIGNALOPCLASSINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_IOCTRLSRHANDLERS
  Verify Dcm_CfgDidMgr_IOControlSenderReceiverHandlers[] is defined for each id in range
  [0..DCM_CFGDIDMGR_IOCONTROLSENDERRECEIVERHANDLERS_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC27SECLEVEL
  Verify Dcm_CfgSvc27SecLevelInfo[] is defined for each id in range [0..DCM_CFGSVC27SECLEVELINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC31OPFUNC
  Verify Dcm_CfgRidMgrOpInfo[] is defined for each id in range [0..DCM_CFGRIDMGROPINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC28SUBFUNC
  Verify Dcm_CfgSvc28SubFuncInfo[] is defined for each id in range [0..DCM_CFGSVC28SUBFUNCINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC29SUBFUNC
  Verify Dcm_CfgSvc29SubFuncInfo[] is defined for each id in range [0..DCM_CFGSVC29SUBFUNCINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC2CSUBFUNC
  Verify Dcm_CfgSvc2CSubFuncInfo[] is defined for each id in range [0..DCM_CFGSVC2CSUBFUNCINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC85SUBFUNC
  Verify Dcm_CfgSvc85SubFuncInfo[] is defined for each id in range [0..DCM_CFGSVC85SUBFUNCINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC86SUBFUNC
  Verify Dcm_CfgSvc86SubFuncInfo[] is defined for each id in range [0..DCM_CFGSVC86SUBFUNCINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_ROEEVENTMODESWITCHINFO
  Verify Dcm_CfgModeRoEEventModeSwitchInfoTable[] is defined for each id in range [0..DCM_CFGMODEROEEVENTMODESWITCHINFOTABLE_SIZE[.

\CM CM_DCM_M_SIZEOF_CFGAUTHMGRNETCONNINFO
  Verify Dcm_CfgAuthMgrNetConnInfo[] is defined for each id in range [0..DCM_CFGAUTHMGRNETCONNINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_SERVICEINFO
  Verify Dcm_CfgDiagServiceInfo[] is defined for each id in range [0..DCM_CFGDIAGSERVICEINFO_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC01SERVICEINFO
  Verify Dcm_CfgSvc01ServiceInfoTable[] is defined for each id in range [0..DCM_CFGSVC01SERVICEINFOTABLE_SIZE[.

 \CM CM_DCM_M_SIZEOF_SVC06MIDTIDINFO
  Verify Dcm_CfgSvc06MidTidInfoTable[] is defined for each id in range [0..DCM_CFGSVC06MIDTIDINFOTABLE_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC08SERVICEINFO
  Verify Dcm_CfgSvc08ServiceInfoTable[] is defined for each id in range [0..DCM_CFGSVC08SERVICEINFOTABLE_SIZE[.

\CM CM_DCM_M_SIZEOF_SVC09SERVICEINFO
  Verify Dcm_CfgSvc09ServiceInfoTable[] is defined for each id in range [0..DCM_CFGSVC09SERVICEINFOTABLE_SIZE[.

\CM CM_DCM_R_CHECK_REMAINING_BUFFER
  Before writing data to a buffer, check that the buffer is large enough for the data written to it.

\CM CM_DCM_R_GET_BUFFERINFO
  Dcm_NetGetBufferInfo() will always return a valid buffer info element even when the passed memory index is
  not a handle to a buffer info element.

\CM CM_DCM_R_GET_COMMCONTEXT
  Dcm_NetGetComMContext() will always return a valid ComM context element even when the passed memory index is
  not a handle to a ComM context element.

\CM CM_DCM_R_GET_BUFFERCONTEXT
  Dcm_NetGetBufferContext() will always return a valid buffer context element even when the passed memory index is
  not a handle to a buffer context element.

\CM CM_DCM_R_GET_TRANSPORTOBJECT
  Dcm_NetGetTransportObject() will always return a valid transport object even when the passed memory index is
  not a handle to a transport object.

\CM CM_DCM_R_GET_TIMERCONTEXT
  Dcm_TmrGetTimerContext() will always return a valid transport object even when the passed memory index is
  not a handle to a timer context.

\CM CM_DCM_R_GET_BITSETROWINDEX
  Dcm_UtiBitSetGetRowIdxSafe() will return a index within the given bitset array, even when the passed bit position is
  not within the bitset.

\CM CM_DCM_R_BITSET_BASETYPE
  Verify that the base type passed to the bitset manipulation macro matches the base type of the respective bitset
  array.

\CM CM_DCM_R_GET_2ASCHEDULERENTRY
  Dcm_Svc2ASchdGetEntry() will return a valid entry of the 0x2A scheduler table, even when the passed memory index is
  not a handle to a scheduler table entry.

\CM CM_DCM_R_GET_2CSRCITEM
  Dcm_Svc2CGetSrcItem() will return a valid entry of the 0x2C source item table, even when the passed memory index is
  not a handle to a source item table entry.

\CM CM_DCM_R_GET_2CITEM
  Dcm_Svc2CGetItem() will return a valid entry of the 0x2C item table, even when the passed memory index is not a handle
  to an item table entry.

\CM CM_DCM_R_GET_2CPROCESSCONTEXT
  Dcm_Svc2CGetDDDidProcessContext() will return a valid process context of a DID, even when the passed memory index is
  not a handle to a process context.

\CM CM_DCM_R_GET_2FACTIVEIODIDS
  Dcm_Svc2FGetActiveIoDids() will return a valid bitmask of active IODIDs, even when the passed memory index is not a
  handle to a bitmask of active IODIDs.

\CM CM_DCM_R_GET_86DIDRECORD
  Dcm_Svc86_03GetDidRecord() or Dcm_Svc86_07GetDidRecord() will return a valid entry of the DID record table, even when
  the passed memory index is not a handle to a DID record table entry.

\CM CM_DCM_R_GET_VSGACTIVECFGVARIANTS
  Verify that the array index is in range before writing to Dcm_VarMgrSingletonContext.ActiveCfgVariants[].

\CM CM_DCM_R_GET_PERIODICTXBUFFER
  Dcm_NetPeriodicMsgGetTxBuffer() will return a valid tx buffer of a periodic message, even when the passed memory index
  is not a handle to a periodic tx object.

\CM CM_DCM_R_GET_RXPDUINFO
  Verify that the local pointer initialized as a NULL_PTR is set after calling Dcm_NetProvideRxBuffer().

\CM CM_DCM_R_GET_THREADCONTEXT
  Dcm_GetThreadContext() will always return a valid thread info pointer even when the passed memory index is
  not a handle to a thread info.

\CM CM_DCM_R_GET_DEBUGTHREADCONTEXT
  Dcm_DebugGetThreadContext() will always return a valid thread info pointer even when the passed memory index is
  not a handle to a thread info.

\CM CM_DCM_R_GET_SVC31THREADCONTEXT
  Dcm_Svc31GetThreadContext() will always return a valid thread info pointer even when the passed memory index is
  not a handle to a thread info.

\CM CM_DCM_R_GET_TIMERINFO
  Dcm_TmrGetTimerInfo() will always return a valid timer info even when the passed memory index is
  not a handle to a timer info.

\CM CM_DCM_R_GET_SVCPOSTPROCESSORS
  Dcm_DiagGetPostProcessorFunc() will always return a valid function pointer even when the passed memory index is
  not a handle to a post-processor function.

\CM CM_DCM_R_GET_SVCUPDATERS
  Dcm_DiagGetUpdateFunc() will always return a valid function pointer even when the passed memory index is
  not a handle to an update function.

\CM CM_DCM_R_GET_SVCCANCELLERS
  Dcm_DiagGetCancelFunc() will always return a valid function pointer even when the passed memory index is
  not a handle to a cancellation function.

\CM CM_DCM_R_TERMINATED_LIST
  Verify that iteration over all elements of a given table is only done until NULL_PTR element.

\CM CM_DCM_R_LOOP
  The for loop or while loop with constrains ensures that the index never exceeds the size of the given table.

\CM CM_DCM_R_SET_TOBJ_ADDBUFFER
  Verify that the array index is in range before writing to AddBfufer[] of a specific transport object.

\CM CM_DCM_R_SET_COMCONTROLCHANNEL
  Verify that the array index is in range before writing to Dcm_PbRamNetComCtrlChannels[].

\CM CM_DCM_R_SET_AUTHNVMDATA
  Verify that the array index is in range before writing to Dcm_AuthMgrNvMData[].

\CM CM_DCM_R_SET_PENDINGROLEDATA
  Verify that the array index is in range before writing to Dcm_SingletonContext.AuthMgr.PendingData.Role[].

\CM CM_DCM_R_SET_WLSERVICEELEMENT
  Verify that the array index is in range before writing to pWLServiceContext->WLServiceElement[].

\CM CM_DCM_R_SET_WLDIDELEMENT
  Verify that the array index is in range before writing to pWLDidContext->WLDidElement[].

\CM CM_DCM_R_SET_WLRIDELEMENT
  Verify that the array index is in range before writing to pWLRidContext->WLRidElement[].

\CM CM_DCM_R_SET_WLMEMELEMENT
  Verify that the array index is in range before writing to pWLMemContext->WLMemElement[].

\CM CM_DCM_R_SET_TOBJHANDLE
  Verify that the array index is in range before writing to Dcm_PbRamNetConnHdl2TObjMap[].

\CM CM_DCM_R_SET_TIMER
  Verify that the array index is in range before writing to Dcm_SingletonContext.TimerMgr.Timer[].

\CM CM_DCM_R_SET_START_UP_FBL_RES_BUFFER
  Verify that the array index is in range before writing to Dcm_SingletonContext.Diag.StartUpFbl.ResBuffer[].

\CM CM_DCM_R_SET_ATTEMPTCOUNT
  Verify that the array index is in range before writing to Dcm_SingletonContext.Diag.Services.Svc27.AttemptCount[].

\CM CM_DCM_R_SET_DELAYTIME_SEC
  Verify that the array index is in range before writing to Dcm_SingletonContext.Diag.Services.Svc27.DelayTime[].

\CM CM_DCM_R_SET_DELAYTIME_AUTH
  Verify that the array index is in range before writing to Dcm_SingletonContext.AuthMgr.DelayTime[].

\CM CM_DCM_R_SET_DIDLOCKLIST
  Verify that the array index is in range before writing to Dcm_RsrcMgrSingletonContext.DidLockList[].

\CM CM_DCM_R_SET_RIDLOCKLIST
  Verify that the array index is in range before writing to Dcm_RsrcMgrSingletonContext.RidLockList[].

\CM CM_DCM_R_SET_PERTXOBJ
  Verify that the array index is in range before writing to Dcm_PbRamNetPeriodicTxObject[].

\CM CM_DCM_R_SET_DELAYTIMER
  Verify that the array index is in range before writing to Dcm_SingletonContext.Network.PeriodicTxContext.DelayTimer[].

\CM CM_DCM_R_SET_DATA_CONTEXT_BUFFER
  Verify that the array index is in range [0..pDataContext->Size[ before writing to pDataContext->Buffer.

\CM CM_DCM_R_SET_MESSAGE_CONTEXT_RESBUFFER
  Verify that the array index is in range [0..pMsgContext->resBufSize[ before writing to pMsgContext->resData.

\CM CM_DCM_R_WRITE_IO_CTRL_CEMR_SESSION_MASK
  Verify that the write access to the bitmask Dcm_DidMgrIoControlCemrSessionMask does not exceed its
  size (DCM_DIDMGR_IODID_MAX_EXT_CEMR_SIZE).

\CM CM_DCM_R_SET_MESSAGE_CONTEXT_REQBUFFER
  Verify that the array index is in range [0..pMsgContext->reqBufSize[ before writing to pMsgContext->reqData.

\CM CM_DCM_R_SET_DATA_CONTEXT_USAGE
  Verify that the sum of pDataContext->Usage and pDataContext->AvailLen is always equal to or smaller as
  pDataContext->Size.

\CM CM_DCM_R_MEMCPY_PASS_BUFFER
  Verify that the passed pair of buffer pointer and buffer size matches to referenced memory entry and memory size.

\CM CM_DCM_R_MEMCPY_WRITE
  Verify that the array index is in range between 0 and the passed buffer size before writing to the passed
  buffer pointer.

\CM CM_DCM_R_GET_DIDINFOCONTEXT
  Dcm_Svc22GetDidInfoContext() will always return a valid Did info context even when the passed memory index is
  not a handle to a Did info context.

\CM CM_DCM_R_GET_CFGAUTHMGRNETCONNINFO
  Verify that the array index is in range before getting the mode switch function from Dcm_CfgAuthMgrNetConnInfo[].

\CM CM_DCM_R_GET_ROEEVENTMODESWITCHINFO
  Verify that the array index is in range before getting the mode switch function from Dcm_CfgModeRoEEventModeSwitchInfoTable[].

\CM CM_DCM_R_GET_RECOVERYINFOCOMMCHANNELSTATE
  Dcm_DiagGetRecoveryInfoComMChannelState() will return a valid ComM channel state of the recovery info, even when the
  passed memory index is not a handle to a ComM channel state of the recovery info.

\CM CM_DCM_R_GET_RECOVERYINFOCOMMCONTROLSTATE
  Dcm_DiagGetRecoveryInfoCommControlState() will return a valid communication state of a ComM channel of the recovery
  info, even when the passed memory index is not a handle to a communication state of a ComM channel of the recovery
  info.

\CM CM_DCM_R_CONVERTTOARRAY_PASS_BUFFER
  Verify that the passed pair of buffer pointer and buffer size matches to referenced memory entry and memory size.

\CM CM_DCM_R_CONVERTTOARRAY_WRITE
  Verify that the array index is in range between 0 and the passed buffer size before writing to the passed
  buffer pointer.

\CM CM_DCM_R_GET_VALID_POINTER
  The pointer concerned is initialized with a getter-function by memory index.
  The caller must explicitly verify that the initialization was successful before forwarding or writing to the pointer,
  unless when it can be guaranteed that the passed memory index is valid.

*/
/**********************************************************************************************************************
 *  END OF FILE: Dcm.c
 *********************************************************************************************************************/
